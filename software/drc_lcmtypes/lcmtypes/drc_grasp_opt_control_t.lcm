package drc;

struct grasp_opt_control_t // Usually published on INIT_GRASP_SEED to start/reset/halt drake optimization for single handed or bihanded grasping
{
    int64_t utime;    
    string robot_name; // parent robot name
    
    // unique way to associate a grasp with a object geometry in the scene
    // object_name + geometry name + "_lgrasp_" or "_rgrasp_"(grasp_type) + unique_hand_id;
    // e.g. steering_wheel_1_torus_lgrasp_1 where {object:"steering_wheel_1"} {geometry: "torus"}
    string object_name; 
    string geometry_name; 
    int32_t  unique_id;
    
    int16_t drake_control;
    const int16_t NEW=0, RESET=1, HALT=2; //interruption for reset or halting
        
    //The type of hand (left, right or both) to be used 
    int16_t grasp_type; // see constants below 
    
    // power grasp or precision grasp, for small objects a finger grasp is required.
    int16_t contact_mask;// see constants below 
    const int16_t ALL=0, FINGERS_ONLY=1; 
    
    //The type of object to be grasped
    int16_t geometry_type; // see constants below 
    const int16_t SPHERE=0, CYLINDER=1, BOX=2, TORUS=4; 
    int32_t num_dims;
    double dims[num_dims]; // sphere: dims = [radius]; cylinder: dims = [radius,length];box: dims = [span_x,span_y,span_z]; torus: dims = [radius,tube_radius];
    
    // initial positions of left/right hands in object frame;
    position_3d_t l_hand_init_pose; 
    position_3d_t r_hand_init_pose; 

    // the actual xyz location where the ray hit the affordance
    float ray_hit[3];

    const int16_t SANDIA_LEFT=0; 
    const int16_t SANDIA_RIGHT=1;
    const int16_t SANDIA_BOTH=2;
    const int16_t IROBOT_LEFT=3;
    const int16_t IROBOT_RIGHT=4;
    const int16_t IROBOT_BOTH=5;
    const int16_t ROBOTIQ_LEFT=6;
    const int16_t ROBOTIQ_RIGHT=7;
    const int16_t ROBOTIQ_BOTH=8;
    const int16_t INERT_LEFT=9;
    const int16_t INERT_RIGHT=10;
    const int16_t INERT_BOTH=11; // INERT for hook end effectors and stuff.

}


