package drc;

// usually published on CANDIDATE_GRASP 
// channel to seed sticky hands
struct desired_grasp_state_t  
{
  int64_t utime;  
  string robot_name;
  
  // unique way to associate a grasp with a object geometry in the scene
  // object_name + geometry name + "_grasp_" + unique_hand_id;
  // e.g. steering_wheel_1_torus_grasp_1 where
  // {object:"steering_wheel_1"} {geometry: "torus"}
  string object_name; 
  string geometry_name; 
  int8_t unique_id;
  
  int8_t grasp_type; // see constants below 
  const int8_t SANDIA_LEFT=0;
  const int8_t SANDIA_RIGHT=1;
  const int8_t SANDIA_BOTH=2;
  const int8_t IROBOT_LEFT=3;
  const int8_t IROBOT_RIGHT=4;
  const int8_t IROBOT_BOTH=5;

  // boolean to manually indicate to the controller 
  // that torque needs to set to maximum.
  boolean power_grasp; 
  
  // end effector position that realizes the grasp. 
  // Pose is used on CANDIDATE_GRASP to realize sticky hands
  // On COMMITTED_GRASP, the following poses may 
  // be used as funnels that trigger a grasp if 
  // current ee pose is within tolerance.  
  position_3d_t l_hand_pose; 
  position_3d_t r_hand_pose; 
  
  //joint angles for left hand   
  int8_t num_l_joints;
  string l_joint_name [num_l_joints];
  double l_joint_position [num_l_joints]; 
  
   //joint angles for right hand   
  int8_t num_r_joints;
  string r_joint_name [num_r_joints];
  double r_joint_position [num_r_joints];  

  // used to provide visual feedback
  int8_t optimization_status; 
  const int8_t RUNNING=0;
  const int8_t SUCCESS=1;
  const int8_t FAILURE=2;
}


