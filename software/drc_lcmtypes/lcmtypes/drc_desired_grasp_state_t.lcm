package drc;

struct desired_grasp_state_t  // usually published on CANDIDATE_GRASP channel to seed sticky hands
{
    int64_t utime;    
    string robot_name; // parent robot name
    
    // unique way to associate a grasp with a object geometry in the scene
    // object_name + geometry name + "_grasp_" + unique_hand_id;
    // e.g. steering_wheel_1_torus_grasp_1 where {object:"steering_wheel_1"} {geometry: "torus"}
    string object_name; 
    string geometry_name; 
    int32_t unique_id;
    
    int16_t grasp_type; // see constants below 
    const int16_t SANDIA_LEFT=0, SANDIA_RIGHT=1, SANDIA_BOTH=2, IROBOT_LEFT=3, IROBOT_RIGHT=4, IROBOT_BOTH=5;
    boolean power_grasp; // boolean to manually indicate to the controller that torque needs to set to maximum.
    
    // end effector position that realizes the grasp. 
    // Pose is used on CANDIDATE_GRASP to realize sticky hands
    // On COMMITTED_GRASP, the following poses may be used as funnels that trigger a grasp if current ee pose is within tolerance.  
    position_3d_t l_hand_pose; 
    position_3d_t r_hand_pose; 
    
    //joint angles for left hand     
    int32_t num_l_joints;
    string l_joint_name [num_l_joints];
    double l_joint_position [num_l_joints]; 
    
     //joint angles for right hand   
    int32_t num_r_joints;
    string r_joint_name [num_r_joints];
    double r_joint_position [num_r_joints];  
    
    int16_t optimization_status; // used to provide visual feedback
    const int16_t RUNNING=0, SUCCESS=1, FAILURE=2;
}


