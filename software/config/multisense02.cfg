coordinate_frames {
  root_frame = "local";

  head {
    # this cannot change - its rigid
    # forward facing scan at the same axis as the rotating scan - but fixed
    relative_to = "local";
    history = 1000;                       
    pose_update_channel= "POSE_HEAD";
    initial_transform{
      translation=[  0 , 0.0 , 0.0 ];
      rpy = [0.0 , 0.0 , 0.0 ];
    }
  }    
  
  # this is the pelvis link, its a legacy that its referred to as body
  body {
    relative_to = "head";
    history = 1000;
    update_channel = "HEAD_TO_BODY";  
    initial_transform{
      translation = [ 0, 0, 0 ];
      quat = [ 1, 0, 0, 0 ];
    }
  }
  
  ################## Sensor Frames ###################################
  CAMERA_LEFT {
    # this cannot change - its rigid
    relative_to = "head";
    history = 1000;
    update_channel = "HEAD_TO_LEFT_CAMERA_OPTICAL_FRAME";
    initial_transform{
      # location of left camera:
      # i dont think .....78242 is taken care of the URDF transforms...
      translation = [ 0.0, 0.035078242, -0.002];
      rpy = [ -90.0, 0.0, -90.0];      
    }
  }  
  
  CAMERA_RIGHT {
    relative_to = "CAMERA_LEFT";
    history = 1000;
    # Fixed, read from CRL camera
    update_channel = "CAMERA_LEFT_TO_CAMERA_RIGHT"; 
    initial_transform{
      translation = [ 0.0701564848423, 0.0, 0.0];
      rpy = [ 0.0, 0.0, 0.0];
    }
  }     
  
  
  ################## Path from Camera to Laser: ####################################
  PRE_SPINDLE {
    # multisense 02 calibration
    relative_to = "CAMERA_LEFT";
    history = 1000;
    update_channel = "CAMERA_LEFT_TO_PRE_SPINDLE";
    initial_transform{
      # rigid, read from sensor by mfallon, aug 2013
      translation = [ 0.034024, -0.107727, 0.008747 ];
      quat = [ 0.714312, -0.000002, 0.000000, 0.699827 ];
    }
  }    
  
  POST_SPINDLE {
    relative_to = "PRE_SPINDLE";
    history = 1000;
    update_channel = "PRE_SPINDLE_TO_POST_SPINDLE";
    initial_transform{
      # pure rotation transform
      translation = [ 0.0, 0.0, 0.0 ];
      quat = [ 1,0,0,0 ];
    }
  }      
  
  
  SCAN {
    # multisense 02 calibration
    relative_to = "POST_SPINDLE";
    history = 1000;
    update_channel = "POST_SPINDLE_TO_SCAN";
    initial_transform{
      translation = [ -0.000000, 0.018196, 0.000000 ];
      quat = [ 0.494188, -0.496592, -0.505789, -0.503341 ];
    }
  }   
  
  ################## Deprecated: ####################################
  #SCAN {
  #  relative_to = "CAMERA_LEFT";
  #  history = 1000;                       
  #  #update_channel = "HOKUYO_LINK_TO_HEAD_HOKUYO";
  #  update_channel = "CAMERA_TO_SCAN";    
  #  initial_transform{
  #    translation=[  0.03 , 0.0 , 0.015 ];
  #    rpy = [0.0 , 0.0 , 0.0 ];
  #  }
  #}    
  
  ## continously rotating link:
  #hokuyo_link {
  #  relative_to = "head";
  #  history = 1000;                       
  #  update_channel = "HEAD_TO_HOKUYO_LINK";
  #  initial_transform{
  #    translation=[  -0.0446 , 0.0 , 0.0880 ];
  #    rpy = [0.0 , 0.0 , 0.0 ];
  #  }
  #}  

  #SCAN_URDF {
  #  relative_to = "CAMERA_LEFT";
  #  history = 1000;                       
  #  #update_channel = "HOKUYO_LINK_TO_HEAD_HOKUYO";
  #  update_channel = "CAMERA_TO_SCAN_URDF";    
  #  initial_transform{
  #    translation=[  0.03 , 0.0 , 0.015 ];
  #    rpy = [0.0 , 0.0 , 0.0 ];
  #  }
  #}  
  
  # this shouldn't be necessary but it makes using bot_frames
  # easier than having to read planar_lidar too
  #SCAN_FREE {
  #  relative_to = "SCAN";
  #  history = 1000;                       
  #  update_channel = "HOKUYO_LINK_TO_HOKUYO_LINK_FREE";
  #  initial_transform{
  #    translation=[  0.0 , 0.0 , 0.0 ];
  #    rpy = [0.0 , 0.0 , 0.0 ];
  #  }
  #}  




 }




cameras {
  # fx fy skew cx cy 
  CAMERA_LEFT {
    # multisense 02 calibration
    lcm_channel = "CAMERA_LEFT";
    coord_frame = "CAMERA_LEFT";
    intrinsic_cal{
      width = 1024;
      height= 544;
      distortion_model = "plumb-bob";
      distortion_k = [0,0,0];
      distortion_p = [0,0];
      pinhole = [557.1886596679688, 557.1886596679688, 0, 512.0, 272.0];
    }
  }
  
  CAMERA_RIGHT {
    # multisense 02 calibration
    lcm_channel = "CAMERA_RIGHT";
    coord_frame = "CAMERA_RIGHT";
    intrinsic_cal{
      width = 1024;
      height= 544;
      distortion_model = "plumb-bob";
      distortion_k = [0,0,0];
      distortion_p = [0,0];
      pinhole = [557.1886596679688, 557.1886596679688, 0, 512.0, 272.0];
    }
  }  

  CAMERA {
    # multisense 02 calibration
    lcm_channel = "CAMERA";
    type = "stereo";
    rotation = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];
    translation = [-0.0701564848423, 0.0, 0.0]; # taken from CRL's calibration
  }
}


planar_lidars {
  SCAN {
    viewer_color = [ 1.0, 0.0, 0.0 ]; # red
    max_range = 29.0;
    min_range = 0.1;
    frequency = 40;
    laser_type = "HOKUYO_UTM";
    coord_frame = "SCAN";
    lcm_channel = "SCAN";
    # defaults for laser_renderer
    #surround_region = [0, 1e6];        
    up_region = [-1,-1];
    down_region = [-1, -1];
    max_range_free_dist = 29.0;
  }
  SCAN_FREE {
    viewer_color = [ 0.0, 0.0, 1.0 ]; # blue
    max_range = 29.0;
    min_range = 0.1;
    frequency = 40;
    laser_type = "HOKUYO_UTM";
    coord_frame = "SCAN";
    lcm_channel = "SCAN_FREE";
    # defaults for laser_renderer
    #surround_region = [0, 1e6];        
    up_region = [-1,-1];
    down_region = [-1, -1];
    max_range_free_dist = 29.0;
  }
}
