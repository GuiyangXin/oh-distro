
network {
  udp_frame_size_bytes=1024;

  # Testing:
  # target_rate_bps=10000000; # set to 10Mbps (essentially non-restrictive) 
  # disable_pmd_custom_codecs = true;
  # disable_ers_custom_codecs = true;
  # disable_robot_plan_custom_codecs=true;

  #target_rate_bps=1000000; # set to 1Mbps (a little restrictive) 
  #disable_pmd_custom_codecs = false;
  #disable_ers_custom_codecs = true;
  #disable_robot_plan_custom_codecs= true;

  # Competition:
  target_rate_bps=95000; # set to 95kbps - competition (should be same as throughput_bps below for 250 ms latency case)
  fallback_seconds=50; # after these number of seconds at a rate other than the target_rate_bps (i.e. set adaptively for lower latency/higher throughput case), set back to target_rate_bps
  disallow_rate_change_seconds=15;

  disable_pmd_custom_codecs = false; #Procman custom compression
  disable_ers_custom_codecs = false; #EST_ROBOT_STATE custom compression
  disable_robot_plan_custom_codecs= false;

  latency=[50, 500];
  throughput_bps=[950000, 95000];

  expected_packet_loss_percent=5;

  robot {
      udp_host="172.19.5.2"; # Field Computer 1
      udp_port=9000;
  }
  base {
      udp_host="172.19.5.1"; # Main OCU
      udp_port=9001;
  }

  manipulation {
    robot_to_base {
      ########################################
      channels_a=["CAMERA_LEFT_TX","CAMERA_RIGHT_TX",
                  "CAMERALHAND_LEFT_TX", "CAMERARHAND_LEFT_TX",
                  "CAMERACHEST_LEFT_TX", "CAMERACHEST_RIGHT_TX",  
                  "CAMERA_LEFT_SUB","CAMERACHEST_LEFT_SUB","CAMERACHEST_RIGHT_SUB",
                  "MAP_OCTREE","MAP_CLOUD","MAP_DEPTH", "OGG_SERVER",
                  "MAP_CATALOG","MAP_LOCAL_CORRECTION",
                  "SYSTEM_STATUS","POSE_TAG",
                  "AFFORDANCE_PLUS_BASE_OVERWRITE","PMD_PRINTF_REPLY"];
      frequency_a=0.0;
      buffer_size_a=1;
      priority_a=0;

      ########################################
      channels_b=["PMD_INFO2"];
      frequency_b=0.0;
      buffer_size_b=10;
      priority_b=0;

      ########################################
      channels_c=["FREQUENCY_LCM", "ATLAS_STATUS", "CONTROLLER_STATUS"];
      frequency_c=1.0;
      buffer_size_c=1;
      priority_c=0;

      ########################################
      channels_d=["EST_ROBOT_STATE"];
      frequency_d=4.0;
      buffer_size_d=1;
      priority_d=2;
    }

    base_to_robot {
      ########################################
      channels_a=["MAP_REQUEST","SENSOR_REQUEST","SUBIMAGE_REQUEST",
                  "CAMERA_SETTINGS","MAP_DEPTH_SETTINGS",
                  "COMMITTED_FOOTSTEP_PLAN","PMD_ORDERS","PMD_ORDERS2","DATA_REQUEST",
                  "COMMITTED_ROBOT_PLAN","COMMITTED_GRASP",
                  "AFFORDANCE_PLUS_BOT_OVERWRITE","GAZE_COMMAND",
                  "DESIRED_NECK_PITCH","SIMPLE_GRASP_COMMAND",
                  "COMMITTED_MANIP_GAIN","COMMITTED_POSTURE_PRESET",
                  "PMD_PRINTF_REQUEST", "COMMITTED_PLAN_PAUSE","RECOVERY_CMD",
                  "COMMITTED_EE_ADJUSTMENT", "CONTROLLER_MODE", "MAP_CONTROLLER_COMMAND",
                  "COMMITTED_MANIP_MAP","MOTIONEST_REQUEST", "STOP_WALKING",
                  "MULTISENSE_COMMAND", "MAP_REQUEST_BBOX",
                  "IROBOT_LEFT_SIMPLE_GRASP", "IROBOT_RIGHT_SIMPLE_GRASP", 
                  "SANDIA_LEFT_SIMPLE_GRASP", "SANDIA_RIGHT_SIMPLE_GRASP", 
                  "IROBOT_RIGHT_CALIBRATE", "IROBOT_RIGHT_SPREAD", 
                  "IROBOT_RIGHT_POSITION_CONTROL_CLOSE", "IROBOT_RIGHT_CURRENT_CONTROL_CLOSE",
                  "IROBOT_LEFT_CALIBRATE", "IROBOT_LEFT_SPREAD",
                  "IROBOT_LEFT_POSITION_CONTROL_CLOSE", "IROBOT_LEFT_CURRENT_CONTROL_CLOSE",
                  "ROBOTIQ_LEFT_COMMAND", "ROBOTIQ_RIGHT_COMMAND",
                  "OGG_CLIENT", "PLAN_USING_BDI_HEIGHT",
                  "ATLAS_BEHAVIOR_COMMAND", "ATLAS_MANIPULATE_PARAMS", 
                  "CALIBRATE_ARM_ENCODERS","RESET_DRIVER_SAFETY"];
      frequency_a=0.0;
      buffer_size_a=10;
      priority_a=1;

      ########################################
      # send this so there's some constant traffic for the robot
      # to estimate latency from
      channels_b=["BASE_UTIME"];
      frequency_b=1.0;
      buffer_size_b=1;
      priority_b=0;

      ########################################
      channels_c=[];
      frequency_c=[1.0];
      buffer_size_c=1;
      priority_c=0;

      ########################################
      channels_d=[];
      frequency_d=[1.0];
      buffer_size_d=1;
      priority_d=0;
    }  
  }
}

frequency_tool {
    LCM { # must be caps | channels_short must be 4 chars
        #NBNBNB: dont change this list - its hard coded for easy transmission from robot to base
        channels       = ["EST_ROBOT_STATE","ATLAS_COMMAND","CAMERA","SCAN"];
        channels_short = ["ERS "           ,"ACOM"         ,"HEAD"  ,"SCAN"]; 
    }
}

driving {
    control {
        lookahead_distance_default = 11.0;
        kp_steer_default = 6.0;
    }
}

viewer {
  renderer_groups {
    manipulation {
      name="Manipulation";
      enabled=["BOT_FRAMES","Grid", "Maps", "Robot State Display","Robot Plan Display", "Data Control",
          "Affordances & StickyHands/Feet", "Collections" ];
    }

    walking {
      name="Walking";
      enabled=[ "BOT_FRAMES","Grid", "Maps", "Robot State Display","Robot Plan Display", "Data Control", "Walking",
          "Footstep Plans & Stick Feet" ];
    }
  }

  datacontrol_presets {

    all {
      label = "All";
      Camera_Head     { enable = 1;  period = 1;  quality = 1; }
      Camera_L_Chest  { enable = 1;  period = 1;  quality = 1; }
      Camera_R_Chest  { enable = 1;  period = 1;  quality = 1; }
      Scene_Height    { enable = 1;  period = 1; }
      Scene_Depth     { enable = 1;  period = 1; }
      Workspace_Depth { enable = 1;  period = 1;  fov = 90;  yaw = 0; }
    }

    camera_only {
      label = "Camera Only";
      Camera_Head     { enable = 1;  period = 1;  quality = 1; }
      Camera_L_Chest  { enable = 0;  period = 0;  quality = 1; }
      Camera_R_Chest  { enable = 0;  period = 0;  quality = 1; }
      Scene_Height    { enable = 0;  period = 0; }
      Scene_Depth     { enable = 0;  period = 0; }
      Workspace_Depth { enable = 0;  period = 0; }
    }

    camera_lidar {
      label = "Camera + Hi Lidar";
      Camera_Head     { enable = 1;  period = 1;  quality = 1; }
      Camera_L_Chest  { enable = 1;  period = 5;  quality = 1; }
      Camera_R_Chest  { enable = 1;  period = 5;  quality = 1; }
      Scene_Height    { enable = 0;  period = 0; }
      Scene_Depth     { enable = 0;  period = 0; }
      Workspace_Depth { enable = 1;  period = 1; }
    }

    camera_low_lidar {
      label = "Camera + Low Lidar";
      Camera_Head     { enable = 1;  period = 1;  quality = 1; }
      Camera_L_Chest  { enable = 1;  period = 5;  quality = 1; }
      Camera_R_Chest  { enable = 1;  period = 5;  quality = 1; }
      Scene_Height    { enable = 0;  period = 0; }
      Scene_Depth     { enable = 0;  period = 0; }
      Workspace_Depth { enable = 1;  period = 5; }
    }
  }
}




state_estimator {

  pose_channel = "STATE_ESTIMATOR_POSE";
  filter_state_channel = "STATE_ESTIMATOR_STATE";
  publish_filter_state = true; #publish alongside pose
  publish_pose = true;
  republish_sensors = false; # if using a log
  init_sensors = ["ins"];
  #"laser_gpf","ins","rgbd_gpf"
  #active_sensors = ["ins"];
  #active_sensors = ["ins","rgbd_gpf"];
  #active_sensors = ["ins","fovis","rgbd_gpf"];
  #active_sensors = ["ins","fovis"];
  #active_sensors = ["ins","laser_gpf","rgbd_gpf","fovis"];
  #active_sensors = ["ins","laser_gpf"];
  active_sensors = ["ins","legodo"];

  utime_history_span =1000000;

  #initial state estimate (relavent states overridden by init sensors)
  sigma0 {
          vb = 0.15; #m/s
          chi_xy = 3.0; #degrees
          chi_z = 3.0; #degrees
          Delta_xy = .5; #m
          Delta_z = 1;    #m
          
          gyro_bias = 0; #deg/seg
          accel_bias = 0; #m/s^2
  }

  #vicon area:
  #x0 {
  #  velocity = [0,0,0];
  #  angular_velocity = [0,0,0];
  #  position = [0, 0, 0];
  #  rpy = [0, 0, 0];
  #}

  # original stairwell map:
  #x0 {
  #  velocity = [0,0,0];
  #  angular_velocity = [0,0,0];
  #  position = [3.4, 0, 0.02];
  #  rpy = [0, 0, 0];
  #}

  # icra2013 stairwell map:
  x0 {
    velocity = [0,0,0];
    angular_velocity = [0,0,0];
    position = [21.0, -1.15, 0.02];
    rpy = [0, 0, 1.57];
  }

  init_message {
    channel = "MAV_STATE_EST_INITIALIZER";
  }

  viewer {
    channel = "MAV_STATE_EST_VIEWER_MEASUREMENT";
    utime_offset = 0; #units 1e-6 seconds
    downsample_factor = 1; # process 1 out of every this many
    roll_forward_on_receive = true;
    publish_head_on_message = true;
  }

  ins {
    channel = "MICROSTRAIN_INS";
    utime_offset = 0; #units 1e-6 seconds
    downsample_factor = 1; # process 1 out of every this many
    roll_forward_on_receive = true;
    publish_head_on_message = true;

    q_gyro = 0.5; #deg/sec
    q_accel = 0.2; #m/s^2       
    q_gyro_bias = 0; #deg/seg^2
    q_accel_bias = 0; #m/sec^2/sec
    frame = "imu";
    
    #ms     
    #timestep_dt = 0.01; # REMEMBER TO CHANGE THIS IF YOU CHANGE THE IMU FREQUENCY or downsample factor
    #bdi
    timestep_dt = 0.003; # REMEMBER TO CHANGE THIS IF YOU CHANGE THE IMU FREQUENCY or downsample factor
    
    num_to_init = 300; # was 100
  }

  gps{
    channel = "UBLOX_GPS_DATA";
    #utime_offset = 273200; #.27 second delay optimized for on 11-05-03-outdoors.01
    utime_offset = 145000; #.145 second delay from fixie-gps-2012-05-12.02
    #utime_offset = 0;
    downsample_factor = 1; # process 1 out of every this many
    roll_forward_on_receive = true;
    publish_head_on_message = false;

    r_xy = 2.0; #m
    r_z = 2.0; #m
  }

  vicon{
    channel = "VICON_fixie";
    utime_offset = 0; #units 1e-6 seconds
    downsample_factor = 10; # process 1 out of every this many
    roll_forward_on_receive = true;
    publish_head_on_message = false;

    r_xyz = .01; #m
    r_chi = 3.0; #degrees
    

  }

  laser_gpf_out_of_process { 
    utime_offset = 0; 
    downsample_factor = 1; 
    channel = "GPF_MEASUREMENT";
    roll_forward_on_receive = true;
    publish_head_on_message = false;
  }

  laser_gpf {
    utime_offset = 0; 
    downsample_factor = 3; 
    channel = "LASER";
    roll_forward_on_receive = true;
    publish_head_on_message = false;

    # sept 2012 era
    #map_name = "/media/passport1/data/other/sensor_rig/octomaps/stairarea/stata_lights_3/octomap.bt_blurred_0.5";          
    # icra 2013 paper:
    map_name = "/media/passport1/data/other/sensor_rig/octomaps/stairarea/icra_octomap/icra_octomap.bt_blurred_0.5";        
    # made by charlie on 03-10-2012
    #map_name = "/media/passport1/data/other/sensor_rig/2012-10-03-rig-vicon-fixie/occmap/octomap.bt_blurred_0.5";          
    # adam used map_name = "octomap.25.bt_blurred_0.5";
    #map_name = "octomap.1.bt_blurred_0.5";
    gpf_vis = true;

    # 300 is bare min
    gpf_num_samples = 500;
    
    # according to abe:
    # pos_only - less accurate
    # pos_yaw  - sufficient/typical for fixie
    # pos_chi  - more accurate, use this initially for kmcl
    gpf_substate = "pos_yaw";
    
    #laser projection settings
    beam_skip = 16;
    spatial_decimation_min = 0;
    spatial_decimation_max = .5;
    
    #-----------gpf probability settings-----------
    
    #log-likelihood of an unknown cell in the map
    unknown_loglike = -12.0; #original value used for johnson/parking garage 2012-5-13
    
    #gpf cov is scaled by sigma_scaling^2 via division of summed log probabilities
    sigma_scaling = 8.16; #should be identical to "adams magic scaling factor used for johnson/parking garage 2012-5-13
  }


  rgbd_gpf { 
    utime_offset = 0; #units 1e-6 seconds   
    #if running in a separate process the downsampling is applied before processing, and as many as can be processed will be (it will hog cpu)
    # laser 40Hz df: 3 | rgbd 10Hz df: 1
    downsample_factor = 1; # process 1 out of every this many laser readings (come at 40hz)

    #channel = "RGBD_GPF_MEASUREMENT";
    channel = "KINECT_FRAME";
    roll_forward_on_receive = true;
    publish_head_on_message = false;
    
    
    # sept 2012 era
    #map_name = "/media/passport1/data/other/sensor_rig/octomaps/stairarea/stata_lights_3/octomap.bt_blurred_0.5";          
    # icra 2013 paper:
    map_name = "/media/passport1/data/other/sensor_rig/octomaps/stairarea/icra_octomap/icra_octomap.bt_blurred_0.5";        
    # made by charlie on 03-10-2012
    #map_name = "/media/passport1/data/other/sensor_rig/2012-10-03-rig-vicon-fixie/occmap/octomap.bt_blurred_0.5";          
    # adam used map_name = "octomap.25.bt_blurred_0.5";
    #map_name = "octomap.1.bt_blurred_0.5";
    gpf_vis = true;

    # 300 is bare min
    gpf_num_samples = 500; 
    
    # according to abe:
    # pos_only - less accurate
    # pos_yaw  - sufficient/typical for fixie
    # pos_chi  - more accurate, use this initially for kmcl
    gpf_substate = "pos_yaw";
    
    #laser projection settings
    beam_skip = 16;
    spatial_decimation_min = 0;
    spatial_decimation_max = .5;
    
    #-----------gpf probability settings-----------
    
    #log-likelihood of an unknown cell in the map
    unknown_loglike = -12.0; #original value used for johnson/parking garage 2012-5-13
    
    #gpf cov is scaled by sigma_scaling^2 via division of summed log probabilities
    sigma_scaling = 8.16; #should be identical to "adams magic scaling factor used for johnson/parking garage 2012-5-13
  }


  fovis {

    channel = "KINECT_REL_ODOMETRY";
    mode = "lin_rate"; # linear and rotation rates i.e. velocities
    
    # velocity variances:
    # 0.50 looks good for very difficult logs
    r_vxyz = 5.0;  # m/s
    # scan matchered used 1.0
    r_vang  = 0.50;  # degrees?

    utime_offset = 0;
    downsample_factor = 1;
    roll_forward_on_receive = true;
    publish_head_on_message = false;
  }

  legodo {

    channel = "EST_ROBOT_STATE";
    mode = "lin_rot_rate"; # linear and rotation rates i.e. velocities
    
    # velocity variances:
    # 0.50 looks good for very difficult logs
    r_vxyz = 1.0;  # m/s
    # was using 5.0
    # scan matchered used 1.0
    r_vang  = 0.50;  # degrees?

    utime_offset = 0;
    downsample_factor = 1;
    roll_forward_on_receive = true;
    publish_head_on_message = false;
    
    # basic, slaved_once, slaved_always
    integration_mode = "basic"; 
  }
  
  legodo_external {

    # Channel Subscribed to:
    channel = "LEG_ODOMETRY_DELTA";
    
    # All other parameters are taken from legodo block
  }  
  
}
