coordinate_frames {
  root_frame = "local";

  global {
      relative_to = "local";
      history = 1000;
      update_channel = "GLOBAL_TO_LOCAL";
      initial_transform {
          translation = [0, 0, 0 ];
          quat = [1, 0, 0, 0];
      }
  }

  head {
    # this cannot change - its rigid
    # forward facing scan at the same axis as the rotating scan - but fixed
    relative_to = "local";
    history = 1000;                       
    pose_update_channel= "POSE_HEAD";
    initial_transform{
      translation=[  0 , 0.0 , 0.0 ];
      rpy = [0.0 , 0.0 , 0.0 ];
    }
  }    
  
  body {
    relative_to = "head";
    history = 1000;
    update_channel = "HEAD_TO_BODY";  
    initial_transform{
      translation = [ 0, 0, 0 ];
      quat = [ 1, 0, 0, 0 ];
    }
  }

  car {
    relative_to = "body";
    history = 1000;
    update_channel = "CAR_TO_BODY";  
    initial_transform{
      translation = [ 0, -0.3, 0 ];
      quat = [ 1, 0, 0, 0 ];
    }
  }
  
  
  # Show what the ground height infered from the feet height is
  ground {
    relative_to = "local";
    history = 1000;
    pose_update_channel= "POSE_GROUND";
    initial_transform{
      translation=[  0 , 0.0 , 0.0 ];
      rpy = [0.0 , 0.0 , 0.0 ];
    }
  }  

  ################## Sensor Frames ###################################
  # continously rotating link:
  hokuyo_link {
    relative_to = "head";
    history = 1000;                       
    update_channel = "HEAD_TO_HOKUYO_LINK";
    initial_transform{
      translation=[  -0.0446 , 0.0 , 0.0880 ];
      rpy = [0.0 , 0.0 , 0.0 ];
    }
  }  

  # fixed link:
  SCAN {
    relative_to = "hokuyo_link";
    history = 1000;                       
    update_channel = "HOKUYO_LINK_TO_HEAD_HOKUYO";
    initial_transform{
      translation=[  0.03 , 0.0 , 0.015 ];
      rpy = [0.0 , 0.0 , 0.0 ];
    }
  }  

  # this shouldn't be necessary but it makes using bot_frames
  # easier than having to read planar_lidar too
  SCAN_FREE {
    relative_to = "SCAN";
    history = 1000;                       
    update_channel = "HOKUYO_LINK_TO_HOKUYO_LINK_FREE";
    initial_transform{
      translation=[  0.0 , 0.0 , 0.0 ];
      rpy = [0.0 , 0.0 , 0.0 ];
    }
  }  

  CAMERA {
    # this cannot change - its rigid
    relative_to = "head";
    history = 1000;
    update_channel = "HEAD_TO_LEFT_CAMERA_OPTICAL_FRAME";
    initial_transform{
      # location of left camera:
      translation = [ 0.0, 0.035, -0.002];
      rpy = [ -90.0, 0.0, -90.0];
    }
  }

  CAMERARIGHT {
    relative_to = "head";
    history = 1000;
    update_channel = "HEAD_TO_RIGHT_CAMERA_OPTICAL_FRAME"; 
    initial_transform{
      translation = [0.0, -0.035, -0.002];
      rpy = [ -90.0, 0.0, -90.0];
    }
  }   
  
  LHAND {
    relative_to = "body";
    history = 1000;
    update_channel = "BODY_TO_LHAND";
    initial_transform{  # initial transform is useless as it always changes
      translation = [ 0.0, 0.0, 0.0];
      rpy = [ 0.0, 0.0, 0.0]; 
    }
  }  

  RHAND {
    relative_to = "body";
    history = 1000;
    update_channel = "BODY_TO_RHAND";
    initial_transform{  # initial transform is useless as it always changes
      translation = [ 0.0, 0.0, 0.0];
      rpy = [ 0.0, 0.0, 0.0]; 
    }
  }
  
  ################## Development and Visualization Frames #############################
  head_vicon {
    relative_to = "local";
    history = 1000;
    pose_update_channel= "POSE_HEAD_VICON";
    initial_transform{
      translation=[  0 , 0.0 , 0.0 ];
      rpy = [0.0 , 0.0 , 0.0 ];
    }
  }

  head_vo {
    relative_to = "local";
    history = 1000;
    pose_update_channel= "POSE_HEAD_VO";
    initial_transform{
      translation=[  0 , 0.0 , 0.0 ];
      rpy = [0.0 , 0.0 , 0.0 ];
    }
  }

  body_vo {
    relative_to = "local";
    history = 1000;
    pose_update_channel= "POSE_BODY_VO";
    initial_transform{
      translation=[  0 , 0.0 , 0.0 ];
      rpy = [0.0 , 0.0 , 0.0 ];
    }
  }  
  
  # Torso IMU orientation-only Pose: (zero xyz)
  torso_orient{
    relative_to = "local";
    history = 1000;
    pose_update_channel = "POSE_BODY_ORIENT";      #bot_core_pose_t messages will be listened for this channel
    initial_transform{
      translation = [ 0, 0, 0 ];
      quat = [ 1, 0, 0, 0 ];
    }
  }

  # Head IMU orientation-only Pose: (zero xyz)
  head_orient{
    relative_to = "local";
    history = 1000;
    pose_update_channel = "POSE_HEAD_ORIENT";      #bot_core_pose_t messages will be listened for this channel
    initial_transform{
      translation = [ 0, 0, 0 ];
      quat = [ 1, 0, 0, 0 ];
    }
  }  

  # Ground Truth Position of the Robot
  body_true {
    relative_to = "local";
    history = 1000;
    pose_update_channel = "POSE_BODY_TRUE";      #bot_core_pose_t messages will be listened for this channel
    initial_transform{
      translation = [ 0, 0, 0 ];
      quat = [ 1, 0, 0, 0 ];
    }
  }
  
  # Ground Truth Position of the Head
  head_true {
    relative_to = "local";
    history = 1000;
    pose_update_channel = "POSE_HEAD_TRUE";      #bot_core_pose_t messages will be listened for this channel
    initial_transform{
      translation = [ 0, 0, 0 ];
      quat = [ 1, 0, 0, 0 ];
    }
  }  

}




cameras {
    # Stereo Pair:
    # fx fy skew cx cy 
    # gazebo_ros_camera_utils.cpp, 
    # 1.5708 (90degrees) as of 6dec 2012
    # 1.3962634 (80degrees) in april 2013
    # fx = fy = w / (2 * tan( hfov/2))
    # cx = (w+1)/2  |  cy = (h+1)/2
    CAMERA {
      lcm_channel = "CAMERA";
      coord_frame = "CAMERA";
      type = "stereo";

      left {
          width = 800;
          height= 800;
          distortion_model = "plumb";
          fx = 476.7014;
          fy = 476.7014;
          cx = 400.5;
          cy = 400.5;
          k1 = 0.0;
          k2 = 0.0;
          k3 = 0.0;
          p1 = 0.0;
          p2 = 0.0;
      }

      right {
          width = 800;
          height= 800;
          distortion_model = "plumb";
          fx = 476.7014;
          fy = 476.7014;
          cx = 400.5;
          cy = 400.5;
          k1 = 0.0;
          k2 = 0.0;
          k3 = 0.0;
          p1 = 0.0;
          p2 = 0.0;
      }
      rotation = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];
      translation = [-0.07, 0.0, 0.0];
    }

    CAMERA_LHAND {
      lcm_channel = "CAMERA_LHAND";
      coord_frame = "LHAND";
      type = "stereo";

      left {
        width = 752;
        height= 480;
        distortion_model = "plumb";
        fx = 517.5196;
        fy = 517.5196;
        cx = 376.5;
        cy = 240.5;
        k1 = 0.0;
        k2 = 0.0;
        k3 = 0.0;
        p1 = 0.0;
        p2 = 0.0;      
      }

      right {
        width = 752;
        height= 480;
        distortion_model = "plumb";
        fx = 517.5196;
        fy = 517.5196;
        cx = 376.5;
        cy = 240.5;
        k1 = 0.0;
        k2 = 0.0;
        k3 = 0.0;
        p1 = 0.0;
        p2 = 0.0;  
      }
      rotation = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];
      translation = [-0.04, 0.0, 0.0];
    }    
    

    CAMERA_RHAND {
      lcm_channel = "CAMERA_RHAND";
      coord_frame = "RHAND";
      type = "stereo";

      left {
        width = 752;
        height= 480;
        distortion_model = "plumb";
        fx = 517.5196;
        fy = 517.5196;
        cx = 376.5;
        cy = 240.5;
        k1 = 0.0;
        k2 = 0.0;
        k3 = 0.0;
        p1 = 0.0;
        p2 = 0.0;      
      }

      right {
        width = 752;
        height= 480;
        distortion_model = "plumb";
        fx = 517.5196;
        fy = 517.5196;
        cx = 376.5;
        cy = 240.5;
        k1 = 0.0;
        k2 = 0.0;
        k3 = 0.0;
        p1 = 0.0;
        p2 = 0.0;  
      }
      rotation = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];
      translation = [-0.04, 0.0, 0.0];
    }     
    
    CAMERALEFT {
      lcm_channel = "CAMERALEFT";
      coord_frame = "CAMERA";

      intrinsic_cal{
        width = 800;
        height= 800;
        distortion_model = "plumb-bob";
        fx = 476.7014;
        fy = 476.7014;
        cx = 400.5;
        cy = 400.5;
        k1 = 0.0;
        k2 = 0.0;
        k3 = 0.0;
        p1 = 0.0;
        p2 = 0.0;

        distortion_k = [0,0,0];
        distortion_p = [ 0,0];
        pinhole = [  476.7014,   476.7014, 0, 400.5, 400.5];
      }
    }


    CAMERARIGHT {
      lcm_channel = "CAMERARIGHT";
      coord_frame = "CAMERARIGHT";

      intrinsic_cal{
        width = 800;
        height= 800;
        distortion_model = "plumb-bob";
        fx = 476.7014;
        fy = 476.7014;
        cx = 400.5;
        cy = 400.5;
        k1 = 0.0;
        k2 = 0.0;
        k3 = 0.0;
        p1 = 0.0;
        p2 = 0.0;

        distortion_k = [0,0,0];
        distortion_p = [ 0,0];
        pinhole = [  476.7014,   476.7014, 0, 400.5, 400.5];
      }
    }    
    
    CAMERA_LHANDLEFT {
      lcm_channel = "CAMERA_LHANDLEFT";
      coord_frame = "LHAND";
      
      intrinsic_cal{
        width = 752;
        height= 480;
        distortion_model = "plumb-bob";
        fx = 517.5196;
        fy = 517.5196;
        cx = 376.5;
        cy = 240.5;
        k1 = 0.0;
        k2 = 0.0;
        k3 = 0.0;
        p1 = 0.0;
        p2 = 0.0;

        distortion_k = [0,0,0];
        distortion_p = [ 0,0];
        pinhole = [  517.5196,   517.5196, 0, 376.5, 240.5];
      }
    }
    CAMERA_RHANDLEFT {
      lcm_channel = "CAMERA_RHANDLEFT";
      coord_frame = "RHAND";
      
      intrinsic_cal{
        width = 752;
        height= 480;
        distortion_model = "plumb-bob";
        fx = 517.5196;
        fy = 517.5196;
        cx = 376.5;
        cy = 240.5;
        k1 = 0.0;
        k2 = 0.0;
        k3 = 0.0;
        p1 = 0.0;
        p2 = 0.0;

        distortion_k = [0,0,0];
        distortion_p = [ 0,0];
        pinhole = [  517.5196,   517.5196, 0, 376.5, 240.5];
      }      
    }

    ########################################################################################################
    ########################################################################################################
    ########################################################################################################
    # the real sensor head on multisense loaner - letterbox removed
    stereo {
      lcm_channel = "MULTISENSE_LR"; # only for Left/Right currently
      coord_frame = "CAMERA";
      type = "stereo";

      left {

          #  left_cam_info_.P[0] = msg->fx;   left_cam_info_.P[1] =     0.0;   left_cam_info_.P[2] = msg->width/2.0;   left_cam_info_.P[3] = 0.0;
          #  left_cam_info_.P[4] =     0.0;   left_cam_info_.P[5] = msg->fy;   left_cam_info_.P[6] = msg->height/2.0;  left_cam_info_.P[7] = 0.0;
          #  left_cam_info_.P[8] =     0.0;   left_cam_info_.P[9] =     0.0;   left_cam_info_.P[10]= 1.0;  left_cam_info_.P[11]= 0.0;
          width = 1024;
          height = 544;
          distortion_model = "plumb";
          fx = 606.0344848632812;
          fy = 606.0344848632812;
          cx = 512.0; # should this have another 0.5?
          cy = 272.0; # should this have another 0.5?
          k1 = 0.0;
          k2 = 0.0;
          k3 = 0.0;
          p1 = 0.0;
          p2 = 0.0;
      }

      right {
          width = 1024;
          height = 544;
          distortion_model = "plumb";
          fx = 606.0344848632812;
          fy = 606.0344848632812;
          cx = 512.0; # should this have another 0.5?
          cy = 272.0; # should this have another 0.5?
          k1 = 0.0;
          k2 = 0.0;
          k3 = 0.0;
          p1 = 0.0;
          p2 = 0.0;
      }
      rotation = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];
      translation = [-0.07, 0.0, 0.0];
    }

    # the real sensor head on multisense loaner - with letterbox
    stereo_with_letterbox {
      lcm_channel = "CAMERA";
      coord_frame = "CAMERA";
      type = "stereo";

      left {

          #  left_cam_info_.P[0] = msg->fx;   left_cam_info_.P[1] =     0.0;   left_cam_info_.P[2] = msg->width/2.0;   left_cam_info_.P[3] = 0.0;
          #  left_cam_info_.P[4] =     0.0;   left_cam_info_.P[5] = msg->fy;   left_cam_info_.P[6] = msg->height/2.0;  left_cam_info_.P[7] = 0.0;
          #  left_cam_info_.P[8] =     0.0;   left_cam_info_.P[9] =     0.0;   left_cam_info_.P[10]= 1.0;  left_cam_info_.P[11]= 0.0;
          width = 1024;
          height = 1088;
          distortion_model = "plumb";
          fx = 606.0344848632812;
          fy = 606.0344848632812;
          cx = 512.0; # should this have another 0.5?
          cy = 544.0; # should this have another 0.5?
          k1 = 0.0;
          k2 = 0.0;
          k3 = 0.0;
          p1 = 0.0;
          p2 = 0.0;
      }

      right {
          width = 1024;
          height = 1088;
          distortion_model = "plumb";
          fx = 606.0344848632812;
          fy = 606.0344848632812;
          cx = 512.0; # should this have another 0.5?
          cy = 544.0; # should this have another 0.5?
          k1 = 0.0;
          k2 = 0.0;
          k3 = 0.0;
          p1 = 0.0;
          p2 = 0.0;
      }
      rotation = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];
      translation = [-0.07, 0.0, 0.0];
    }


    # just used to integrate with viewer
    REGISTERATION {
      lcm_channel = "REGISTERATION";
      coord_frame = "CAMERA";
    }
}


planar_lidars {
  SCAN {
    viewer_color = [ 1.0, 0.0, 0.0 ]; # red
    max_range = 29.0;
    min_range = 0.1;
    frequency = 40;
    laser_type = "HOKUYO_UTM";
    coord_frame = "SCAN";
    lcm_channel = "SCAN";
    # defaults for laser_renderer
    surround_region = [0, 1e6];        
    up_region = [-1,-1];
    down_region = [-1, -1];
    max_range_free_dist = 29.0;
  }
  SCAN_FREE {
    viewer_color = [ 0.0, 0.0, 1.0 ]; # blue
    max_range = 29.0;
    min_range = 0.1;
    #angle_range = [135, -135];
    #down_region = [1068, 1078];
    up_region = [-1,-1];
    #surround_region = [0, 640];        
    frequency = 40;
    laser_type = "HOKUYO_UTM";
    coord_frame = "SCAN";
    lcm_channel = "SCAN_FREE";
    # defaults for laser_renderer
    surround_region = [0, 1e6];        
    up_region = [-1,-1];
    down_region = [-1, -1];
    max_range_free_dist = 29.0;
  }
}

# Options for fovis
fovis {
  feature-window-size = 9;
  max-pyramid-level = 6;
  min-pyramid-level = 2;
  target-pixels-per-feature = 200;
  fast-threshold = 10;
  fast-threshold-adaptive-gain = 0.002;
  use-adaptive-threshold = "true";
  use-homography-initialization = "true";
  ref-frame-change-threshold = 100; #100; #150;

  # OdometryFrame
  use-bucketing = "true";
  bucket-width = 20;
  bucket-height = 20;
  max-keypoints-per-bucket = 10;
  use-image-normalization = "false";

  # MotionEstimator
  inlier-max-reprojection-error = 2.0;
  clique-inlier-threshold = 0.15;
  min-features-for-estimate = 10;
  max-mean-reprojection-error = 3.0;
  use-subpixel-refinement = "true";
  feature-search-window = 25;
  update-target-features-with-refined = "false";

  # StereoDepth
  stereo-require-mutual-match = "true";
  stereo-max-dist-epipolar-line = 2.0;
  stereo-max-refinement-displacement = 2.0;
  stereo-max-disparity = 128;
}

network {
  udp_frame_size_bytes=1024;
  target_rate_bps=3200000;
  channel_buffer_size=100;
  expected_packet_loss_percent=5;
  # Joint names to be paired with joint angles - eventually this will be taken care of by goby
  # NB: keep this in sync with the angles coming from Gazebo as OSFR like to change them to keep us on our toes!
  joint_names=["back_lbz", "back_mby", "back_ubx", "neck_ay", "l_leg_uhz", "l_leg_mhx", "l_leg_lhy", 
              "l_leg_kny", "l_leg_uay", "l_leg_lax", "r_leg_uhz", "r_leg_mhx", "r_leg_lhy", "r_leg_kny", 
              "r_leg_uay", "r_leg_lax", "l_arm_usy", "l_arm_shx", "l_arm_ely", "l_arm_elx", "l_arm_uwy", 
              "l_arm_mwx", "r_arm_usy", "r_arm_shx", "r_arm_ely", "r_arm_elx", "r_arm_uwy", "r_arm_mwx", 
              "hokuyo_joint", "left_f0_j0", "left_f0_j1", "left_f0_j2", "left_f1_j0", "left_f1_j1", "left_f1_j2", 
              "left_f2_j0", "left_f2_j1", "left_f2_j2", "left_f3_j0", "left_f3_j1", "left_f3_j2", "right_f0_j0", 
              "right_f0_j1", "right_f0_j2", "right_f1_j0", "right_f1_j1", "right_f1_j2", "right_f2_j0", "right_f2_j1", 
              "right_f2_j2", "right_f3_j0", "right_f3_j1", "right_f3_j2"];
  robot {
#      udp_host="11.8.0.1"; # bullpen setup # stop commiting this Sachi!!!!
      udp_host="10.0.0.52"; # softlayer 
      udp_port=9000;
  }
  base {
      udp_host="11.8.0.2";
      udp_port=9001;
  }
  manipulation {
    robot_to_base {
      channels_a=["CAMERALEFT_TX","CAMERA_LHANDLEFT_TX", "CAMERA_RHANDLEFT_TX", 
                  "MAP_OCTREE","MAP_CLOUD","MAP_DEPTH","MAP_CATALOG",
                  "PMD_INFO","SYSTEM_STATUS","DRIVING_CONTROLLER_COMMAND_VALUES",
                  "AFFORDANCE_PLUS_BASE_OVERWRITE","PMD_PRINTF_REPLY"];
      frequency_a=0.0;
      channels_b=["ROBOT_UTIME", "OBJECT_BEARING", "DRC_DRIVING_CONTROL_STATUS",
                  "TLD_OBJECT_ROI_RESULT","FREQUENCY_LCM","VRC_SCORE"];
      frequency_b=1.0;
      channels_c=["EST_ROBOT_STATE","CONTROLLER_STATUS"];
      frequency_c=3.0;
    }

    base_to_robot {
      channels_a=["MAP_REQUEST","SENSOR_REQUEST",
                  "COMMITTED_FOOTSTEP_PLAN","PMD_ORDERS","DATA_REQUEST",
                  "DRIVING_CONTROLLER_COMMAND","TLD_OBJECT_ROI",
                  "COMMITTED_ROBOT_PLAN","COMMITTED_GRASP",
                  "AFFORDANCE_PLUS_BOT_OVERWRITE","GAZE_COMMAND",
                  "TRACKER_COMMAND","DESIRED_NECK_PITCH","SIMPLE_GRASP_COMMAND",
                  "COMMITTED_MANIP_GAIN","COMMITTED_POSTURE_PRESET",
                  "AFFORDANCE_MINI_BOT_OVERWRITE","PMD_PRINTF_REQUEST",
                  "COMMITTED_MANIP_MAP","MOTIONEST_REQUEST"];
      frequency_a=0.0;
      channels_b=[];
      frequency_b=[1.0];
      channels_c=[];
      frequency_c=[1.0];
    }  
  }
}

frequency_tool {
    LCM { # must be caps | channels_short must be 4 chars
        #NBNBNB: dont change this list - its hard coded for easy transmission from robot to base
        channels       = ["EST_ROBOT_STATE","ATLAS_COMMAND","CAMERA","CAMERA_LHAND","CAMERA_RHAND","SCAN"];
        channels_short = ["ERS "           ,"ACOM"         ,"HEAD"  ,"LEFT"        ,"RGHT"        ,"SCAN"]; 
    }
}

driving {
    control {
        lookahead_distance_default = 11.0;
        kp_steer_default = 6.0;
    }
}

viewer {
  renderer_groups {
    manipulation {
      name="Manipulation";
      enabled=["BOT_FRAMES","Grid", "Maps", "Robot State Display","Robot Plan Display", "Data Control",
          "Affordances & StickyHands/Feet", "Collections" ];
    }

    walking {
      name="Walking";
      enabled=[ "BOT_FRAMES","Grid", "Maps", "Robot State Display","Robot Plan Display", "Data Control", "Walking",
          "Footstep Plans & Stick Feet" ];
    }
  }
}
