   1               		.file	"adc.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  13               	.global	captureSweep
  15               	captureSweep:
  16               	.LFB4:
  17               		.file 1 "adc.c"
   1:adc.c         **** /****************************************************
   2:adc.c         **** 
   3:adc.c         ****  // Author:            Zachary Clifford
   4:adc.c         ****  // File Name:        C1482-SRC-PXDMCU-0_adc.c
   5:adc.c         ****  // Creation Date:    24 February, 2012
   6:adc.c         ****  // Revision:        00
   7:adc.c         ****  // Hardware:        ATxmega32A4U
   8:adc.c         ****  // Description:    ADC driver
   9:adc.c         **** 
  10:adc.c         **** ****************************************************/
  11:adc.c         **** 
  12:adc.c         **** /******************************************************************************
  13:adc.c         ****     File Revision History:
  14:adc.c         **** -------------------------------------------------------------------------------
  15:adc.c         **** Revision    Date        Engineer    Description
  16:adc.c         **** --------    --------    --------    -------------------------------------------
  17:adc.c         **** 00            MM/DD/YY    ZAC            Initial Release
  18:adc.c         **** -------------------------------------------------------------------------------
  19:adc.c         **** 
  20:adc.c         **** ******************************************************************************/
  21:adc.c         **** 
  22:adc.c         **** #include <avr/io.h>
  23:adc.c         **** #include <avr/interrupt.h>
  24:adc.c         **** #include <stddef.h>
  25:adc.c         **** #include <avr/pgmspace.h>
  26:adc.c         **** #include <math.h>
  27:adc.c         **** 
  28:adc.c         **** //static void calibrateADC(void);
  29:adc.c         **** static uint8_t ReadCalibrationByte(uint8_t index);
  30:adc.c         **** 
  31:adc.c         **** //static int16_t ADCCurrentCalibration;
  32:adc.c         **** 
  33:adc.c         **** 
  34:adc.c         **** 
  35:adc.c         **** /************************************************************************
  36:adc.c         **** * ReadCalibrationByte
  37:adc.c         **** *
  38:adc.c         **** * Library code from Atmel for reading the ADC calibration byte from the
  39:adc.c         **** * production signature row.  This is required for the ADC to achieve
  40:adc.c         **** * its full specification.
  41:adc.c         **** ************************************************************************/
  42:adc.c         **** static uint8_t ReadCalibrationByte(uint8_t index)
  43:adc.c         **** {
  44:adc.c         ****     uint8_t result;
  45:adc.c         **** 
  46:adc.c         ****     // Load the NVM Command register to read the calibration row.
  47:adc.c         ****     NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
  48:adc.c         ****     result = pgm_read_byte(index);
  49:adc.c         **** 
  50:adc.c         ****     //Clean up NVM Command register.
  51:adc.c         ****     NVM_CMD = NVM_CMD_NO_OPERATION_gc;
  52:adc.c         **** 
  53:adc.c         ****     return result;
  54:adc.c         **** }
  55:adc.c         **** 
  56:adc.c         **** // /************************************************************************
  57:adc.c         **** // * calibrateCurrentADC
  58:adc.c         **** // *
  59:adc.c         **** // * Assumes that the motor is inactive.
  60:adc.c         **** // * Captures a few samples of the ADC, averages them, and stores an
  61:adc.c         **** // * appropriate offset estimation for calibration
  62:adc.c         **** // ************************************************************************/
  63:adc.c         **** // /*
  64:adc.c         **** // static void calibrateADC(void)
  65:adc.c         **** // {
  66:adc.c         **** //     int i=0;
  67:adc.c         **** //     int32_t calibrationAccumulator=0;
  68:adc.c         **** //     while(i<16)
  69:adc.c         **** //     {
  70:adc.c         **** //         if(ADCA.INTFLAGS & ADC_CH1IF_bm)
  71:adc.c         **** //         {
  72:adc.c         **** //             ADCA.INTFLAGS = ADC_CH1IF_bm;
  73:adc.c         **** //             calibrationAccumulator += ADCA.CH1RES;
  74:adc.c         **** //             i++;
  75:adc.c         **** //         }
  76:adc.c         **** //     }
  77:adc.c         **** //     ADCCurrentCalibration = round((float) calibrationAccumulator / 16.0);
  78:adc.c         **** //     return;
  79:adc.c         **** // }
  80:adc.c         **** // */
  81:adc.c         **** 
  82:adc.c         **** void captureSweep(int16_t *outputData)
  83:adc.c         **** {
  18               		.loc 1 83 0
  19               		.cfi_startproc
  20               	.LVL0:
  21               	/* prologue: function */
  22               	/* frame size = 0 */
  23               	/* stack size = 0 */
  24               	.L__stack_usage = 0
  25 0000 FC01      		movw r30,r24
  84:adc.c         ****     //Begin sampling on the Distal
  85:adc.c         ****     ADCA_CH0_MUXCTRL = ADC_CH_MUXPOS_PIN1_gc;
  26               		.loc 1 85 0
  27 0002 88E0      		ldi r24,lo8(8)
  28               	.LVL1:
  29 0004 8093 2102 		sts 545,r24
  86:adc.c         ****     ADCA_CH1_MUXCTRL = ADC_CH_MUXPOS_PIN2_gc;
  30               		.loc 1 86 0
  31 0008 80E1      		ldi r24,lo8(16)
  32 000a 8093 2902 		sts 553,r24
  87:adc.c         ****     ADCA_CH2_MUXCTRL = ADC_CH_MUXPOS_PIN3_gc;
  33               		.loc 1 87 0
  34 000e 88E1      		ldi r24,lo8(24)
  35 0010 8093 3102 		sts 561,r24
  88:adc.c         ****     ADCA_CH3_MUXCTRL = ADC_CH_MUXPOS_PIN4_gc;
  36               		.loc 1 88 0
  37 0014 80E2      		ldi r24,lo8(32)
  38 0016 8093 3902 		sts 569,r24
  89:adc.c         **** 
  90:adc.c         ****     asm("nop"); // delay for mux switch
  39               		.loc 1 90 0
  40               	/* #APP */
  41               	 ;  90 "adc.c" 1
  42 001a 0000      		nop
  43               	 ;  0 "" 2
  91:adc.c         ****     asm("nop");
  44               		.loc 1 91 0
  45               	 ;  91 "adc.c" 1
  46 001c 0000      		nop
  47               	 ;  0 "" 2
  92:adc.c         **** 
  93:adc.c         ****     ADCA.CTRLA = ADC_CH3START_bm | ADC_CH2START_bm | ADC_CH1START_bm | ADC_CH0START_bm | ADC_ENABLE
  48               		.loc 1 93 0
  49               	/* #NOAPP */
  50 001e 8DE3      		ldi r24,lo8(61)
  51 0020 8093 0002 		sts 512,r24
  52               	.L2:
  94:adc.c         **** 
  95:adc.c         ****     //Now wait for the conclusion of the sampling
  96:adc.c         ****     while(!(ADCA.INTFLAGS & ADC_CH3IF_bm));
  53               		.loc 1 96 0 discriminator 1
  54 0024 8091 0602 		lds r24,518
  55 0028 83FF      		sbrs r24,3
  56 002a 00C0      		rjmp .L2
  57               	.L8:
  97:adc.c         ****     while(!(ADCA.INTFLAGS & ADC_CH2IF_bm));
  58               		.loc 1 97 0 discriminator 1
  59 002c 8091 0602 		lds r24,518
  60 0030 82FF      		sbrs r24,2
  61 0032 00C0      		rjmp .L8
  62               	.L7:
  98:adc.c         ****     while(!(ADCA.INTFLAGS & ADC_CH1IF_bm));
  63               		.loc 1 98 0 discriminator 1
  64 0034 8091 0602 		lds r24,518
  65 0038 81FF      		sbrs r24,1
  66 003a 00C0      		rjmp .L7
  67               	.L6:
  99:adc.c         ****     while(!(ADCA.INTFLAGS & ADC_CH0IF_bm));
  68               		.loc 1 99 0 discriminator 1
  69 003c 8091 0602 		lds r24,518
  70 0040 80FF      		sbrs r24,0
  71 0042 00C0      		rjmp .L6
 100:adc.c         **** 
 101:adc.c         ****     //Sampling complete
 102:adc.c         ****     outputData[0] = ADCA.CH0RES;
  72               		.loc 1 102 0
  73 0044 8091 1002 		lds r24,528
  74 0048 9091 1102 		lds r25,528+1
  75 004c 8083      		st Z,r24
  76 004e 9183      		std Z+1,r25
 103:adc.c         ****     outputData[1] = ADCA.CH1RES;
  77               		.loc 1 103 0
  78 0050 8091 1202 		lds r24,530
  79 0054 9091 1302 		lds r25,530+1
  80 0058 8283      		std Z+2,r24
  81 005a 9383      		std Z+3,r25
 104:adc.c         ****     outputData[2] = ADCA.CH2RES;
  82               		.loc 1 104 0
  83 005c 8091 1402 		lds r24,532
  84 0060 9091 1502 		lds r25,532+1
  85 0064 8483      		std Z+4,r24
  86 0066 9583      		std Z+5,r25
 105:adc.c         ****     outputData[3] = ADCA.CH3RES;
  87               		.loc 1 105 0
  88 0068 8091 1602 		lds r24,534
  89 006c 9091 1702 		lds r25,534+1
  90 0070 8683      		std Z+6,r24
  91 0072 9783      		std Z+7,r25
 106:adc.c         **** 
 107:adc.c         ****     ADCA.INTFLAGS = ADC_CH3IF_bm | ADC_CH2IF_bm | ADC_CH1IF_bm | ADC_CH0IF_bm;
  92               		.loc 1 107 0
  93 0074 8FE0      		ldi r24,lo8(15)
  94 0076 E0E0      		ldi r30,lo8(512)
  95 0078 F2E0      		ldi r31,hi8(512)
  96               	.LVL2:
  97 007a 8683      		std Z+6,r24
  98               	/* epilogue start */
 108:adc.c         **** 
 109:adc.c         ****     // //Begin sampling on the Dynamic
 110:adc.c         ****     // ADCA_CH0_MUXCTRL = ADC_CH_MUXPOS_PIN5_gc;
 111:adc.c         ****     // ADCA_CH1_MUXCTRL = ADC_CH_MUXPOS_PIN6_gc;
 112:adc.c         ****     // ADCA_CH2_MUXCTRL = ADC_CH_MUXPOS_PIN7_gc;
 113:adc.c         **** 
 114:adc.c         ****     // asm("nop"); // delay for mux switch
 115:adc.c         ****     // asm("nop");
 116:adc.c         **** 
 117:adc.c         ****     // ADCA.CTRLA = ADC_CH2START_bm | ADC_CH1START_bm | ADC_CH0START_bm | ADC_ENABLE_bm;
 118:adc.c         **** 
 119:adc.c         ****     // //Now wait for the conclusion of the sampling
 120:adc.c         ****     // while(!(ADCA.INTFLAGS & ADC_CH2IF_bm));
 121:adc.c         ****     // while(!(ADCA.INTFLAGS & ADC_CH1IF_bm));
 122:adc.c         ****     // while(!(ADCA.INTFLAGS & ADC_CH0IF_bm));
 123:adc.c         **** 
 124:adc.c         ****     // //Sampling complete
 125:adc.c         ****     // outputData[4] = ADCA.CH0RES;
 126:adc.c         ****     // outputData[5] = ADCA.CH1RES;
 127:adc.c         ****     // outputData[6] = ADCA.CH2RES;
 128:adc.c         **** 
 129:adc.c         ****     // ADCA.INTFLAGS = ADC_CH2IF_bm | ADC_CH1IF_bm | ADC_CH0IF_bm;
 130:adc.c         **** 
 131:adc.c         ****     return;
 132:adc.c         **** }
  99               		.loc 1 132 0
 100 007c 0895      		ret
 101               		.cfi_endproc
 102               	.LFE4:
 104               	.global	configureADC
 106               	configureADC:
 107               	.LFB5:
 133:adc.c         **** 
 134:adc.c         **** /************************************************************************
 135:adc.c         **** * configureADC
 136:adc.c         **** *
 137:adc.c         **** * Configure the ADC to capture the four analog inputs we care about
 138:adc.c         **** * in free-running sweep mode with no interrupts.
 139:adc.c         **** * When the PID loop is evaluated, the most recent acquisition is placed into
 140:adc.c         **** * a buffer for later use.
 141:adc.c         **** *
 142:adc.c         **** * Note that an internal reference is being used in this test setup.
 143:adc.c         **** * The production system will have an external one available.
 144:adc.c         **** ************************************************************************/
 145:adc.c         **** void configureADC(void)
 146:adc.c         **** {
 108               		.loc 1 146 0
 109               		.cfi_startproc
 110 007e CF93      		push r28
 111               	.LCFI0:
 112               		.cfi_def_cfa_offset 3
 113               		.cfi_offset 28, -2
 114 0080 DF93      		push r29
 115               	.LCFI1:
 116               		.cfi_def_cfa_offset 4
 117               		.cfi_offset 29, -3
 118               	/* prologue: function */
 119               	/* frame size = 0 */
 120               	/* stack size = 2 */
 121               	.L__stack_usage = 2
 122               	.LVL3:
 123               	.LBB8:
 124               	.LBB9:
  47:adc.c         ****     NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
 125               		.loc 1 47 0
 126 0082 AAEC      		ldi r26,lo8(458)
 127 0084 B1E0      		ldi r27,hi8(458)
 128 0086 82E0      		ldi r24,lo8(2)
 129 0088 8C93      		st X,r24
 130               	.LVL4:
 131               	.LBB10:
  48:adc.c         ****     result = pgm_read_byte(index);
 132               		.loc 1 48 0
 133 008a E0E2      		ldi r30,lo8(32)
 134 008c F0E0      		ldi r31,hi8(32)
 135               	/* #APP */
 136               	 ;  48 "adc.c" 1
 137 008e E491      		lpm r30, Z
 138               		
 139               	 ;  0 "" 2
 140               	.LVL5:
 141               	/* #NOAPP */
 142               	.LBE10:
  51:adc.c         ****     NVM_CMD = NVM_CMD_NO_OPERATION_gc;
 143               		.loc 1 51 0
 144 0090 1C92      		st X,__zero_reg__
 145               	.LBE9:
 146               	.LBE8:
 147:adc.c         ****     ADCA.CALL = ReadCalibrationByte( offsetof(NVM_PROD_SIGNATURES_t, ADCACAL0) );
 147               		.loc 1 147 0
 148 0092 C0E0      		ldi r28,lo8(512)
 149 0094 D2E0      		ldi r29,hi8(512)
 150 0096 EC87      		std Y+12,r30
 151               	.LVL6:
 152               	.LBB11:
 153               	.LBB12:
  47:adc.c         ****     NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
 154               		.loc 1 47 0
 155 0098 8C93      		st X,r24
 156               	.LVL7:
 157               	.LBB13:
  48:adc.c         ****     result = pgm_read_byte(index);
 158               		.loc 1 48 0
 159 009a E1E2      		ldi r30,lo8(33)
 160 009c F0E0      		ldi r31,hi8(33)
 161               	.LVL8:
 162               	/* #APP */
 163               	 ;  48 "adc.c" 1
 164 009e E491      		lpm r30, Z
 165               		
 166               	 ;  0 "" 2
 167               	.LVL9:
 168               	/* #NOAPP */
 169               	.LBE13:
  51:adc.c         ****     NVM_CMD = NVM_CMD_NO_OPERATION_gc;
 170               		.loc 1 51 0
 171 00a0 1C92      		st X,__zero_reg__
 172               	.LBE12:
 173               	.LBE11:
 148:adc.c         ****     ADCA.CALH = ReadCalibrationByte( offsetof(NVM_PROD_SIGNATURES_t, ADCACAL1) );
 174               		.loc 1 148 0
 175 00a2 ED87      		std Y+13,r30
 149:adc.c         **** 
 150:adc.c         ****     //CURRENT_ADC.EVCTRL = ADC_SWEEP_0123_gc | ADC_EVACT_NONE_gc;
 151:adc.c         **** 
 152:adc.c         ****     //Use the Event System to actuate sweeps
 153:adc.c         **** 
 154:adc.c         ****     //EVSYS.CH3MUX = EVSYS_CHMUX_PRESCALER_8192_gc;
 155:adc.c         ****     //EVSYS.CH3CTRL = EVSYS_DIGFILT_1SAMPLE_gc;
 156:adc.c         **** 
 157:adc.c         ****     //ADCA.EVCTRL = ADC_SWEEP_0123_gc | ADC_EVSEL_3456_gc | ADC_EVACT_SWEEP_gc;
 158:adc.c         **** 
 159:adc.c         ****     //Maximum ADC clock is 2 MHz.  This requires a prescaler of 16 on a CPU clock of 32 MHz
 160:adc.c         ****     ADCA.PRESCALER = ADC_PRESCALER_DIV16_gc;
 176               		.loc 1 160 0
 177 00a4 8C83      		std Y+4,r24
 161:adc.c         ****     //CURRENT_ADC.PRESCALER = ADC_PRESCALER_DIV256_gc;
 162:adc.c         **** 
 163:adc.c         **** #ifdef USE_INTERNAL_REF
 164:adc.c         ****     ADCA.REFCTRL = ADC_REFSEL_VCC_gc;
 165:adc.c         **** #else
 166:adc.c         ****     ADCA.REFCTRL = ADC_REFSEL_AREFA_gc;
 178               		.loc 1 166 0
 179 00a6 20E2      		ldi r18,lo8(32)
 180 00a8 2A83      		std Y+2,r18
 167:adc.c         **** #endif
 168:adc.c         **** 
 169:adc.c         **** #warning The ADC.CH structure is wrong in AU parts.  Just use the ADC_CH0_MUXCTRL, etc. defines ins
 170:adc.c         **** 
 171:adc.c         ****     //CH0 is Distal 1 and Dynamic 1
 172:adc.c         ****     ADCA_CH0_CTRL = ADC_CH_GAIN_1X_gc | ADC_CH_INPUTMODE_SINGLEENDED_gc;
 181               		.loc 1 172 0
 182 00aa 81E0      		ldi r24,lo8(1)
 183 00ac 8093 2002 		sts 544,r24
 173:adc.c         ****     ADCA_CH0_MUXCTRL = ADC_CH_MUXPOS_PIN1_gc;
 184               		.loc 1 173 0
 185 00b0 98E0      		ldi r25,lo8(8)
 186 00b2 9093 2102 		sts 545,r25
 174:adc.c         ****     ADCA_CH0_INTCTRL = ADC_CH_INTMODE_COMPLETE_gc | ADC_CH_INTLVL_OFF_gc;
 187               		.loc 1 174 0
 188 00b6 1092 2202 		sts 546,__zero_reg__
 175:adc.c         **** 
 176:adc.c         ****     //CH1 is Distal 2 and Dynamic 2
 177:adc.c         ****     ADCA_CH1_CTRL = ADC_CH_GAIN_1X_gc | ADC_CH_INPUTMODE_SINGLEENDED_gc;
 189               		.loc 1 177 0
 190 00ba 8093 2802 		sts 552,r24
 178:adc.c         ****     ADCA_CH1_MUXCTRL = ADC_CH_MUXPOS_PIN2_gc;
 191               		.loc 1 178 0
 192 00be 90E1      		ldi r25,lo8(16)
 193 00c0 9093 2902 		sts 553,r25
 179:adc.c         ****     ADCA_CH1_INTCTRL = ADC_CH_INTMODE_COMPLETE_gc | ADC_CH_INTLVL_OFF_gc;
 194               		.loc 1 179 0
 195 00c4 1092 2A02 		sts 554,__zero_reg__
 180:adc.c         **** 
 181:adc.c         ****     //CH2 is Distal 3 and Dynamic 3
 182:adc.c         ****     ADCA_CH2_CTRL = ADC_CH_GAIN_1X_gc | ADC_CH_INPUTMODE_SINGLEENDED_gc;
 196               		.loc 1 182 0
 197 00c8 8093 3002 		sts 560,r24
 183:adc.c         ****     ADCA_CH2_MUXCTRL = ADC_CH_MUXPOS_PIN3_gc;
 198               		.loc 1 183 0
 199 00cc 38E1      		ldi r19,lo8(24)
 200 00ce 3093 3102 		sts 561,r19
 184:adc.c         ****     ADCA_CH2_INTCTRL = ADC_CH_INTMODE_COMPLETE_gc | ADC_CH_INTLVL_OFF_gc;
 201               		.loc 1 184 0
 202 00d2 1092 3202 		sts 562,__zero_reg__
 185:adc.c         **** 
 186:adc.c         ****     //CH3 is Distal 4 only
 187:adc.c         ****     ADCA_CH3_CTRL = ADC_CH_GAIN_1X_gc | ADC_CH_INPUTMODE_SINGLEENDED_gc;
 203               		.loc 1 187 0
 204 00d6 8093 3802 		sts 568,r24
 188:adc.c         ****     ADCA_CH3_MUXCTRL = ADC_CH_MUXPOS_PIN4_gc;
 205               		.loc 1 188 0
 206 00da 2093 3902 		sts 569,r18
 189:adc.c         ****     ADCA_CH3_INTCTRL = ADC_CH_INTMODE_COMPLETE_gc | ADC_CH_INTLVL_OFF_gc;
 207               		.loc 1 189 0
 208 00de 1092 3A02 		sts 570,__zero_reg__
 190:adc.c         **** 
 191:adc.c         ****     //Configure for signed operation
 192:adc.c         ****     ADCA.CTRLB = ADC_RESOLUTION_12BIT_gc | ADC_CONMODE_bm;
 209               		.loc 1 192 0
 210 00e2 9983      		std Y+1,r25
 193:adc.c         ****     ADCA.CTRLA = ADC_ENABLE_bm;
 211               		.loc 1 193 0
 212 00e4 8883      		st Y,r24
 213               	/* epilogue start */
 194:adc.c         **** 
 195:adc.c         ****     //Calibrate the ADC
 196:adc.c         ****     //calibrateADC();
 197:adc.c         **** 
 198:adc.c         ****     //Just use manual triggering for now
 199:adc.c         ****     //ADC_TC.CTRLB = TC_WGMODE_NORMAL_gc;
 200:adc.c         ****     //ADC_TC.CTRLC = 0x00;
 201:adc.c         ****     //ADC_TC.CTRLD = TC_EVACT_OFF_gc | TC_EVSEL_OFF_gc;
 202:adc.c         ****     //ADC_TC.CTRLE = 0x00;
 203:adc.c         ****     //ADC_TC.PERBUF = 3125;
 204:adc.c         ****     //ADC_TC.INTCTRLA = TC_OVFINTLVL_LO_gc;
 205:adc.c         ****     //ADC_TC.CTRLA = TC_CLKSEL_DIV1024_gc;
 206:adc.c         **** 
 207:adc.c         **** }
 214               		.loc 1 207 0
 215 00e6 DF91      		pop r29
 216 00e8 CF91      		pop r28
 217               	.LVL10:
 218 00ea 0895      		ret
 219               		.cfi_endproc
 220               	.LFE5:
 222               	.Letext0:
 223               		.file 2 "/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../av
 224               		.file 3 "/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../av
DEFINED SYMBOLS
                            *ABS*:00000000 adc.c
     /tmp/ccVO9BM5.s:2      *ABS*:0000003f __SREG__
     /tmp/ccVO9BM5.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccVO9BM5.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccVO9BM5.s:5      *ABS*:00000034 __CCP__
     /tmp/ccVO9BM5.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccVO9BM5.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccVO9BM5.s:15     .text:00000000 captureSweep
     /tmp/ccVO9BM5.s:106    .text:0000007e configureADC

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
