   1               		.file	"accel.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  14               	writeRegisterSPI:
  15               	.LFB7:
  16               		.file 1 "accel.c"
   1:accel.c       **** /****************************************************
   2:accel.c       **** 
   3:accel.c       ****  // Author:            Zachary Clifford
   4:accel.c       ****  // File Name:        C1482-SRC-PXDMCU-0_tactsense.c
   5:accel.c       ****  // Creation Date:    5 March, 2012
   6:accel.c       ****  // Revision:        00
   7:accel.c       ****  // Hardware:        ATxmega32A4U
   8:accel.c       ****  // Description:    Accelerometer sensor driver
   9:accel.c       **** 
  10:accel.c       **** ****************************************************/
  11:accel.c       **** 
  12:accel.c       **** /******************************************************************************
  13:accel.c       ****     File Revision History:
  14:accel.c       **** -------------------------------------------------------------------------------
  15:accel.c       **** Revision    Date        Engineer    Description
  16:accel.c       **** --------    --------    --------    -------------------------------------------
  17:accel.c       **** 00            MM/DD/YY    ZAC            Initial Release
  18:accel.c       **** -------------------------------------------------------------------------------
  19:accel.c       **** 
  20:accel.c       **** ******************************************************************************/
  21:accel.c       **** 
  22:accel.c       **** #include <avr/io.h>
  23:accel.c       **** #include "accel.h"
  24:accel.c       **** #include "proximal.h"
  25:accel.c       **** 
  26:accel.c       **** //The system can take 5 MHz.  Peripheral clock is set to 32 MHz internally, so a divide by 8 presca
  27:accel.c       **** //In this chip, the division is accomplished by a divide by 16 with a doubler
  28:accel.c       **** 
  29:accel.c       **** #define ACCELSPI SPID
  30:accel.c       **** #define ACCELSPI_PORT PORTD
  31:accel.c       **** #define ACCEL_CS_PORT PORTA     // chip select
  32:accel.c       **** #define ACCEL_CS_PIN_MASK 0x80  // chip select pin
  33:accel.c       **** 
  34:accel.c       **** static void writeRegisterSPI(uint8_t addr, uint8_t data);
  35:accel.c       **** 
  36:accel.c       **** void configureSPIModulesAccel(void)
  37:accel.c       **** {
  38:accel.c       ****   ACCEL_CS_PORT.OUTSET = ACCEL_CS_PIN_MASK; // default chip select to high
  39:accel.c       ****   ACCEL_CS_PORT.DIRSET = ACCEL_CS_PIN_MASK; // make sure it is an output
  40:accel.c       ****   ACCELSPI_PORT.DIRCLR = 0x40;
  41:accel.c       ****   ACCELSPI_PORT.DIRSET = 0xB0;
  42:accel.c       ****   //ACCELSPI_PORT.OUTSET = 0x10;
  43:accel.c       ****   ACCELSPI.INTCTRL = SPI_INTLVL_OFF_gc;
  44:accel.c       ****   ACCELSPI.CTRL = SPI_ENABLE_bm | SPI_MASTER_bm | SPI_MODE_3_gc | SPI_PRESCALER_DIV16_gc | SPI_CLK2
  45:accel.c       **** }
  46:accel.c       **** 
  47:accel.c       **** /*
  48:accel.c       ****  * Abstraction Function for ReadWriting Registers On The Accelerometer
  49:accel.c       ****  */
  50:accel.c       **** static void writeRegisterSPI(uint8_t addr, uint8_t data)
  51:accel.c       **** {
  17               		.loc 1 51 0
  18               		.cfi_startproc
  19               	.LVL0:
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 0 */
  23               	.L__stack_usage = 0
  52:accel.c       ****   uint8_t dummy;
  53:accel.c       ****   ACCEL_CS_PORT.OUTCLR = ACCEL_CS_PIN_MASK; // chip select
  24               		.loc 1 53 0
  25 0000 90E8      		ldi r25,lo8(-128)
  26 0002 E0E0      		ldi r30,lo8(1536)
  27 0004 F6E0      		ldi r31,hi8(1536)
  28 0006 9683      		std Z+6,r25
  54:accel.c       **** 
  55:accel.c       ****   //ADDR should be 5 bits in length.  Bit 6 should be low for single write
  56:accel.c       ****   //bit 7 should be low to indicate WRITE
  57:accel.c       ****   ACCELSPI.DATA = addr;
  29               		.loc 1 57 0
  30 0008 E0EC      		ldi r30,lo8(2496)
  31 000a F9E0      		ldi r31,hi8(2496)
  32 000c 8383      		std Z+3,r24
  58:accel.c       ****   while(!(ACCELSPI.STATUS & SPI_IF_bm)) {
  33               		.loc 1 58 0
  34 000e 00C0      		rjmp .L2
  35               	.LVL1:
  36               	.L3:
  59:accel.c       ****     dummy = ACCELSPI.DATA; } //wait for it to finish
  37               		.loc 1 59 0
  38 0010 8091 C309 		lds r24,2499
  39               	.L2:
  58:accel.c       ****   while(!(ACCELSPI.STATUS & SPI_IF_bm)) {
  40               		.loc 1 58 0 discriminator 1
  41 0014 8091 C209 		lds r24,2498
  42 0018 87FF      		sbrs r24,7
  43 001a 00C0      		rjmp .L3
  60:accel.c       **** 
  61:accel.c       ****   // the dummy read is needed for the SPI_IF flag to clear
  62:accel.c       **** 
  63:accel.c       ****   ACCELSPI.DATA = data;
  44               		.loc 1 63 0
  45 001c E0EC      		ldi r30,lo8(2496)
  46 001e F9E0      		ldi r31,hi8(2496)
  47 0020 6383      		std Z+3,r22
  64:accel.c       ****   while(!(ACCELSPI.STATUS & SPI_IF_bm)) {
  48               		.loc 1 64 0
  49 0022 00C0      		rjmp .L4
  50               	.L5:
  65:accel.c       ****     dummy = ACCELSPI.DATA; } //wait for it to finish
  51               		.loc 1 65 0
  52 0024 8091 C309 		lds r24,2499
  53               	.L4:
  64:accel.c       ****   while(!(ACCELSPI.STATUS & SPI_IF_bm)) {
  54               		.loc 1 64 0 discriminator 1
  55 0028 8091 C209 		lds r24,2498
  56 002c 87FF      		sbrs r24,7
  57 002e 00C0      		rjmp .L5
  66:accel.c       **** 
  67:accel.c       ****   ACCEL_CS_PORT.OUTSET = ACCEL_CS_PIN_MASK; // chip select
  58               		.loc 1 67 0
  59 0030 80E8      		ldi r24,lo8(-128)
  60 0032 E0E0      		ldi r30,lo8(1536)
  61 0034 F6E0      		ldi r31,hi8(1536)
  62               	.LVL2:
  63 0036 8583      		std Z+5,r24
  64               	/* epilogue start */
  68:accel.c       ****   return;
  69:accel.c       **** }
  65               		.loc 1 69 0
  66 0038 0895      		ret
  67               		.cfi_endproc
  68               	.LFE7:
  70               	.global	configureSPIModulesAccel
  72               	configureSPIModulesAccel:
  73               	.LFB6:
  37:accel.c       **** {
  74               		.loc 1 37 0
  75               		.cfi_startproc
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 0 */
  79               	.L__stack_usage = 0
  38:accel.c       ****   ACCEL_CS_PORT.OUTSET = ACCEL_CS_PIN_MASK; // default chip select to high
  80               		.loc 1 38 0
  81 003a E0E0      		ldi r30,lo8(1536)
  82 003c F6E0      		ldi r31,hi8(1536)
  83 003e 80E8      		ldi r24,lo8(-128)
  84 0040 8583      		std Z+5,r24
  39:accel.c       ****   ACCEL_CS_PORT.DIRSET = ACCEL_CS_PIN_MASK; // make sure it is an output
  85               		.loc 1 39 0
  86 0042 8183      		std Z+1,r24
  40:accel.c       ****   ACCELSPI_PORT.DIRCLR = 0x40;
  87               		.loc 1 40 0
  88 0044 E0E6      		ldi r30,lo8(1632)
  89 0046 F6E0      		ldi r31,hi8(1632)
  90 0048 80E4      		ldi r24,lo8(64)
  91 004a 8283      		std Z+2,r24
  41:accel.c       ****   ACCELSPI_PORT.DIRSET = 0xB0;
  92               		.loc 1 41 0
  93 004c 80EB      		ldi r24,lo8(-80)
  94 004e 8183      		std Z+1,r24
  43:accel.c       ****   ACCELSPI.INTCTRL = SPI_INTLVL_OFF_gc;
  95               		.loc 1 43 0
  96 0050 E0EC      		ldi r30,lo8(2496)
  97 0052 F9E0      		ldi r31,hi8(2496)
  98 0054 1182      		std Z+1,__zero_reg__
  44:accel.c       ****   ACCELSPI.CTRL = SPI_ENABLE_bm | SPI_MASTER_bm | SPI_MODE_3_gc | SPI_PRESCALER_DIV16_gc | SPI_CLK2
  99               		.loc 1 44 0
 100 0056 8DED      		ldi r24,lo8(-35)
 101 0058 8083      		st Z,r24
 102               	/* epilogue start */
  45:accel.c       **** }
 103               		.loc 1 45 0
 104 005a 0895      		ret
 105               		.cfi_endproc
 106               	.LFE6:
 108               	.global	configAccel
 110               	configAccel:
 111               	.LFB8:
  70:accel.c       **** 
  71:accel.c       **** /*
  72:accel.c       ****  * Configure ADXL345 Accelerometer for 16G Measurement Mode
  73:accel.c       **** 
  74:accel.c       ****  called once in main
  75:accel.c       ****  */
  76:accel.c       **** void configAccel(void)
  77:accel.c       **** {
 112               		.loc 1 77 0
 113               		.cfi_startproc
 114               	/* prologue: function */
 115               	/* frame size = 0 */
 116               	/* stack size = 0 */
 117               	.L__stack_usage = 0
  78:accel.c       ****     writeRegisterSPI(0x2D, 0x08); //switch from standby to measuring
 118               		.loc 1 78 0
 119 005c 8DE2      		ldi r24,lo8(45)
 120 005e 68E0      		ldi r22,lo8(8)
 121 0060 0E94 0000 		call writeRegisterSPI
  79:accel.c       ****     writeRegisterSPI(0x31, 0x0F); //set to fullscale, full resolution
 122               		.loc 1 79 0
 123 0064 81E3      		ldi r24,lo8(49)
 124 0066 6FE0      		ldi r22,lo8(15)
 125 0068 0E94 0000 		call writeRegisterSPI
 126               	/* epilogue start */
  80:accel.c       **** }
 127               		.loc 1 80 0
 128 006c 0895      		ret
 129               		.cfi_endproc
 130               	.LFE8:
 132               	.global	readAxes
 134               	readAxes:
 135               	.LFB9:
  81:accel.c       **** 
  82:accel.c       **** /*
  83:accel.c       ****  * Clockout Six Databytes From ADXL345, Two Bytes Per Axis
  84:accel.c       ****  */
  85:accel.c       **** void readAxes(uint8_t *dataOut)
  86:accel.c       **** {
 136               		.loc 1 86 0
 137               		.cfi_startproc
 138               	.LVL3:
 139               	/* prologue: function */
 140               	/* frame size = 0 */
 141               	/* stack size = 0 */
 142               	.L__stack_usage = 0
  87:accel.c       ****     //configureSPIModulesAccel();
  88:accel.c       ****     ACCEL_CS_PORT.OUTCLR = ACCEL_CS_PIN_MASK;
 143               		.loc 1 88 0
 144 006e 20E8      		ldi r18,lo8(-128)
 145 0070 E0E0      		ldi r30,lo8(1536)
 146 0072 F6E0      		ldi r31,hi8(1536)
 147 0074 2683      		std Z+6,r18
  89:accel.c       **** 
  90:accel.c       ****     ACCELSPI.DATA = (0x32 | 0xC0); //start at the x axis register, addr 0x32, set multibyte read wi
 148               		.loc 1 90 0
 149 0076 22EF      		ldi r18,lo8(-14)
 150 0078 E0EC      		ldi r30,lo8(2496)
 151 007a F9E0      		ldi r31,hi8(2496)
 152 007c 2383      		std Z+3,r18
 153               	.L9:
  91:accel.c       ****     while(!(ACCELSPI.STATUS & SPI_IF_bm)); //wait for it to finish
 154               		.loc 1 91 0 discriminator 1
 155 007e 2091 C209 		lds r18,2498
 156 0082 27FF      		sbrs r18,7
 157 0084 00C0      		rjmp .L9
 158               		.loc 1 91 0 is_stmt 0
 159 0086 FC01      		movw r30,r24
 160 0088 86E0      		ldi r24,lo8(6)
 161               	.LVL4:
 162               	.LBB2:
  92:accel.c       **** 
  93:accel.c       ****     for (uint8_t i = 0; i < 6; i++)
  94:accel.c       ****     {
  95:accel.c       ****         ACCELSPI.DATA = 0x00; //clockout
 163               		.loc 1 95 0 is_stmt 1
 164 008a A0EC      		ldi r26,lo8(2496)
 165 008c B9E0      		ldi r27,hi8(2496)
 166               	.LVL5:
 167               	.L11:
 168 008e 1396      		adiw r26,3
 169 0090 1C92      		st X,__zero_reg__
 170 0092 1397      		sbiw r26,3
 171               	.L10:
  96:accel.c       ****         while(!(ACCELSPI.STATUS & SPI_IF_bm)); //wait for clockout to finish
 172               		.loc 1 96 0 discriminator 1
 173 0094 9091 C209 		lds r25,2498
 174 0098 97FF      		sbrs r25,7
 175 009a 00C0      		rjmp .L10
  97:accel.c       ****         dataOut[i] = ACCELSPI.DATA; //store
 176               		.loc 1 97 0
 177 009c 9091 C309 		lds r25,2499
 178 00a0 9193      		st Z+,r25
 179 00a2 8150      		subi r24,lo8(-(-1))
  93:accel.c       ****     for (uint8_t i = 0; i < 6; i++)
 180               		.loc 1 93 0
 181 00a4 01F4      		brne .L11
 182               	.LBE2:
  98:accel.c       ****     }
  99:accel.c       **** 
 100:accel.c       ****     ACCEL_CS_PORT.OUTSET = ACCEL_CS_PIN_MASK;
 183               		.loc 1 100 0
 184 00a6 80E8      		ldi r24,lo8(-128)
 185 00a8 E0E0      		ldi r30,lo8(1536)
 186 00aa F6E0      		ldi r31,hi8(1536)
 187 00ac 8583      		std Z+5,r24
 188               	/* epilogue start */
 101:accel.c       ****     return;
 102:accel.c       **** }
 189               		.loc 1 102 0
 190 00ae 0895      		ret
 191               		.cfi_endproc
 192               	.LFE9:
 194               	.Letext0:
 195               		.file 2 "/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../av
 196               		.file 3 "/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../av
DEFINED SYMBOLS
                            *ABS*:00000000 accel.c
     /tmp/ccLNf5bM.s:2      *ABS*:0000003f __SREG__
     /tmp/ccLNf5bM.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccLNf5bM.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccLNf5bM.s:5      *ABS*:00000034 __CCP__
     /tmp/ccLNf5bM.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccLNf5bM.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccLNf5bM.s:14     .text:00000000 writeRegisterSPI
     /tmp/ccLNf5bM.s:72     .text:0000003a configureSPIModulesAccel
     /tmp/ccLNf5bM.s:110    .text:0000005c configAccel
     /tmp/ccLNf5bM.s:134    .text:0000006e readAxes

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
