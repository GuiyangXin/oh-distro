   1               		.file	"proximal.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  14               	ReadIntFromEEPROM:
  15               	.LFB10:
  16               		.file 1 "proximal.c"
   1:proximal.c    **** /****************************************************
   2:proximal.c    **** 
   3:proximal.c    ****  // Author:            Zachary Clifford
   4:proximal.c    ****  // File Name:        C1482-SRC-PXDMCU-0.c
   5:proximal.c    ****  // Creation Date:    24 February, 2012
   6:proximal.c    ****  // Revision:        00
   7:proximal.c    ****  // Hardware:        ATxmega32A4U
   8:proximal.c    ****  // Description:    Proximal/Distal Top Level Implementation
   9:proximal.c    **** 
  10:proximal.c    **** ****************************************************/
  11:proximal.c    **** 
  12:proximal.c    **** /******************************************************************************
  13:proximal.c    ****     Project Build Summary:
  14:proximal.c    **** -------------------------------------------------------------------------------
  15:proximal.c    **** Source File                                Cur. Rev. Level        Prev. Rev. Level
  16:proximal.c    **** --------------------------------        ----------------    ----------------
  17:proximal.c    **** C1482-SRC-PXDMCU-0.c                    00                    00
  18:proximal.c    **** 
  19:proximal.c    **** 
  20:proximal.c    **** -------------------------------------------------------------------------------
  21:proximal.c    **** 
  22:proximal.c    ****     Project Revision History:
  23:proximal.c    **** -------------------------------------------------------------------------------
  24:proximal.c    **** Revision    Date        Engineer    Description
  25:proximal.c    **** --------    --------    --------    -------------------------------------------
  26:proximal.c    **** 00            MM/DD/YY    ZAC            Initial Release
  27:proximal.c    **** -------------------------------------------------------------------------------
  28:proximal.c    **** 
  29:proximal.c    ****     File Revision History:
  30:proximal.c    **** -------------------------------------------------------------------------------
  31:proximal.c    **** Revision    Date        Engineer    Description
  32:proximal.c    **** --------    --------    --------    -------------------------------------------
  33:proximal.c    **** 00            MM/DD/YY    ZAC            Initial Release
  34:proximal.c    **** -------------------------------------------------------------------------------
  35:proximal.c    **** 
  36:proximal.c    **** ******************************************************************************/
  37:proximal.c    **** #define F_CPU 32000000
  38:proximal.c    **** #include <util/delay.h>
  39:proximal.c    **** #include "daisyconfig.h"
  40:proximal.c    **** #define COMMAND_PACKET_SIZE 7
  41:proximal.c    **** 
  42:proximal.c    **** 
  43:proximal.c    **** #include "proximal.h"
  44:proximal.c    **** #include "portio.h"
  45:proximal.c    **** #include "../common/daisycomm.h"
  46:proximal.c    **** #include "tactsense.h"
  47:proximal.c    **** #include "adc.h"
  48:proximal.c    **** #include "encoder.h"
  49:proximal.c    **** #include "accel.h"
  50:proximal.c    **** 
  51:proximal.c    **** #include <avr/io.h>
  52:proximal.c    **** #include <avr/interrupt.h>
  53:proximal.c    **** #include <math.h>
  54:proximal.c    **** #include <string.h>
  55:proximal.c    **** #include <avr/wdt.h>
  56:proximal.c    **** #include <avr/eeprom.h>
  57:proximal.c    **** 
  58:proximal.c    **** #define FIRMWARE_VERSION 301
  59:proximal.c    **** 
  60:proximal.c    **** uint8_t numPressureSensors = 12;
  61:proximal.c    **** 
  62:proximal.c    **** uint16_t testADC[8];
  63:proximal.c    **** 
  64:proximal.c    **** static void configureClocks(void);
  65:proximal.c    **** static void WriteIntToEEPROM(uint8_t address, uint8_t* value);
  66:proximal.c    **** static void ReadIntFromEEPROM(uint8_t address, uint8_t* destination);
  67:proximal.c    **** static void verifyVersion(void);
  68:proximal.c    **** static void initStateFromEEPROM(void);
  69:proximal.c    **** 
  70:proximal.c    **** /************************************************************************
  71:proximal.c    **** * Private function definitions
  72:proximal.c    **** ************************************************************************/
  73:proximal.c    **** 
  74:proximal.c    **** /************************************************************************
  75:proximal.c    **** * configureClocks()
  76:proximal.c    **** *
  77:proximal.c    **** * Configure system clocks
  78:proximal.c    **** * The RTC is being used to generate PID ticks, so ensure that the 32 kHz oscillator
  79:proximal.c    **** * is running.  This will feed a 1.024 kHz clock to the RTC.
  80:proximal.c    **** * The system clock will use the onboard 32MHz oscillator
  81:proximal.c    **** ************************************************************************/
  82:proximal.c    **** static void configureClocks(void)
  83:proximal.c    **** {
  84:proximal.c    ****     OSC.CTRL = OSC_RC32MEN_bm | OSC_RC32KEN_bm;            //enable the 32MHz ring oscillator and t
  85:proximal.c    ****     while(!(OSC.STATUS & OSC_RC32MRDY_bm));                //wait for 32MHz to stabilize
  86:proximal.c    ****     while(!(OSC.STATUS & OSC_RC32KRDY_bm));                //wait for 32kHz to stabilize
  87:proximal.c    **** 
  88:proximal.c    ****     DFLLRC32M.CTRL = DFLL_ENABLE_bm;
  89:proximal.c    ****     DFLLRC2M.CTRL = DFLL_ENABLE_bm;
  90:proximal.c    **** 
  91:proximal.c    ****     CCP = CCP_IOREG_gc;                                    //clock is protected by Configuration Ch
  92:proximal.c    ****     CLK.CTRL = CLK_SCLKSEL_RC32M_gc;                    //switch to 32MHz oscillator
  93:proximal.c    ****     CLK.RTCCTRL = CLK_RTCSRC_RCOSC_gc | CLK_RTCEN_bm;    //Select 1.024 kHz from internal oscillato
  94:proximal.c    **** }
  95:proximal.c    **** 
  96:proximal.c    **** static int handleCollectionCommand(uint8_t *commandPacket, uint8_t *outputBuffer)
  97:proximal.c    **** {
  98:proximal.c    ****     uint8_t responseSize = 0;
  99:proximal.c    ****     uint16_t collectionBitfield;
 100:proximal.c    ****     int16_t adcData[7];
 101:proximal.c    ****     uint8_t accelData[6];
 102:proximal.c    ****     int16_t encoderData;
 103:proximal.c    **** 
 104:proximal.c    ****     memcpy(&collectionBitfield, &commandPacket[PAYLOAD_OFFSET], 2);
 105:proximal.c    **** 
 106:proximal.c    ****     if (collectionBitfield & (DATA_COLLECTION_DISTALJOINT_BITMASK | DATA_COLLECTION_DYNAMIC_BITMASK
 107:proximal.c    ****     {
 108:proximal.c    ****         captureSweep(adcData);
 109:proximal.c    ****     }
 110:proximal.c    **** 
 111:proximal.c    ****     if(collectionBitfield & DATA_COLLECTION_ACCELERATION_BITMASK)
 112:proximal.c    ****     {
 113:proximal.c    ****         readAxes(accelData);
 114:proximal.c    ****         memcpy(&outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize], &accelData, 6);
 115:proximal.c    ****         responseSize += 6;
 116:proximal.c    ****     }
 117:proximal.c    **** 
 118:proximal.c    ****     if(collectionBitfield & DATA_COLLECTION_DYNAMIC_BITMASK)
 119:proximal.c    ****     {
 120:proximal.c    ****         memcpy(&outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize], &adcData[DYNAMIC_OFFSET], 6);
 121:proximal.c    ****         responseSize += 6;
 122:proximal.c    ****     }
 123:proximal.c    **** 
 124:proximal.c    ****     if(collectionBitfield & DATA_COLLECTION_DISTALJOINT_BITMASK)
 125:proximal.c    ****     {
 126:proximal.c    ****         memcpy(&outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize], &adcData[DISTALJOINT_OFFSET], 8
 127:proximal.c    ****         responseSize += 8;
 128:proximal.c    ****     }
 129:proximal.c    **** 
 130:proximal.c    ****     if(collectionBitfield & DATA_COLLECTION_PROXIMALJOINT_BITMASK)
 131:proximal.c    ****     {
 132:proximal.c    ****         encoderData = readEncoder();
 133:proximal.c    ****         memcpy(&outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize], &encoderData, 2);
 134:proximal.c    ****         responseSize += 2;
 135:proximal.c    ****     }
 136:proximal.c    **** 
 137:proximal.c    ****     if(collectionBitfield & DATA_COLLECTION_TACTILE_BITMASK)
 138:proximal.c    ****     {
 139:proximal.c    ****         memcpy(&outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize], &pressureData, numPressureSenso
 140:proximal.c    ****         responseSize += numPressureSensors*2;
 141:proximal.c    ****     }
 142:proximal.c    **** 
 143:proximal.c    ****     if(collectionBitfield & DATA_COLLECTION_DEBUG_BITMASK)
 144:proximal.c    ****     {
 145:proximal.c    ****         memcpy(&outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize], &RxCheckSumErrCnt, 4);
 146:proximal.c    ****         responseSize += 4;
 147:proximal.c    ****     }
 148:proximal.c    ****     
 149:proximal.c    ****     if(collectionBitfield & DATA_COLLECTION_TACTILE_TEMP_BITMASK)
 150:proximal.c    ****     {
 151:proximal.c    ****         memcpy(&outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize], &pressureTempData, numPressureS
 152:proximal.c    ****         responseSize += numPressureSensors*2;
 153:proximal.c    ****     }
 154:proximal.c    ****     
 155:proximal.c    ****     outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3+responseSize;
 156:proximal.c    ****     outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = DATA_COLLECTION_OPCODE;
 157:proximal.c    ****     outputBuffer[RESPONSE_STATUSCODE_OFFSET] = STATUS_OK;
 158:proximal.c    ****     outputBuffer[3+responseSize] = computeChecksum(outputBuffer,3+responseSize); //this is the chec
 159:proximal.c    ****     return 4+responseSize;
 160:proximal.c    **** }
 161:proximal.c    **** 
 162:proximal.c    **** static void initStateFromEEPROM(void)
 163:proximal.c    **** {
 164:proximal.c    ****     uint32_t temp = 0;
 165:proximal.c    ****     
 166:proximal.c    ****     ReadIntFromEEPROM(EEPROM_ADDRESS_LED, (uint8_t*)&temp);
 167:proximal.c    ****     if(temp)
 168:proximal.c    ****         LEDon();
 169:proximal.c    ****     else
 170:proximal.c    ****         LEDoff();
 171:proximal.c    ****     
 172:proximal.c    ****     ReadIntFromEEPROM(EEPROM_ADDRESS_ENCODER_OFFSET, (uint8_t*)&temp);
 173:proximal.c    ****     encoderOffset = temp;
 174:proximal.c    **** }
 175:proximal.c    **** 
 176:proximal.c    **** static void WriteIntToEEPROM(uint8_t address, uint8_t* value)
 177:proximal.c    **** {
 178:proximal.c    ****     for(uint8_t i=0; i<4; i++)
 179:proximal.c    ****         eeprom_write_byte((uint8_t *) (address*4+i), *(value+i));
 180:proximal.c    **** }
 181:proximal.c    **** 
 182:proximal.c    **** static void ReadIntFromEEPROM(uint8_t address, uint8_t* destination)
 183:proximal.c    **** {
  17               		.loc 1 183 0
  18               		.cfi_startproc
  19               	.LVL0:
  20 0000 EF92      		push r14
  21               	.LCFI0:
  22               		.cfi_def_cfa_offset 3
  23               		.cfi_offset 14, -2
  24 0002 FF92      		push r15
  25               	.LCFI1:
  26               		.cfi_def_cfa_offset 4
  27               		.cfi_offset 15, -3
  28 0004 0F93      		push r16
  29               	.LCFI2:
  30               		.cfi_def_cfa_offset 5
  31               		.cfi_offset 16, -4
  32 0006 1F93      		push r17
  33               	.LCFI3:
  34               		.cfi_def_cfa_offset 6
  35               		.cfi_offset 17, -5
  36 0008 CF93      		push r28
  37               	.LCFI4:
  38               		.cfi_def_cfa_offset 7
  39               		.cfi_offset 28, -6
  40 000a DF93      		push r29
  41               	.LCFI5:
  42               		.cfi_def_cfa_offset 8
  43               		.cfi_offset 29, -7
  44 000c 0F92      		push __tmp_reg__
  45               	.LCFI6:
  46               		.cfi_def_cfa_offset 9
  47 000e CDB7      		in r28,__SP_L__
  48 0010 DEB7      		in r29,__SP_H__
  49               	.LCFI7:
  50               		.cfi_def_cfa_register 28
  51               	/* prologue: function */
  52               	/* frame size = 1 */
  53               	/* stack size = 7 */
  54               	.L__stack_usage = 7
  55               	.LVL1:
  56               	.LBB16:
 184:proximal.c    ****     for(uint8_t i=0; i<4; i++)
 185:proximal.c    ****         *(destination+i) = eeprom_read_byte((uint8_t *) (address*4+i));
  57               		.loc 1 185 0
  58 0012 E82E      		mov r14,r24
  59 0014 FF24      		clr r15
  60 0016 EE0C      		lsl r14
  61 0018 FF1C      		rol r15
  62 001a EE0C      		lsl r14
  63 001c FF1C      		rol r15
  64               	.LVL2:
  65 001e 8B01      		movw r16,r22
 184:proximal.c    ****     for(uint8_t i=0; i<4; i++)
  66               		.loc 1 184 0
  67 0020 20E0      		ldi r18,lo8(0)
  68               	.LVL3:
  69               	.L2:
  70               		.loc 1 185 0 discriminator 2
  71 0022 C701      		movw r24,r14
  72 0024 2983      		std Y+1,r18
  73 0026 0E94 0000 		call __eerd_byte_x32a4u
  74 002a F801      		movw r30,r16
  75 002c 8193      		st Z+,r24
  76 002e 8F01      		movw r16,r30
 184:proximal.c    ****     for(uint8_t i=0; i<4; i++)
  77               		.loc 1 184 0 discriminator 2
  78 0030 2981      		ldd r18,Y+1
  79 0032 2F5F      		subi r18,lo8(-(1))
  80               	.LVL4:
  81 0034 0894      		sec
  82 0036 E11C      		adc r14,__zero_reg__
  83 0038 F11C      		adc r15,__zero_reg__
  84 003a 2430      		cpi r18,lo8(4)
  85 003c 01F4      		brne .L2
  86               	/* epilogue start */
  87               	.LBE16:
 186:proximal.c    **** }
  88               		.loc 1 186 0
  89 003e 0F90      		pop __tmp_reg__
  90 0040 DF91      		pop r29
  91 0042 CF91      		pop r28
  92 0044 1F91      		pop r17
  93 0046 0F91      		pop r16
  94 0048 FF90      		pop r15
  95 004a EF90      		pop r14
  96 004c 0895      		ret
  97               		.cfi_endproc
  98               	.LFE10:
 101               	WriteIntToEEPROM:
 102               	.LFB9:
 177:proximal.c    **** {
 103               		.loc 1 177 0
 104               		.cfi_startproc
 105               	.LVL5:
 106 004e EF92      		push r14
 107               	.LCFI8:
 108               		.cfi_def_cfa_offset 3
 109               		.cfi_offset 14, -2
 110 0050 FF92      		push r15
 111               	.LCFI9:
 112               		.cfi_def_cfa_offset 4
 113               		.cfi_offset 15, -3
 114 0052 0F93      		push r16
 115               	.LCFI10:
 116               		.cfi_def_cfa_offset 5
 117               		.cfi_offset 16, -4
 118 0054 1F93      		push r17
 119               	.LCFI11:
 120               		.cfi_def_cfa_offset 6
 121               		.cfi_offset 17, -5
 122 0056 CF93      		push r28
 123               	.LCFI12:
 124               		.cfi_def_cfa_offset 7
 125               		.cfi_offset 28, -6
 126 0058 DF93      		push r29
 127               	.LCFI13:
 128               		.cfi_def_cfa_offset 8
 129               		.cfi_offset 29, -7
 130 005a 0F92      		push __tmp_reg__
 131               	.LCFI14:
 132               		.cfi_def_cfa_offset 9
 133 005c CDB7      		in r28,__SP_L__
 134 005e DEB7      		in r29,__SP_H__
 135               	.LCFI15:
 136               		.cfi_def_cfa_register 28
 137               	/* prologue: function */
 138               	/* frame size = 1 */
 139               	/* stack size = 7 */
 140               	.L__stack_usage = 7
 141               	.LVL6:
 142               	.LBB17:
 179:proximal.c    ****         eeprom_write_byte((uint8_t *) (address*4+i), *(value+i));
 143               		.loc 1 179 0
 144 0060 8B01      		movw r16,r22
 145 0062 E82E      		mov r14,r24
 146 0064 FF24      		clr r15
 147 0066 EE0C      		lsl r14
 148 0068 FF1C      		rol r15
 149 006a EE0C      		lsl r14
 150 006c FF1C      		rol r15
 178:proximal.c    ****     for(uint8_t i=0; i<4; i++)
 151               		.loc 1 178 0
 152 006e 20E0      		ldi r18,lo8(0)
 153               	.LVL7:
 154               	.L5:
 179:proximal.c    ****         eeprom_write_byte((uint8_t *) (address*4+i), *(value+i));
 155               		.loc 1 179 0 discriminator 2
 156 0070 F801      		movw r30,r16
 157 0072 6191      		ld r22,Z+
 158 0074 8F01      		movw r16,r30
 159 0076 C701      		movw r24,r14
 160 0078 2983      		std Y+1,r18
 161 007a 0E94 0000 		call __eewr_byte_x32a4u
 178:proximal.c    ****     for(uint8_t i=0; i<4; i++)
 162               		.loc 1 178 0 discriminator 2
 163 007e 2981      		ldd r18,Y+1
 164 0080 2F5F      		subi r18,lo8(-(1))
 165               	.LVL8:
 166 0082 0894      		sec
 167 0084 E11C      		adc r14,__zero_reg__
 168 0086 F11C      		adc r15,__zero_reg__
 169 0088 2430      		cpi r18,lo8(4)
 170 008a 01F4      		brne .L5
 171               	/* epilogue start */
 172               	.LBE17:
 180:proximal.c    **** }
 173               		.loc 1 180 0
 174 008c 0F90      		pop __tmp_reg__
 175 008e DF91      		pop r29
 176 0090 CF91      		pop r28
 177 0092 1F91      		pop r17
 178 0094 0F91      		pop r16
 179 0096 FF90      		pop r15
 180 0098 EF90      		pop r14
 181 009a 0895      		ret
 182               		.cfi_endproc
 183               	.LFE9:
 185               	.global	LEDon
 187               	LEDon:
 188               	.LFB17:
 187:proximal.c    **** 
 188:proximal.c    **** static void verifyVersion(void)
 189:proximal.c    **** {
 190:proximal.c    ****     uint32_t readversion = 0;
 191:proximal.c    ****     ReadIntFromEEPROM(EEPROM_ADDRESS_FIRMWARE_VERSION, (uint8_t*)&readversion);
 192:proximal.c    ****     if (readversion != FIRMWARE_VERSION)
 193:proximal.c    ****     {
 194:proximal.c    ****         readversion = FIRMWARE_VERSION;
 195:proximal.c    ****         WriteIntToEEPROM(EEPROM_ADDRESS_FIRMWARE_VERSION, (uint8_t*)&readversion);
 196:proximal.c    ****     }
 197:proximal.c    **** }
 198:proximal.c    **** 
 199:proximal.c    **** static int handleEEPROMCommand(uint8_t *commandPacket, uint8_t *outputBuffer)
 200:proximal.c    **** {
 201:proximal.c    ****     uint8_t opcode;
 202:proximal.c    ****     uint8_t address;
 203:proximal.c    ****     uint8_t responseSize = 4;
 204:proximal.c    **** 
 205:proximal.c    ****     opcode = commandPacket[COMMAND_OFFSET] & OPCODE_BITMASK;
 206:proximal.c    ****     address = commandPacket[COMMAND_OFFSET] & 0x1F;
 207:proximal.c    **** 
 208:proximal.c    ****     switch(opcode)
 209:proximal.c    ****     {
 210:proximal.c    ****         case MOTOR_PARAMETER_RE_L_OPCODE:
 211:proximal.c    ****         case MOTOR_PARAMETER_RE_H_OPCODE:
 212:proximal.c    ****             // Read 4 bytes of data
 213:proximal.c    ****             ReadIntFromEEPROM(address, &outputBuffer[RESPONSE_PAYLOAD_OFFSET]);
 214:proximal.c    ****             // finish up the packet
 215:proximal.c    ****             outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3+responseSize;
 216:proximal.c    ****             outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = commandPacket[COMMAND_OFFSET];
 217:proximal.c    ****             outputBuffer[RESPONSE_STATUSCODE_OFFSET] = STATUS_OK;
 218:proximal.c    ****             outputBuffer[3+responseSize] = computeChecksum(outputBuffer,3+responseSize); //this is 
 219:proximal.c    ****             return 4+responseSize;
 220:proximal.c    ****         case MOTOR_PARAMETER_WR_L_OPCODE:
 221:proximal.c    ****         case MOTOR_PARAMETER_WR_H_OPCODE:
 222:proximal.c    **** 
 223:proximal.c    ****             // Write 32 bits of data
 224:proximal.c    ****             WriteIntToEEPROM(address, &commandPacket[PAYLOAD_OFFSET]);
 225:proximal.c    ****             
 226:proximal.c    ****             // re-init our state
 227:proximal.c    ****             initStateFromEEPROM();
 228:proximal.c    ****             
 229:proximal.c    ****             // ack the command
 230:proximal.c    ****             outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3;
 231:proximal.c    ****             outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = commandPacket[COMMAND_OFFSET];
 232:proximal.c    ****             outputBuffer[RESPONSE_STATUSCODE_OFFSET] = STATUS_OK;
 233:proximal.c    ****             outputBuffer[3] = computeChecksum(outputBuffer,3); //this is the checksum
 234:proximal.c    ****             return 4;
 235:proximal.c    ****         default:
 236:proximal.c    ****             outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3;
 237:proximal.c    ****             outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = commandPacket[COMMAND_OFFSET];
 238:proximal.c    ****             outputBuffer[RESPONSE_STATUSCODE_OFFSET] = UNKNOWN_COMMAND;
 239:proximal.c    ****             outputBuffer[3] = computeChecksum(outputBuffer,3); //this is the checksum
 240:proximal.c    ****             return 4;
 241:proximal.c    ****     }
 242:proximal.c    **** }
 243:proximal.c    **** 
 244:proximal.c    **** static int handleCalibrationCommand(uint8_t *commandPacket, uint8_t *outputBuffer)
 245:proximal.c    **** {
 246:proximal.c    ****     uint16_t collectionBitfield;
 247:proximal.c    ****     
 248:proximal.c    ****     memcpy(&collectionBitfield, &commandPacket[PAYLOAD_OFFSET], 2);
 249:proximal.c    ****     
 250:proximal.c    ****     if(collectionBitfield & DATA_COLLECTION_TACTILE_BITMASK)
 251:proximal.c    ****     {
 252:proximal.c    ****         // zero out pressure readings with an offset
 253:proximal.c    ****         for(uint8_t i=0; i<MAXIMUM_NUMBER_OF_TACTILE_SENSORS; i++)
 254:proximal.c    ****         {
 255:proximal.c    ****             pressureDataOffset[i] = pressureData[i] + pressureDataOffset[i];
 256:proximal.c    ****         }
 257:proximal.c    ****     }
 258:proximal.c    ****     
 259:proximal.c    ****     if (collectionBitfield & DATA_COLLECTION_DEBUG_BITMASK)
 260:proximal.c    ****     {
 261:proximal.c    ****         RxCheckSumErrCnt[0] = 0;
 262:proximal.c    ****         RxCheckSumErrCnt[1] = 0;
 263:proximal.c    ****     }
 264:proximal.c    ****     
 265:proximal.c    ****     if (collectionBitfield & DATA_COLLECTION_PROXIMALJOINT_BITMASK)
 266:proximal.c    ****     {
 267:proximal.c    ****         encoderOffset = readRawEncoder();
 268:proximal.c    ****         uint32_t temp = encoderOffset;
 269:proximal.c    ****         WriteIntToEEPROM(EEPROM_ADDRESS_ENCODER_OFFSET, (uint8_t*)&temp);
 270:proximal.c    ****     }
 271:proximal.c    ****     
 272:proximal.c    ****     outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3;
 273:proximal.c    ****     outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = CALIBRATION_OPCODE;
 274:proximal.c    ****     outputBuffer[RESPONSE_STATUSCODE_OFFSET] = STATUS_OK;
 275:proximal.c    ****     outputBuffer[3] = computeChecksum(outputBuffer,3); //this is the checksum
 276:proximal.c    ****     return 4;
 277:proximal.c    **** }
 278:proximal.c    **** 
 279:proximal.c    **** void BootRelay(uint8_t *commandPacket)
 280:proximal.c    **** {
 281:proximal.c    ****   // overview: 1)send a bootload command to the target
 282:proximal.c    ****   // overview: 2)configure for 115200 baud passthrough
 283:proximal.c    ****   // overview: 3)start a 20 second timer
 284:proximal.c    ****   // overview: 4)do the serial passthrough, blink LED
 285:proximal.c    ****   // overview: 5)wait for timer to finish, then reset/reboot
 286:proximal.c    **** 
 287:proximal.c    ****   cli(); // disable all interrupts, nothing else going on
 288:proximal.c    ****   DMA.CTRL = 0; // disable the DMA controller
 289:proximal.c    ****   
 290:proximal.c    ****   // repeat the command to the target
 291:proximal.c    ****   DOWNSTREAM_USART.CTRLA = 0x00; // disable interrupts
 292:proximal.c    ****   DOWNSTREAM_USART.CTRLB |= USART_RXEN_bm | USART_TXEN_bm; //enable RX and TX
 293:proximal.c    ****   for(int i=0;i<COMMAND_PACKET_SIZE;i++)
 294:proximal.c    ****     {
 295:proximal.c    ****       while(!(DOWNSTREAM_USART.STATUS & USART_DREIF_bm));
 296:proximal.c    ****       DOWNSTREAM_USART.DATA = commandPacket[i];
 297:proximal.c    ****     }
 298:proximal.c    ****   // dont bother waiting for a response verification
 299:proximal.c    ****   while(!(DOWNSTREAM_USART.STATUS & USART_DREIF_bm)); // wait for the data to be read
 300:proximal.c    ****   DOWNSTREAM_USART.STATUS = USART_TXCIF_bm; // clear the TX done flag
 301:proximal.c    ****   while(!(DOWNSTREAM_USART.STATUS & USART_TXCIF_bm)); // wait for the TX to be done
 302:proximal.c    ****   
 303:proximal.c    ****   // Reconfigure the serial ports
 304:proximal.c    ****   //int bsel = 1047;       // 115200 @ 32Mhz as calculated from ProtoTalk.net
 305:proximal.c    ****   //uint8_t bscale = 10;      // 115200 @ 32Mhz as calculated from ProtoTalk.net
 306:proximal.c    ****   int bsel = 3269;       // 38,400 @ 32Mhz as calculated from ProtoTalk.net
 307:proximal.c    ****   uint8_t bscale = -6;      // 38,400 @ 32Mhz as calculated from ProtoTalk.net
 308:proximal.c    ****   UPSTREAM_USART.CTRLA = 0x00; // disable interrupts
 309:proximal.c    ****   UPSTREAM_USART.BAUDCTRLA = (uint8_t) bsel;
 310:proximal.c    ****   UPSTREAM_USART.BAUDCTRLB = (bscale << 4) | (bsel >> 8);
 311:proximal.c    ****   UPSTREAM_USART.CTRLB = USART_RXEN_bm | USART_TXEN_bm;    //enable RX and TX
 312:proximal.c    ****   DOWNSTREAM_USART.CTRLA = 0x00; // disable interrupts
 313:proximal.c    ****   DOWNSTREAM_USART.BAUDCTRLA = (uint8_t) bsel;
 314:proximal.c    ****   DOWNSTREAM_USART.BAUDCTRLB = (bscale << 4) | (bsel >> 8);
 315:proximal.c    ****   DOWNSTREAM_USART.CTRLB = USART_RXEN_bm | USART_TXEN_bm;    //enable RX and TX
 316:proximal.c    ****   
 317:proximal.c    ****   int sec_cnt=0;
 318:proximal.c    ****   uint32_t loop_cnt=0;
 319:proximal.c    ****   uint8_t up_fifo[16];
 320:proximal.c    ****   uint8_t up_head = 0;
 321:proximal.c    ****   uint8_t up_tail = 0;
 322:proximal.c    ****   uint8_t down_fifo[16];
 323:proximal.c    ****   uint8_t down_head = 0;
 324:proximal.c    ****   uint8_t down_tail = 0;
 325:proximal.c    **** 
 326:proximal.c    ****   // relay chars while waiting for timeout
 327:proximal.c    ****   while(sec_cnt < 200) 
 328:proximal.c    ****   {
 329:proximal.c    ****       loop_cnt++;
 330:proximal.c    ****       if(loop_cnt > 90000L) 
 331:proximal.c    ****       { // approximately 0.1sec experimentally
 332:proximal.c    ****           loop_cnt=0;
 333:proximal.c    ****           sec_cnt++;
 334:proximal.c    ****           if((sec_cnt&0x03)==0x03)
 335:proximal.c    ****               LEDon();
 336:proximal.c    ****           else
 337:proximal.c    ****               LEDoff();
 338:proximal.c    ****       }
 339:proximal.c    ****       if (DOWNSTREAM_USART.STATUS & USART_RXCIF_bm) {
 340:proximal.c    ****           up_fifo[up_head++] = DOWNSTREAM_USART.DATA;
 341:proximal.c    ****           up_head %= sizeof(up_fifo);
 342:proximal.c    ****       }
 343:proximal.c    ****       if (UPSTREAM_USART.STATUS & USART_RXCIF_bm) {
 344:proximal.c    ****           down_fifo[down_head++] = UPSTREAM_USART.DATA;
 345:proximal.c    ****           down_head %= sizeof(down_fifo);
 346:proximal.c    ****       }
 347:proximal.c    ****       if (up_head != up_tail && (UPSTREAM_USART.STATUS & USART_DREIF_bm)) {
 348:proximal.c    ****           UPSTREAM_USART.DATA = up_fifo[up_tail++];
 349:proximal.c    ****           up_tail %= sizeof(up_fifo);
 350:proximal.c    ****       }
 351:proximal.c    ****       if (down_head != down_tail && (DOWNSTREAM_USART.STATUS & USART_DREIF_bm)) {
 352:proximal.c    ****           DOWNSTREAM_USART.DATA = down_fifo[down_tail++];
 353:proximal.c    ****           down_tail %= sizeof(down_fifo);
 354:proximal.c    ****       }
 355:proximal.c    ****   }
 356:proximal.c    **** 
 357:proximal.c    ****   // 30sec timer finished, reset/reboot
 358:proximal.c    ****   wdt_enable(WDT_PER_8CLK_gc);
 359:proximal.c    ****   while(1);  // use watchdog timer to trigger a reset
 360:proximal.c    **** }
 361:proximal.c    **** 
 362:proximal.c    **** static int handleBootloaderCommand(uint8_t *commandPacket)
 363:proximal.c    **** {
 364:proximal.c    **** 
 365:proximal.c    ****   if(0x0f & commandPacket[PAYLOAD_OFFSET]){
 366:proximal.c    ****     BootRelay(commandPacket);
 367:proximal.c    ****   }
 368:proximal.c    ****   else {
 369:proximal.c    ****     // self bootload
 370:proximal.c    ****     wdt_enable(WDT_PER_8CLK_gc);
 371:proximal.c    ****     while(1);  // use watchdog timer to trigger a reset
 372:proximal.c    ****   }
 373:proximal.c    ****   return 5; // never get here, but keep compiler happy
 374:proximal.c    **** }
 375:proximal.c    **** 
 376:proximal.c    **** int processCommand(uint8_t *commandPacket,uint8_t *outputBuffer)
 377:proximal.c    **** {
 378:proximal.c    ****   uint8_t opcode;
 379:proximal.c    **** 
 380:proximal.c    ****   opcode = commandPacket[COMMAND_OFFSET] & OPCODE_BITMASK;
 381:proximal.c    **** 
 382:proximal.c    ****   switch(opcode)
 383:proximal.c    ****   {
 384:proximal.c    ****       case DATA_COLLECTION_OPCODE:
 385:proximal.c    ****           return handleCollectionCommand(commandPacket,outputBuffer);
 386:proximal.c    **** 
 387:proximal.c    ****       case MOTOR_PARAMETER_RE_L_OPCODE:
 388:proximal.c    ****       case MOTOR_PARAMETER_RE_H_OPCODE:
 389:proximal.c    ****       case MOTOR_PARAMETER_WR_L_OPCODE:
 390:proximal.c    ****       case MOTOR_PARAMETER_WR_H_OPCODE:
 391:proximal.c    ****           return handleEEPROMCommand(commandPacket,outputBuffer);
 392:proximal.c    **** 
 393:proximal.c    ****       case CALIBRATION_OPCODE:
 394:proximal.c    ****           return handleCalibrationCommand(commandPacket, outputBuffer);
 395:proximal.c    **** 
 396:proximal.c    ****       case BOOTLOADER_OPCODE:
 397:proximal.c    ****           return handleBootloaderCommand(commandPacket);
 398:proximal.c    **** 
 399:proximal.c    ****       default:
 400:proximal.c    ****           outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3;
 401:proximal.c    ****           outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = opcode;
 402:proximal.c    ****           outputBuffer[RESPONSE_STATUSCODE_OFFSET] = UNKNOWN_COMMAND;
 403:proximal.c    ****           outputBuffer[3] = computeChecksum(outputBuffer,3); //this is the checksum
 404:proximal.c    ****           return 4;
 405:proximal.c    ****   }
 406:proximal.c    **** }
 407:proximal.c    **** 
 408:proximal.c    **** void LEDon(void)
 409:proximal.c    **** {
 189               		.loc 1 409 0
 190               		.cfi_startproc
 191               	/* prologue: function */
 192               	/* frame size = 0 */
 193               	/* stack size = 0 */
 194               	.L__stack_usage = 0
 410:proximal.c    ****     PORTC.OUT &= ~0x01;
 195               		.loc 1 410 0
 196 009c E0E4      		ldi r30,lo8(1600)
 197 009e F6E0      		ldi r31,hi8(1600)
 198 00a0 8481      		ldd r24,Z+4
 199 00a2 8E7F      		andi r24,lo8(-2)
 200 00a4 8483      		std Z+4,r24
 201               	/* epilogue start */
 411:proximal.c    **** }
 202               		.loc 1 411 0
 203 00a6 0895      		ret
 204               		.cfi_endproc
 205               	.LFE17:
 207               	.global	LEDoff
 209               	LEDoff:
 210               	.LFB18:
 412:proximal.c    **** 
 413:proximal.c    **** void LEDoff(void)
 414:proximal.c    **** {
 211               		.loc 1 414 0
 212               		.cfi_startproc
 213               	/* prologue: function */
 214               	/* frame size = 0 */
 215               	/* stack size = 0 */
 216               	.L__stack_usage = 0
 415:proximal.c    ****     PORTC.OUT |= 0x01;
 217               		.loc 1 415 0
 218 00a8 E0E4      		ldi r30,lo8(1600)
 219 00aa F6E0      		ldi r31,hi8(1600)
 220 00ac 8481      		ldd r24,Z+4
 221 00ae 8160      		ori r24,lo8(1)
 222 00b0 8483      		std Z+4,r24
 223               	/* epilogue start */
 416:proximal.c    **** }
 224               		.loc 1 416 0
 225 00b2 0895      		ret
 226               		.cfi_endproc
 227               	.LFE18:
 230               	initStateFromEEPROM:
 231               	.LFB8:
 163:proximal.c    **** {
 232               		.loc 1 163 0
 233               		.cfi_startproc
 234 00b4 CF93      		push r28
 235               	.LCFI16:
 236               		.cfi_def_cfa_offset 3
 237               		.cfi_offset 28, -2
 238 00b6 DF93      		push r29
 239               	.LCFI17:
 240               		.cfi_def_cfa_offset 4
 241               		.cfi_offset 29, -3
 242 00b8 00D0      		rcall .
 243 00ba 00D0      		rcall .
 244               	.LCFI18:
 245               		.cfi_def_cfa_offset 8
 246 00bc CDB7      		in r28,__SP_L__
 247 00be DEB7      		in r29,__SP_H__
 248               	.LCFI19:
 249               		.cfi_def_cfa_register 28
 250               	/* prologue: function */
 251               	/* frame size = 4 */
 252               	/* stack size = 6 */
 253               	.L__stack_usage = 6
 164:proximal.c    ****     uint32_t temp = 0;
 254               		.loc 1 164 0
 255 00c0 1982      		std Y+1,__zero_reg__
 256 00c2 1A82      		std Y+2,__zero_reg__
 257 00c4 1B82      		std Y+3,__zero_reg__
 258 00c6 1C82      		std Y+4,__zero_reg__
 259               	.LVL9:
 166:proximal.c    ****     ReadIntFromEEPROM(EEPROM_ADDRESS_LED, (uint8_t*)&temp);
 260               		.loc 1 166 0
 261 00c8 8FE1      		ldi r24,lo8(31)
 262 00ca BE01      		movw r22,r28
 263 00cc 6F5F      		subi r22,lo8(-(1))
 264 00ce 7F4F      		sbci r23,hi8(-(1))
 265 00d0 0E94 0000 		call ReadIntFromEEPROM
 167:proximal.c    ****     if(temp)
 266               		.loc 1 167 0
 267 00d4 8981      		ldd r24,Y+1
 268 00d6 9A81      		ldd r25,Y+2
 269 00d8 AB81      		ldd r26,Y+3
 270 00da BC81      		ldd r27,Y+4
 271 00dc 0097      		sbiw r24,0
 272 00de A105      		cpc r26,__zero_reg__
 273 00e0 B105      		cpc r27,__zero_reg__
 274 00e2 01F0      		breq .L10
 168:proximal.c    ****         LEDon();
 275               		.loc 1 168 0
 276 00e4 0E94 0000 		call LEDon
 277 00e8 00C0      		rjmp .L11
 278               	.L10:
 170:proximal.c    ****         LEDoff();
 279               		.loc 1 170 0
 280 00ea 0E94 0000 		call LEDoff
 281               	.L11:
 172:proximal.c    ****     ReadIntFromEEPROM(EEPROM_ADDRESS_ENCODER_OFFSET, (uint8_t*)&temp);
 282               		.loc 1 172 0
 283 00ee 8CE1      		ldi r24,lo8(28)
 284 00f0 BE01      		movw r22,r28
 285 00f2 6F5F      		subi r22,lo8(-(1))
 286 00f4 7F4F      		sbci r23,hi8(-(1))
 287 00f6 0E94 0000 		call ReadIntFromEEPROM
 173:proximal.c    ****     encoderOffset = temp;
 288               		.loc 1 173 0
 289 00fa 8981      		ldd r24,Y+1
 290 00fc 9A81      		ldd r25,Y+2
 291 00fe 8093 0000 		sts encoderOffset,r24
 292 0102 9093 0000 		sts encoderOffset+1,r25
 293               	/* epilogue start */
 174:proximal.c    **** }
 294               		.loc 1 174 0
 295 0106 2496      		adiw r28,4
 296 0108 CDBF      		out __SP_L__,r28
 297 010a DEBF      		out __SP_H__,r29
 298 010c DF91      		pop r29
 299 010e CF91      		pop r28
 300 0110 0895      		ret
 301               		.cfi_endproc
 302               	.LFE8:
 304               	.global	BootRelay
 306               	BootRelay:
 307               	.LFB14:
 280:proximal.c    **** {
 308               		.loc 1 280 0
 309               		.cfi_startproc
 310               	.LVL10:
 311 0112 CF93      		push r28
 312               	.LCFI20:
 313               		.cfi_def_cfa_offset 3
 314               		.cfi_offset 28, -2
 315 0114 DF93      		push r29
 316               	.LCFI21:
 317               		.cfi_def_cfa_offset 4
 318               		.cfi_offset 29, -3
 319 0116 CDB7      		in r28,__SP_L__
 320 0118 DEB7      		in r29,__SP_H__
 321 011a A097      		sbiw r28,32
 322               	.LCFI22:
 323               		.cfi_def_cfa 28, 36
 324 011c CDBF      		out __SP_L__,r28
 325 011e DEBF      		out __SP_H__,r29
 326               	/* prologue: function */
 327               	/* frame size = 32 */
 328               	/* stack size = 34 */
 329               	.L__stack_usage = 34
 287:proximal.c    ****   cli(); // disable all interrupts, nothing else going on
 330               		.loc 1 287 0
 331               	/* #APP */
 332               	 ;  287 "proximal.c" 1
 333 0120 F894      		cli
 334               	 ;  0 "" 2
 288:proximal.c    ****   DMA.CTRL = 0; // disable the DMA controller
 335               		.loc 1 288 0
 336               	/* #NOAPP */
 337 0122 1092 0001 		sts 256,__zero_reg__
 291:proximal.c    ****   DOWNSTREAM_USART.CTRLA = 0x00; // disable interrupts
 338               		.loc 1 291 0
 339 0126 E0EA      		ldi r30,lo8(2464)
 340 0128 F9E0      		ldi r31,hi8(2464)
 341 012a 1382      		std Z+3,__zero_reg__
 292:proximal.c    ****   DOWNSTREAM_USART.CTRLB |= USART_RXEN_bm | USART_TXEN_bm; //enable RX and TX
 342               		.loc 1 292 0
 343 012c 2091 A409 		lds r18,2468
 344 0130 2861      		ori r18,lo8(24)
 345 0132 2483      		std Z+4,r18
 346               	.LVL11:
 347 0134 FC01      		movw r30,r24
 293:proximal.c    ****   for(int i=0;i<COMMAND_PACKET_SIZE;i++)
 348               		.loc 1 293 0
 349 0136 80E0      		ldi r24,lo8(0)
 350 0138 90E0      		ldi r25,hi8(0)
 351               	.LVL12:
 352               	.L31:
 353               	.LBB18:
 295:proximal.c    ****       while(!(DOWNSTREAM_USART.STATUS & USART_DREIF_bm));
 354               		.loc 1 295 0 discriminator 1
 355 013a 2091 A109 		lds r18,2465
 356 013e 25FF      		sbrs r18,5
 357 0140 00C0      		rjmp .L31
 296:proximal.c    ****       DOWNSTREAM_USART.DATA = commandPacket[i];
 358               		.loc 1 296 0
 359 0142 2191      		ld r18,Z+
 360 0144 2093 A009 		sts 2464,r18
 293:proximal.c    ****   for(int i=0;i<COMMAND_PACKET_SIZE;i++)
 361               		.loc 1 293 0
 362 0148 0196      		adiw r24,1
 363               	.LVL13:
 364 014a 8730      		cpi r24,7
 365 014c 9105      		cpc r25,__zero_reg__
 366 014e 01F4      		brne .L31
 367               	.LVL14:
 368               	.L26:
 369               	.LBE18:
 299:proximal.c    ****   while(!(DOWNSTREAM_USART.STATUS & USART_DREIF_bm)); // wait for the data to be read
 370               		.loc 1 299 0 discriminator 1
 371 0150 8091 A109 		lds r24,2465
 372 0154 85FF      		sbrs r24,5
 373 0156 00C0      		rjmp .L26
 300:proximal.c    ****   DOWNSTREAM_USART.STATUS = USART_TXCIF_bm; // clear the TX done flag
 374               		.loc 1 300 0
 375 0158 80E4      		ldi r24,lo8(64)
 376 015a E0EA      		ldi r30,lo8(2464)
 377 015c F9E0      		ldi r31,hi8(2464)
 378 015e 8183      		std Z+1,r24
 379               	.L16:
 301:proximal.c    ****   while(!(DOWNSTREAM_USART.STATUS & USART_TXCIF_bm)); // wait for the TX to be done
 380               		.loc 1 301 0 discriminator 1
 381 0160 E0EA      		ldi r30,lo8(2464)
 382 0162 F9E0      		ldi r31,hi8(2464)
 383 0164 8091 A109 		lds r24,2465
 384 0168 86FF      		sbrs r24,6
 385 016a 00C0      		rjmp .L16
 386               	.LVL15:
 308:proximal.c    ****   UPSTREAM_USART.CTRLA = 0x00; // disable interrupts
 387               		.loc 1 308 0
 388 016c A0EA      		ldi r26,lo8(2720)
 389 016e BAE0      		ldi r27,hi8(2720)
 390 0170 1396      		adiw r26,3
 391 0172 1C92      		st X,__zero_reg__
 392 0174 1397      		sbiw r26,3
 309:proximal.c    ****   UPSTREAM_USART.BAUDCTRLA = (uint8_t) bsel;
 393               		.loc 1 309 0
 394 0176 25EC      		ldi r18,lo8(-59)
 395 0178 1696      		adiw r26,6
 396 017a 2C93      		st X,r18
 397 017c 1697      		sbiw r26,6
 310:proximal.c    ****   UPSTREAM_USART.BAUDCTRLB = (bscale << 4) | (bsel >> 8);
 398               		.loc 1 310 0
 399 017e 9CEA      		ldi r25,lo8(-84)
 400 0180 1796      		adiw r26,7
 401 0182 9C93      		st X,r25
 402 0184 1797      		sbiw r26,7
 311:proximal.c    ****   UPSTREAM_USART.CTRLB = USART_RXEN_bm | USART_TXEN_bm;    //enable RX and TX
 403               		.loc 1 311 0
 404 0186 88E1      		ldi r24,lo8(24)
 405 0188 1496      		adiw r26,4
 406 018a 8C93      		st X,r24
 312:proximal.c    ****   DOWNSTREAM_USART.CTRLA = 0x00; // disable interrupts
 407               		.loc 1 312 0
 408 018c 1382      		std Z+3,__zero_reg__
 313:proximal.c    ****   DOWNSTREAM_USART.BAUDCTRLA = (uint8_t) bsel;
 409               		.loc 1 313 0
 410 018e 2683      		std Z+6,r18
 314:proximal.c    ****   DOWNSTREAM_USART.BAUDCTRLB = (bscale << 4) | (bsel >> 8);
 411               		.loc 1 314 0
 412 0190 9783      		std Z+7,r25
 315:proximal.c    ****   DOWNSTREAM_USART.CTRLB = USART_RXEN_bm | USART_TXEN_bm;    //enable RX and TX
 413               		.loc 1 315 0
 414 0192 8483      		std Z+4,r24
 415               	.LVL16:
 324:proximal.c    ****   uint8_t down_tail = 0;
 416               		.loc 1 324 0
 417 0194 10E0      		ldi r17,lo8(0)
 323:proximal.c    ****   uint8_t down_head = 0;
 418               		.loc 1 323 0
 419 0196 00E0      		ldi r16,lo8(0)
 321:proximal.c    ****   uint8_t up_tail = 0;
 420               		.loc 1 321 0
 421 0198 FF24      		clr r15
 320:proximal.c    ****   uint8_t up_head = 0;
 422               		.loc 1 320 0
 423 019a EE24      		clr r14
 318:proximal.c    ****   uint32_t loop_cnt=0;
 424               		.loc 1 318 0
 425 019c 80E0      		ldi r24,lo8(0)
 426 019e 90E0      		ldi r25,hi8(0)
 427 01a0 DC01      		movw r26,r24
 317:proximal.c    ****   int sec_cnt=0;
 428               		.loc 1 317 0
 429 01a2 CC24      		clr r12
 430 01a4 DD24      		clr r13
 431               	.LVL17:
 432               	.L23:
 329:proximal.c    ****       loop_cnt++;
 433               		.loc 1 329 0
 434 01a6 0196      		adiw r24,1
 435 01a8 A11D      		adc r26,__zero_reg__
 436 01aa B11D      		adc r27,__zero_reg__
 437               	.LVL18:
 330:proximal.c    ****       if(loop_cnt > 90000L) 
 438               		.loc 1 330 0
 439 01ac 8139      		cpi r24,lo8(90001)
 440 01ae 2FE5      		ldi r18,hi8(90001)
 441 01b0 9207      		cpc r25,r18
 442 01b2 21E0      		ldi r18,hlo8(90001)
 443 01b4 A207      		cpc r26,r18
 444 01b6 20E0      		ldi r18,hhi8(90001)
 445 01b8 B207      		cpc r27,r18
 446 01ba 00F0      		brlo .L17
 447               	.LVL19:
 333:proximal.c    ****           sec_cnt++;
 448               		.loc 1 333 0
 449 01bc 0894      		sec
 450 01be C11C      		adc r12,__zero_reg__
 451 01c0 D11C      		adc r13,__zero_reg__
 452               	.LVL20:
 334:proximal.c    ****           if((sec_cnt&0x03)==0x03)
 453               		.loc 1 334 0
 454 01c2 C601      		movw r24,r12
 455 01c4 8370      		andi r24,lo8(3)
 456 01c6 9070      		andi r25,hi8(3)
 457 01c8 8330      		cpi r24,3
 458 01ca 9105      		cpc r25,__zero_reg__
 459 01cc 01F4      		brne .L18
 335:proximal.c    ****               LEDon();
 460               		.loc 1 335 0
 461 01ce 0E94 0000 		call LEDon
 462 01d2 00C0      		rjmp .L32
 463               	.L18:
 337:proximal.c    ****               LEDoff();
 464               		.loc 1 337 0
 465 01d4 0E94 0000 		call LEDoff
 466               	.L32:
 332:proximal.c    ****           loop_cnt=0;
 467               		.loc 1 332 0
 468 01d8 80E0      		ldi r24,lo8(0)
 469 01da 90E0      		ldi r25,hi8(0)
 470 01dc DC01      		movw r26,r24
 471               	.LVL21:
 472               	.L17:
 339:proximal.c    ****       if (DOWNSTREAM_USART.STATUS & USART_RXCIF_bm) {
 473               		.loc 1 339 0
 474 01de 2091 A109 		lds r18,2465
 475 01e2 27FF      		sbrs r18,7
 476 01e4 00C0      		rjmp .L19
 340:proximal.c    ****           up_fifo[up_head++] = DOWNSTREAM_USART.DATA;
 477               		.loc 1 340 0
 478 01e6 2091 A009 		lds r18,2464
 479 01ea E1E1      		ldi r30,lo8(17)
 480 01ec F0E0      		ldi r31,hi8(17)
 481 01ee EC0F      		add r30,r28
 482 01f0 FD1F      		adc r31,r29
 483 01f2 EE0D      		add r30,r14
 484 01f4 F11D      		adc r31,__zero_reg__
 485 01f6 2083      		st Z,r18
 486 01f8 E394      		inc r14
 487               	.LVL22:
 341:proximal.c    ****           up_head %= sizeof(up_fifo);
 488               		.loc 1 341 0
 489 01fa 2FE0      		ldi r18,lo8(15)
 490 01fc E222      		and r14,r18
 491               	.LVL23:
 492               	.L19:
 343:proximal.c    ****       if (UPSTREAM_USART.STATUS & USART_RXCIF_bm) {
 493               		.loc 1 343 0
 494 01fe 2091 A10A 		lds r18,2721
 495 0202 27FF      		sbrs r18,7
 496 0204 00C0      		rjmp .L20
 344:proximal.c    ****           down_fifo[down_head++] = UPSTREAM_USART.DATA;
 497               		.loc 1 344 0
 498 0206 2091 A00A 		lds r18,2720
 499 020a E1E0      		ldi r30,lo8(1)
 500 020c F0E0      		ldi r31,hi8(1)
 501 020e EC0F      		add r30,r28
 502 0210 FD1F      		adc r31,r29
 503 0212 E00F      		add r30,r16
 504 0214 F11D      		adc r31,__zero_reg__
 505 0216 2083      		st Z,r18
 506 0218 0F5F      		subi r16,lo8(-(1))
 507               	.LVL24:
 345:proximal.c    ****           down_head %= sizeof(down_fifo);
 508               		.loc 1 345 0
 509 021a 0F70      		andi r16,lo8(15)
 510               	.LVL25:
 511               	.L20:
 347:proximal.c    ****       if (up_head != up_tail && (UPSTREAM_USART.STATUS & USART_DREIF_bm)) {
 512               		.loc 1 347 0
 513 021c EF14      		cp r14,r15
 514 021e 01F0      		breq .L21
 347:proximal.c    ****       if (up_head != up_tail && (UPSTREAM_USART.STATUS & USART_DREIF_bm)) {
 515               		.loc 1 347 0 is_stmt 0 discriminator 1
 516 0220 2091 A10A 		lds r18,2721
 517 0224 25FF      		sbrs r18,5
 518 0226 00C0      		rjmp .L21
 348:proximal.c    ****           UPSTREAM_USART.DATA = up_fifo[up_tail++];
 519               		.loc 1 348 0 is_stmt 1
 520 0228 E1E1      		ldi r30,lo8(17)
 521 022a F0E0      		ldi r31,hi8(17)
 522 022c EC0F      		add r30,r28
 523 022e FD1F      		adc r31,r29
 524 0230 EF0D      		add r30,r15
 525 0232 F11D      		adc r31,__zero_reg__
 526 0234 2081      		ld r18,Z
 527 0236 2093 A00A 		sts 2720,r18
 528 023a F394      		inc r15
 529               	.LVL26:
 349:proximal.c    ****           up_tail %= sizeof(up_fifo);
 530               		.loc 1 349 0
 531 023c 2FE0      		ldi r18,lo8(15)
 532 023e F222      		and r15,r18
 533               	.LVL27:
 534               	.L21:
 351:proximal.c    ****       if (down_head != down_tail && (DOWNSTREAM_USART.STATUS & USART_DREIF_bm)) {
 535               		.loc 1 351 0
 536 0240 0117      		cp r16,r17
 537 0242 01F0      		breq .L22
 351:proximal.c    ****       if (down_head != down_tail && (DOWNSTREAM_USART.STATUS & USART_DREIF_bm)) {
 538               		.loc 1 351 0 is_stmt 0 discriminator 1
 539 0244 2091 A109 		lds r18,2465
 540 0248 25FF      		sbrs r18,5
 541 024a 00C0      		rjmp .L22
 352:proximal.c    ****           DOWNSTREAM_USART.DATA = down_fifo[down_tail++];
 542               		.loc 1 352 0 is_stmt 1
 543 024c E1E0      		ldi r30,lo8(1)
 544 024e F0E0      		ldi r31,hi8(1)
 545 0250 EC0F      		add r30,r28
 546 0252 FD1F      		adc r31,r29
 547 0254 E10F      		add r30,r17
 548 0256 F11D      		adc r31,__zero_reg__
 549 0258 2081      		ld r18,Z
 550 025a 2093 A009 		sts 2464,r18
 551 025e 1F5F      		subi r17,lo8(-(1))
 552               	.LVL28:
 353:proximal.c    ****           down_tail %= sizeof(down_fifo);
 553               		.loc 1 353 0
 554 0260 1F70      		andi r17,lo8(15)
 555               	.LVL29:
 556               	.L22:
 327:proximal.c    ****   while(sec_cnt < 200) 
 557               		.loc 1 327 0 discriminator 1
 558 0262 28EC      		ldi r18,lo8(200)
 559 0264 C216      		cp r12,r18
 560 0266 D104      		cpc r13,__zero_reg__
 561 0268 04F4      		brge .+2
 562 026a 00C0      		rjmp .L23
 358:proximal.c    ****   wdt_enable(WDT_PER_8CLK_gc);
 563               		.loc 1 358 0
 564 026c 93E0      		ldi r25,lo8(3)
 565 026e 88ED      		ldi r24,lo8(-40)
 566               	.LVL30:
 567               	/* #APP */
 568               	 ;  358 "proximal.c" 1
 569 0270 08B6      		in __tmp_reg__, 56
 570 0272 84BF      		out 52, r24
 571 0274 9093 8000 		sts 128, r25
 572 0278 A895      		wdr
 573 027a 08BE      		out 56, __tmp_reg__
 574               		
 575               	 ;  0 "" 2
 576               	/* #NOAPP */
 577               	.L24:
 578 027c 00C0      		rjmp .L24
 579               		.cfi_endproc
 580               	.LFE14:
 582               	.global	processCommand
 584               	processCommand:
 585               	.LFB16:
 377:proximal.c    **** {
 586               		.loc 1 377 0
 587               		.cfi_startproc
 588               	.LVL31:
 589 027e CF92      		push r12
 590               	.LCFI23:
 591               		.cfi_def_cfa_offset 3
 592               		.cfi_offset 12, -2
 593 0280 DF92      		push r13
 594               	.LCFI24:
 595               		.cfi_def_cfa_offset 4
 596               		.cfi_offset 13, -3
 597 0282 EF92      		push r14
 598               	.LCFI25:
 599               		.cfi_def_cfa_offset 5
 600               		.cfi_offset 14, -4
 601 0284 FF92      		push r15
 602               	.LCFI26:
 603               		.cfi_def_cfa_offset 6
 604               		.cfi_offset 15, -5
 605 0286 0F93      		push r16
 606               	.LCFI27:
 607               		.cfi_def_cfa_offset 7
 608               		.cfi_offset 16, -6
 609 0288 1F93      		push r17
 610               	.LCFI28:
 611               		.cfi_def_cfa_offset 8
 612               		.cfi_offset 17, -7
 613 028a CF93      		push r28
 614               	.LCFI29:
 615               		.cfi_def_cfa_offset 9
 616               		.cfi_offset 28, -8
 617 028c DF93      		push r29
 618               	.LCFI30:
 619               		.cfi_def_cfa_offset 10
 620               		.cfi_offset 29, -9
 621 028e CDB7      		in r28,__SP_L__
 622 0290 DEB7      		in r29,__SP_H__
 623 0292 6897      		sbiw r28,24
 624               	.LCFI31:
 625               		.cfi_def_cfa 28, 34
 626 0294 CDBF      		out __SP_L__,r28
 627 0296 DEBF      		out __SP_H__,r29
 628               	/* prologue: function */
 629               	/* frame size = 24 */
 630               	/* stack size = 32 */
 631               	.L__stack_usage = 32
 632 0298 8C01      		movw r16,r24
 633 029a 6B01      		movw r12,r22
 380:proximal.c    ****   opcode = commandPacket[COMMAND_OFFSET] & OPCODE_BITMASK;
 634               		.loc 1 380 0
 635 029c FC01      		movw r30,r24
 636 029e 8181      		ldd r24,Z+1
 637               	.LVL32:
 638 02a0 982F      		mov r25,r24
 639 02a2 907F      		andi r25,lo8(-16)
 640               	.LVL33:
 382:proximal.c    ****   switch(opcode)
 641               		.loc 1 382 0
 642 02a4 9038      		cpi r25,lo8(-128)
 643 02a6 01F4      		brne .+2
 644 02a8 00C0      		rjmp .L36
 645               	.LVL34:
 646 02aa 9138      		cpi r25,lo8(-127)
 647 02ac 00F4      		brsh .L39
 648 02ae 9036      		cpi r25,lo8(96)
 649 02b0 01F4      		brne .+2
 650 02b2 00C0      		rjmp .L36
 651 02b4 9037      		cpi r25,lo8(112)
 652 02b6 01F4      		brne .+2
 653 02b8 00C0      		rjmp .L36
 654 02ba 9923      		tst r25
 655 02bc 01F0      		breq .L35
 656 02be 00C0      		rjmp .L34
 657               	.L39:
 658 02c0 903B      		cpi r25,lo8(-80)
 659 02c2 01F4      		brne .+2
 660 02c4 00C0      		rjmp .L37
 661 02c6 903C      		cpi r25,lo8(-64)
 662 02c8 01F4      		brne .+2
 663 02ca 00C0      		rjmp .L38
 664 02cc 9039      		cpi r25,lo8(-112)
 665 02ce 01F0      		breq .+2
 666 02d0 00C0      		rjmp .L34
 667 02d2 00C0      		rjmp .L36
 668               	.L35:
 669               	.LVL35:
 670               	.LBB29:
 671               	.LBB30:
 104:proximal.c    ****     memcpy(&collectionBitfield, &commandPacket[PAYLOAD_OFFSET], 2);
 672               		.loc 1 104 0
 673 02d4 F801      		movw r30,r16
 674 02d6 E280      		ldd r14,Z+2
 675 02d8 F380      		ldd r15,Z+3
 676               	.LVL36:
 106:proximal.c    ****     if (collectionBitfield & (DATA_COLLECTION_DISTALJOINT_BITMASK | DATA_COLLECTION_DYNAMIC_BITMASK
 677               		.loc 1 106 0
 678 02da C701      		movw r24,r14
 679 02dc 8070      		andi r24,lo8(20480)
 680 02de 9075      		andi r25,hi8(20480)
 681 02e0 0097      		sbiw r24,0
 682 02e2 01F0      		breq .L40
 108:proximal.c    ****         captureSweep(adcData);
 683               		.loc 1 108 0
 684 02e4 CE01      		movw r24,r28
 685 02e6 0B96      		adiw r24,11
 686 02e8 0E94 0000 		call captureSweep
 687               	.LVL37:
 688               	.L40:
 111:proximal.c    ****     if(collectionBitfield & DATA_COLLECTION_ACCELERATION_BITMASK)
 689               		.loc 1 111 0
 690 02ec F7FE      		sbrs r15,7
 691 02ee 00C0      		rjmp .L65
 113:proximal.c    ****         readAxes(accelData);
 692               		.loc 1 113 0
 693 02f0 CE01      		movw r24,r28
 694 02f2 0596      		adiw r24,5
 695 02f4 0E94 0000 		call readAxes
 114:proximal.c    ****         memcpy(&outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize], &accelData, 6);
 696               		.loc 1 114 0
 697 02f8 F601      		movw r30,r12
 698 02fa 3396      		adiw r30,3
 699 02fc DE01      		movw r26,r28
 700 02fe 1596      		adiw r26,5
 701 0300 86E0      		ldi r24,lo8(6)
 702               	.L42:
 703 0302 0D90      		ld r0,X+
 704 0304 0192      		st Z+,r0
 705 0306 8150      		subi r24,lo8(-(-1))
 706 0308 01F4      		brne .L42
 707               	.LVL38:
 115:proximal.c    ****         responseSize += 6;
 708               		.loc 1 115 0
 709 030a 06E0      		ldi r16,lo8(6)
 710               	.LVL39:
 711 030c 00C0      		rjmp .L41
 712               	.LVL40:
 713               	.L65:
  98:proximal.c    ****     uint8_t responseSize = 0;
 714               		.loc 1 98 0
 715 030e 00E0      		ldi r16,lo8(0)
 716               	.LVL41:
 717               	.L41:
 118:proximal.c    ****     if(collectionBitfield & DATA_COLLECTION_DYNAMIC_BITMASK)
 718               		.loc 1 118 0
 719 0310 F6FE      		sbrs r15,6
 720 0312 00C0      		rjmp .L43
 120:proximal.c    ****         memcpy(&outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize], &adcData[DYNAMIC_OFFSET], 6);
 721               		.loc 1 120 0
 722 0314 E02F      		mov r30,r16
 723 0316 F0E0      		ldi r31,lo8(0)
 724 0318 3396      		adiw r30,3
 725 031a EC0D      		add r30,r12
 726 031c FD1D      		adc r31,r13
 727 031e DE01      		movw r26,r28
 728 0320 5396      		adiw r26,19
 729 0322 86E0      		ldi r24,lo8(6)
 730               	.L44:
 731 0324 0D90      		ld r0,X+
 732 0326 0192      		st Z+,r0
 733 0328 8150      		subi r24,lo8(-(-1))
 734 032a 01F4      		brne .L44
 121:proximal.c    ****         responseSize += 6;
 735               		.loc 1 121 0
 736 032c 0A5F      		subi r16,lo8(-(6))
 737               	.LVL42:
 738               	.L43:
 124:proximal.c    ****     if(collectionBitfield & DATA_COLLECTION_DISTALJOINT_BITMASK)
 739               		.loc 1 124 0
 740 032e F4FE      		sbrs r15,4
 741 0330 00C0      		rjmp .L45
 126:proximal.c    ****         memcpy(&outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize], &adcData[DISTALJOINT_OFFSET], 8
 742               		.loc 1 126 0
 743 0332 E02F      		mov r30,r16
 744 0334 F0E0      		ldi r31,lo8(0)
 745 0336 3396      		adiw r30,3
 746 0338 EC0D      		add r30,r12
 747 033a FD1D      		adc r31,r13
 748 033c DE01      		movw r26,r28
 749 033e 1B96      		adiw r26,11
 750 0340 88E0      		ldi r24,lo8(8)
 751               	.L46:
 752 0342 0D90      		ld r0,X+
 753 0344 0192      		st Z+,r0
 754 0346 8150      		subi r24,lo8(-(-1))
 755 0348 01F4      		brne .L46
 127:proximal.c    ****         responseSize += 8;
 756               		.loc 1 127 0
 757 034a 085F      		subi r16,lo8(-(8))
 758               	.LVL43:
 759               	.L45:
 130:proximal.c    ****     if(collectionBitfield & DATA_COLLECTION_PROXIMALJOINT_BITMASK)
 760               		.loc 1 130 0
 761 034c F3FE      		sbrs r15,3
 762 034e 00C0      		rjmp .L47
 132:proximal.c    ****         encoderData = readEncoder();
 763               		.loc 1 132 0
 764 0350 0E94 0000 		call readEncoder
 765               	.LVL44:
 133:proximal.c    ****         memcpy(&outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize], &encoderData, 2);
 766               		.loc 1 133 0
 767 0354 F601      		movw r30,r12
 768 0356 E00F      		add r30,r16
 769 0358 F11D      		adc r31,__zero_reg__
 770 035a 8383      		std Z+3,r24
 771 035c 9483      		std Z+4,r25
 134:proximal.c    ****         responseSize += 2;
 772               		.loc 1 134 0
 773 035e 0E5F      		subi r16,lo8(-(2))
 774               	.LVL45:
 775               	.L47:
 137:proximal.c    ****     if(collectionBitfield & DATA_COLLECTION_TACTILE_BITMASK)
 776               		.loc 1 137 0
 777 0360 F1FE      		sbrs r15,1
 778 0362 00C0      		rjmp .L48
 139:proximal.c    ****         memcpy(&outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize], &pressureData, numPressureSenso
 779               		.loc 1 139 0
 780 0364 4091 0000 		lds r20,numPressureSensors
 781 0368 802F      		mov r24,r16
 782 036a 90E0      		ldi r25,lo8(0)
 783 036c 0396      		adiw r24,3
 784 036e 8C0D      		add r24,r12
 785 0370 9D1D      		adc r25,r13
 786 0372 50E0      		ldi r21,lo8(0)
 787 0374 440F      		lsl r20
 788 0376 551F      		rol r21
 789 0378 60E0      		ldi r22,lo8(pressureData)
 790 037a 70E0      		ldi r23,hi8(pressureData)
 791 037c 0E94 0000 		call memcpy
 140:proximal.c    ****         responseSize += numPressureSensors*2;
 792               		.loc 1 140 0
 793 0380 8091 0000 		lds r24,numPressureSensors
 794 0384 880F      		lsl r24
 795 0386 080F      		add r16,r24
 796               	.LVL46:
 797               	.L48:
 143:proximal.c    ****     if(collectionBitfield & DATA_COLLECTION_DEBUG_BITMASK)
 798               		.loc 1 143 0
 799 0388 E1FE      		sbrs r14,1
 800 038a 00C0      		rjmp .L50
 145:proximal.c    ****         memcpy(&outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize], &RxCheckSumErrCnt, 4);
 801               		.loc 1 145 0
 802 038c F601      		movw r30,r12
 803 038e E00F      		add r30,r16
 804 0390 F11D      		adc r31,__zero_reg__
 805 0392 8091 0000 		lds r24,RxCheckSumErrCnt
 806 0396 9091 0000 		lds r25,RxCheckSumErrCnt+1
 807 039a A091 0000 		lds r26,RxCheckSumErrCnt+2
 808 039e B091 0000 		lds r27,RxCheckSumErrCnt+3
 809 03a2 8383      		std Z+3,r24
 810 03a4 9483      		std Z+4,r25
 811 03a6 A583      		std Z+5,r26
 812 03a8 B683      		std Z+6,r27
 146:proximal.c    ****         responseSize += 4;
 813               		.loc 1 146 0
 814 03aa 0C5F      		subi r16,lo8(-(4))
 815               	.LVL47:
 816               	.L50:
 149:proximal.c    ****     if(collectionBitfield & DATA_COLLECTION_TACTILE_TEMP_BITMASK)
 817               		.loc 1 149 0
 818 03ac E0FE      		sbrs r14,0
 819 03ae 00C0      		rjmp .L51
 151:proximal.c    ****         memcpy(&outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize], &pressureTempData, numPressureS
 820               		.loc 1 151 0
 821 03b0 4091 0000 		lds r20,numPressureSensors
 822 03b4 802F      		mov r24,r16
 823 03b6 90E0      		ldi r25,lo8(0)
 824 03b8 0396      		adiw r24,3
 825 03ba 8C0D      		add r24,r12
 826 03bc 9D1D      		adc r25,r13
 827 03be 50E0      		ldi r21,lo8(0)
 828 03c0 440F      		lsl r20
 829 03c2 551F      		rol r21
 830 03c4 60E0      		ldi r22,lo8(pressureTempData)
 831 03c6 70E0      		ldi r23,hi8(pressureTempData)
 832 03c8 0E94 0000 		call memcpy
 152:proximal.c    ****         responseSize += numPressureSensors*2;
 833               		.loc 1 152 0
 834 03cc 8091 0000 		lds r24,numPressureSensors
 835 03d0 880F      		lsl r24
 836 03d2 080F      		add r16,r24
 837               	.LVL48:
 838               	.L51:
 155:proximal.c    ****     outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3+responseSize;
 839               		.loc 1 155 0
 840 03d4 802F      		mov r24,r16
 841 03d6 8D5F      		subi r24,lo8(-(3))
 842 03d8 F601      		movw r30,r12
 843 03da 8083      		st Z,r24
 156:proximal.c    ****     outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = DATA_COLLECTION_OPCODE;
 844               		.loc 1 156 0
 845 03dc 1182      		std Z+1,__zero_reg__
 157:proximal.c    ****     outputBuffer[RESPONSE_STATUSCODE_OFFSET] = STATUS_OK;
 846               		.loc 1 157 0
 847 03de 1282      		std Z+2,__zero_reg__
 158:proximal.c    ****     outputBuffer[3+responseSize] = computeChecksum(outputBuffer,3+responseSize); //this is the chec
 848               		.loc 1 158 0
 849 03e0 10E0      		ldi r17,lo8(0)
 850 03e2 B801      		movw r22,r16
 851 03e4 6D5F      		subi r22,lo8(-(3))
 852 03e6 7F4F      		sbci r23,hi8(-(3))
 853 03e8 7601      		movw r14,r12
 854               	.LVL49:
 855 03ea E60E      		add r14,r22
 856 03ec F71E      		adc r15,r23
 857 03ee C601      		movw r24,r12
 858 03f0 0E94 0000 		call computeChecksum
 859 03f4 F701      		movw r30,r14
 860 03f6 8083      		st Z,r24
 159:proximal.c    ****     return 4+responseSize;
 861               		.loc 1 159 0
 862 03f8 C801      		movw r24,r16
 863 03fa 0496      		adiw r24,4
 864               	.LBE30:
 865               	.LBE29:
 385:proximal.c    ****           return handleCollectionCommand(commandPacket,outputBuffer);
 866               		.loc 1 385 0
 867 03fc 00C0      		rjmp .L53
 868               	.LVL50:
 869               	.L36:
 870               	.LBB31:
 871               	.LBB32:
 206:proximal.c    ****     address = commandPacket[COMMAND_OFFSET] & 0x1F;
 872               		.loc 1 206 0
 873 03fe 8F71      		andi r24,lo8(31)
 874               	.LVL51:
 208:proximal.c    ****     switch(opcode)
 875               		.loc 1 208 0
 876 0400 9037      		cpi r25,lo8(112)
 877 0402 01F0      		breq .L55
 878 0404 9137      		cpi r25,lo8(113)
 879 0406 00F4      		brsh .L57
 880 0408 9036      		cpi r25,lo8(96)
 881 040a 01F4      		brne .L54
 882 040c 00C0      		rjmp .L55
 883               	.L57:
 884 040e 9038      		cpi r25,lo8(-128)
 885 0410 01F0      		breq .L56
 886 0412 9039      		cpi r25,lo8(-112)
 887 0414 01F4      		brne .L54
 888 0416 00C0      		rjmp .L56
 889               	.L55:
 213:proximal.c    ****             ReadIntFromEEPROM(address, &outputBuffer[RESPONSE_PAYLOAD_OFFSET]);
 890               		.loc 1 213 0
 891 0418 B601      		movw r22,r12
 892 041a 6D5F      		subi r22,lo8(-(3))
 893 041c 7F4F      		sbci r23,hi8(-(3))
 894 041e 0E94 0000 		call ReadIntFromEEPROM
 895               	.LVL52:
 215:proximal.c    ****             outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3+responseSize;
 896               		.loc 1 215 0
 897 0422 87E0      		ldi r24,lo8(7)
 898 0424 F601      		movw r30,r12
 899 0426 8083      		st Z,r24
 216:proximal.c    ****             outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = commandPacket[COMMAND_OFFSET];
 900               		.loc 1 216 0
 901 0428 F801      		movw r30,r16
 902 042a 8181      		ldd r24,Z+1
 903 042c F601      		movw r30,r12
 904 042e 8183      		std Z+1,r24
 217:proximal.c    ****             outputBuffer[RESPONSE_STATUSCODE_OFFSET] = STATUS_OK;
 905               		.loc 1 217 0
 906 0430 1282      		std Z+2,__zero_reg__
 218:proximal.c    ****             outputBuffer[3+responseSize] = computeChecksum(outputBuffer,3+responseSize); //this is 
 907               		.loc 1 218 0
 908 0432 C601      		movw r24,r12
 909 0434 67E0      		ldi r22,lo8(7)
 910 0436 70E0      		ldi r23,hi8(7)
 911 0438 0E94 0000 		call computeChecksum
 912 043c F601      		movw r30,r12
 913 043e 8783      		std Z+7,r24
 219:proximal.c    ****             return 4+responseSize;
 914               		.loc 1 219 0
 915 0440 88E0      		ldi r24,lo8(8)
 916 0442 90E0      		ldi r25,hi8(8)
 917 0444 00C0      		rjmp .L53
 918               	.LVL53:
 919               	.L56:
 224:proximal.c    ****             WriteIntToEEPROM(address, &commandPacket[PAYLOAD_OFFSET]);
 920               		.loc 1 224 0
 921 0446 B801      		movw r22,r16
 922 0448 6E5F      		subi r22,lo8(-(2))
 923 044a 7F4F      		sbci r23,hi8(-(2))
 924 044c 0E94 0000 		call WriteIntToEEPROM
 925               	.LVL54:
 227:proximal.c    ****             initStateFromEEPROM();
 926               		.loc 1 227 0
 927 0450 0E94 0000 		call initStateFromEEPROM
 230:proximal.c    ****             outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3;
 928               		.loc 1 230 0
 929 0454 83E0      		ldi r24,lo8(3)
 930 0456 F601      		movw r30,r12
 931 0458 8083      		st Z,r24
 231:proximal.c    ****             outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = commandPacket[COMMAND_OFFSET];
 932               		.loc 1 231 0
 933 045a F801      		movw r30,r16
 934 045c 8181      		ldd r24,Z+1
 935 045e F601      		movw r30,r12
 936 0460 00C0      		rjmp .L71
 937               	.LVL55:
 938               	.L54:
 236:proximal.c    ****             outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3;
 939               		.loc 1 236 0
 940 0462 83E0      		ldi r24,lo8(3)
 941               	.LVL56:
 942 0464 F601      		movw r30,r12
 943 0466 8083      		st Z,r24
 237:proximal.c    ****             outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = commandPacket[COMMAND_OFFSET];
 944               		.loc 1 237 0
 945 0468 F801      		movw r30,r16
 946 046a 8181      		ldd r24,Z+1
 947 046c F601      		movw r30,r12
 948 046e 8183      		std Z+1,r24
 949 0470 00C0      		rjmp .L72
 950               	.LVL57:
 951               	.L38:
 952               	.LBE32:
 953               	.LBE31:
 954               	.LBB33:
 955               	.LBB34:
 248:proximal.c    ****     memcpy(&collectionBitfield, &commandPacket[PAYLOAD_OFFSET], 2);
 956               		.loc 1 248 0
 957 0472 F801      		movw r30,r16
 958 0474 4281      		ldd r20,Z+2
 959 0476 5381      		ldd r21,Z+3
 960               	.LVL58:
 250:proximal.c    ****     if(collectionBitfield & DATA_COLLECTION_TACTILE_BITMASK)
 961               		.loc 1 250 0
 962 0478 51FF      		sbrs r21,1
 963 047a 00C0      		rjmp .L59
 964 047c A0E0      		ldi r26,lo8(pressureData)
 965 047e B0E0      		ldi r27,hi8(pressureData)
 966 0480 E0E0      		ldi r30,lo8(pressureDataOffset)
 967 0482 F0E0      		ldi r31,hi8(pressureDataOffset)
 968 0484 60E0      		ldi r22,lo8(0)
 969               	.L60:
 970               	.LBB35:
 255:proximal.c    ****             pressureDataOffset[i] = pressureData[i] + pressureDataOffset[i];
 971               		.loc 1 255 0
 972 0486 2D91      		ld r18,X+
 973 0488 3D91      		ld r19,X+
 974 048a 8081      		ld r24,Z
 975 048c 9181      		ldd r25,Z+1
 976 048e 820F      		add r24,r18
 977 0490 931F      		adc r25,r19
 978 0492 8193      		st Z+,r24
 979 0494 9193      		st Z+,r25
 253:proximal.c    ****         for(uint8_t i=0; i<MAXIMUM_NUMBER_OF_TACTILE_SENSORS; i++)
 980               		.loc 1 253 0
 981 0496 6F5F      		subi r22,lo8(-(1))
 982               	.LVL59:
 983 0498 6C30      		cpi r22,lo8(12)
 984 049a 01F4      		brne .L60
 985               	.LVL60:
 986               	.L59:
 987               	.LBE35:
 259:proximal.c    ****     if (collectionBitfield & DATA_COLLECTION_DEBUG_BITMASK)
 988               		.loc 1 259 0
 989 049c 41FF      		sbrs r20,1
 990 049e 00C0      		rjmp .L61
 261:proximal.c    ****         RxCheckSumErrCnt[0] = 0;
 991               		.loc 1 261 0
 992 04a0 1092 0000 		sts RxCheckSumErrCnt,__zero_reg__
 993 04a4 1092 0000 		sts RxCheckSumErrCnt+1,__zero_reg__
 262:proximal.c    ****         RxCheckSumErrCnt[1] = 0;
 994               		.loc 1 262 0
 995 04a8 1092 0000 		sts RxCheckSumErrCnt+2,__zero_reg__
 996 04ac 1092 0000 		sts RxCheckSumErrCnt+2+1,__zero_reg__
 997               	.L61:
 265:proximal.c    ****     if (collectionBitfield & DATA_COLLECTION_PROXIMALJOINT_BITMASK)
 998               		.loc 1 265 0
 999 04b0 53FF      		sbrs r21,3
 1000 04b2 00C0      		rjmp .L62
 1001               	.LBB36:
 267:proximal.c    ****         encoderOffset = readRawEncoder();
 1002               		.loc 1 267 0
 1003 04b4 0E94 0000 		call readRawEncoder
 1004               	.LVL61:
 1005 04b8 8093 0000 		sts encoderOffset,r24
 1006 04bc 9093 0000 		sts encoderOffset+1,r25
 268:proximal.c    ****         uint32_t temp = encoderOffset;
 1007               		.loc 1 268 0
 1008 04c0 AA27      		clr r26
 1009 04c2 97FD      		sbrc r25,7
 1010 04c4 A095      		com r26
 1011 04c6 BA2F      		mov r27,r26
 1012               	.LVL62:
 1013 04c8 8983      		std Y+1,r24
 1014 04ca 9A83      		std Y+2,r25
 1015 04cc AB83      		std Y+3,r26
 1016 04ce BC83      		std Y+4,r27
 1017               	.LVL63:
 269:proximal.c    ****         WriteIntToEEPROM(EEPROM_ADDRESS_ENCODER_OFFSET, (uint8_t*)&temp);
 1018               		.loc 1 269 0
 1019 04d0 8CE1      		ldi r24,lo8(28)
 1020               	.LVL64:
 1021 04d2 BE01      		movw r22,r28
 1022 04d4 6F5F      		subi r22,lo8(-(1))
 1023 04d6 7F4F      		sbci r23,hi8(-(1))
 1024 04d8 0E94 0000 		call WriteIntToEEPROM
 1025               	.L62:
 1026               	.LBE36:
 272:proximal.c    ****     outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3;
 1027               		.loc 1 272 0
 1028 04dc 83E0      		ldi r24,lo8(3)
 1029 04de F601      		movw r30,r12
 1030 04e0 8083      		st Z,r24
 273:proximal.c    ****     outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = CALIBRATION_OPCODE;
 1031               		.loc 1 273 0
 1032 04e2 80EC      		ldi r24,lo8(-64)
 1033               	.LVL65:
 1034               	.L71:
 1035 04e4 8183      		std Z+1,r24
 274:proximal.c    ****     outputBuffer[RESPONSE_STATUSCODE_OFFSET] = STATUS_OK;
 1036               		.loc 1 274 0
 1037 04e6 1282      		std Z+2,__zero_reg__
 1038 04e8 00C0      		rjmp .L70
 1039               	.LVL66:
 1040               	.L37:
 1041               	.LBE34:
 1042               	.LBE33:
 1043               	.LBB37:
 1044               	.LBB38:
 365:proximal.c    ****   if(0x0f & commandPacket[PAYLOAD_OFFSET]){
 1045               		.loc 1 365 0
 1046 04ea F801      		movw r30,r16
 1047 04ec 8281      		ldd r24,Z+2
 1048 04ee 8F70      		andi r24,lo8(15)
 1049 04f0 01F0      		breq .L63
 366:proximal.c    ****     BootRelay(commandPacket);
 1050               		.loc 1 366 0
 1051 04f2 C801      		movw r24,r16
 1052 04f4 0E94 0000 		call BootRelay
 1053               	.LVL67:
 1054               	.L63:
 370:proximal.c    ****     wdt_enable(WDT_PER_8CLK_gc);
 1055               		.loc 1 370 0
 1056 04f8 93E0      		ldi r25,lo8(3)
 1057               	.LVL68:
 1058 04fa 88ED      		ldi r24,lo8(-40)
 1059               	/* #APP */
 1060               	 ;  370 "proximal.c" 1
 1061 04fc 08B6      		in __tmp_reg__, 56
 1062 04fe 84BF      		out 52, r24
 1063 0500 9093 8000 		sts 128, r25
 1064 0504 A895      		wdr
 1065 0506 08BE      		out 56, __tmp_reg__
 1066               		
 1067               	 ;  0 "" 2
 1068               	/* #NOAPP */
 1069               	.L64:
 1070 0508 00C0      		rjmp .L64
 1071               	.LVL69:
 1072               	.L34:
 1073               	.LBE38:
 1074               	.LBE37:
 400:proximal.c    ****           outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3;
 1075               		.loc 1 400 0
 1076 050a 83E0      		ldi r24,lo8(3)
 1077 050c F601      		movw r30,r12
 1078 050e 8083      		st Z,r24
 401:proximal.c    ****           outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = opcode;
 1079               		.loc 1 401 0
 1080 0510 9183      		std Z+1,r25
 1081               	.L72:
 402:proximal.c    ****           outputBuffer[RESPONSE_STATUSCODE_OFFSET] = UNKNOWN_COMMAND;
 1082               		.loc 1 402 0
 1083 0512 82E0      		ldi r24,lo8(2)
 1084 0514 8283      		std Z+2,r24
 1085               	.LVL70:
 1086               	.L70:
 403:proximal.c    ****           outputBuffer[3] = computeChecksum(outputBuffer,3); //this is the checksum
 1087               		.loc 1 403 0
 1088 0516 C601      		movw r24,r12
 1089 0518 63E0      		ldi r22,lo8(3)
 1090 051a 70E0      		ldi r23,hi8(3)
 1091 051c 0E94 0000 		call computeChecksum
 1092 0520 F601      		movw r30,r12
 1093 0522 8383      		std Z+3,r24
 404:proximal.c    ****           return 4;
 1094               		.loc 1 404 0
 1095 0524 84E0      		ldi r24,lo8(4)
 1096 0526 90E0      		ldi r25,hi8(4)
 1097               	.LVL71:
 1098               	.L53:
 1099               	/* epilogue start */
 406:proximal.c    **** }
 1100               		.loc 1 406 0
 1101 0528 6896      		adiw r28,24
 1102 052a CDBF      		out __SP_L__,r28
 1103 052c DEBF      		out __SP_H__,r29
 1104 052e DF91      		pop r29
 1105 0530 CF91      		pop r28
 1106 0532 1F91      		pop r17
 1107 0534 0F91      		pop r16
 1108 0536 FF90      		pop r15
 1109 0538 EF90      		pop r14
 1110 053a DF90      		pop r13
 1111 053c CF90      		pop r12
 1112               	.LVL72:
 1113 053e 0895      		ret
 1114               		.cfi_endproc
 1115               	.LFE16:
 1117               	.global	LEDtoggle
 1119               	LEDtoggle:
 1120               	.LFB19:
 417:proximal.c    **** 
 418:proximal.c    **** void LEDtoggle(void)
 419:proximal.c    **** {
 1121               		.loc 1 419 0
 1122               		.cfi_startproc
 1123               	/* prologue: function */
 1124               	/* frame size = 0 */
 1125               	/* stack size = 0 */
 1126               	.L__stack_usage = 0
 420:proximal.c    ****     PORTC.OUTTGL = 0x01;
 1127               		.loc 1 420 0
 1128 0540 81E0      		ldi r24,lo8(1)
 1129 0542 E0E4      		ldi r30,lo8(1600)
 1130 0544 F6E0      		ldi r31,hi8(1600)
 1131 0546 8783      		std Z+7,r24
 1132               	/* epilogue start */
 421:proximal.c    **** }
 1133               		.loc 1 421 0
 1134 0548 0895      		ret
 1135               		.cfi_endproc
 1136               	.LFE19:
 1138               		.section	.text.startup,"ax",@progbits
 1139               	.global	main
 1141               	main:
 1142               	.LFB20:
 422:proximal.c    **** 
 423:proximal.c    **** /************************************************************************
 424:proximal.c    **** * MAIN function.
 425:proximal.c    **** *
 426:proximal.c    **** * This initializes the other port modules and polls a few volatile status
 427:proximal.c    **** * bits set in ISRs.
 428:proximal.c    **** ************************************************************************/
 429:proximal.c    **** int main(void)
 430:proximal.c    **** {
 1143               		.loc 1 430 0
 1144               		.cfi_startproc
 1145 0000 CF93      		push r28
 1146               	.LCFI32:
 1147               		.cfi_def_cfa_offset 3
 1148               		.cfi_offset 28, -2
 1149 0002 DF93      		push r29
 1150               	.LCFI33:
 1151               		.cfi_def_cfa_offset 4
 1152               		.cfi_offset 29, -3
 1153 0004 00D0      		rcall .
 1154 0006 00D0      		rcall .
 1155               	.LCFI34:
 1156               		.cfi_def_cfa_offset 8
 1157 0008 CDB7      		in r28,__SP_L__
 1158 000a DEB7      		in r29,__SP_H__
 1159               	.LCFI35:
 1160               		.cfi_def_cfa_register 28
 1161               	/* prologue: function */
 1162               	/* frame size = 4 */
 1163               	/* stack size = 6 */
 1164               	.L__stack_usage = 6
 431:proximal.c    ****     cli();                                    //disable all interrupts for clock reset
 1165               		.loc 1 431 0
 1166               	/* #APP */
 1167               	 ;  431 "proximal.c" 1
 1168 000c F894      		cli
 1169               	 ;  0 "" 2
 1170               	.LVL73:
 1171               	/* #NOAPP */
 1172               	.LBB39:
 1173               	.LBB40:
 1174               		.file 2 "/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../av
   1:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   6:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   9:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  12:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      distribution.
  16:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  17:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  21:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  33:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  35:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  38:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  41:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  42:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <math.h>
  45:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  46:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \file */
  47:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \code
  49:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \endcode
  53:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  54:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     used.
  58:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  59:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  68:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  77:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  81:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** */
  82:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  83:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  87:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  88:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  93:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  94:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  97:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  98:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #  include <math.h>
 102:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
 103:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 104:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /**
 105:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 107:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 109:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 112:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 114:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 120:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 125:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 129:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 132:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 140:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  */
 141:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** void
 142:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** {
 144:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 153:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 156:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 159:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#else
 160:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//round up by default
 161:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#endif
 163:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 164:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1175               		.loc 2 164 0
 1176 000e 8FE3      		 ldi r24,lo8(7999)
 1177 0010 9FE1      	    ldi r25,hi8(7999)
 1178 0012 0197      	    1:sbiw r24,1
 1179 0014 01F4      	    brne 1b
 1180 0016 00C0      		rjmp .
 1181 0018 0000      		nop
 1182               	.LBE40:
 1183               	.LBE39:
 1184               	.LBB41:
 1185               	.LBB42:
  84:proximal.c    ****     OSC.CTRL = OSC_RC32MEN_bm | OSC_RC32KEN_bm;            //enable the 32MHz ring oscillator and t
 1186               		.loc 1 84 0
 1187 001a 86E0      		ldi r24,lo8(6)
 1188 001c 8093 5000 		sts 80,r24
 1189               	.L75:
  85:proximal.c    ****     while(!(OSC.STATUS & OSC_RC32MRDY_bm));                //wait for 32MHz to stabilize
 1190               		.loc 1 85 0
 1191 0020 8091 5100 		lds r24,81
 1192 0024 81FF      		sbrs r24,1
 1193 0026 00C0      		rjmp .L75
 1194               	.L83:
  86:proximal.c    ****     while(!(OSC.STATUS & OSC_RC32KRDY_bm));                //wait for 32kHz to stabilize
 1195               		.loc 1 86 0
 1196 0028 8091 5100 		lds r24,81
 1197 002c 82FF      		sbrs r24,2
 1198 002e 00C0      		rjmp .L83
  88:proximal.c    ****     DFLLRC32M.CTRL = DFLL_ENABLE_bm;
 1199               		.loc 1 88 0
 1200 0030 81E0      		ldi r24,lo8(1)
 1201 0032 8093 6000 		sts 96,r24
  89:proximal.c    ****     DFLLRC2M.CTRL = DFLL_ENABLE_bm;
 1202               		.loc 1 89 0
 1203 0036 8093 6800 		sts 104,r24
  91:proximal.c    ****     CCP = CCP_IOREG_gc;                                    //clock is protected by Configuration Ch
 1204               		.loc 1 91 0
 1205 003a 98ED      		ldi r25,lo8(-40)
 1206 003c 94BF      		out 52-0,r25
  92:proximal.c    ****     CLK.CTRL = CLK_SCLKSEL_RC32M_gc;                    //switch to 32MHz oscillator
 1207               		.loc 1 92 0
 1208 003e 8093 4000 		sts 64,r24
  93:proximal.c    ****     CLK.RTCCTRL = CLK_RTCSRC_RCOSC_gc | CLK_RTCEN_bm;    //Select 1.024 kHz from internal oscillato
 1209               		.loc 1 93 0
 1210 0042 85E0      		ldi r24,lo8(5)
 1211 0044 E0E4      		ldi r30,lo8(64)
 1212 0046 F0E0      		ldi r31,hi8(64)
 1213 0048 8383      		std Z+3,r24
 1214               	.LVL74:
 1215               	.LBE42:
 1216               	.LBE41:
 1217               	.LBB43:
 1218               	.LBB44:
 1219               		.loc 2 164 0
 1220 004a 8FE3      		 ldi r24,lo8(7999)
 1221 004c 9FE1      	    ldi r25,hi8(7999)
 1222 004e 0197      	    1:sbiw r24,1
 1223 0050 01F4      	    brne 1b
 1224 0052 00C0      		rjmp .
 1225 0054 0000      		nop
 1226               	.LBE44:
 1227               	.LBE43:
 432:proximal.c    ****     _delay_ms(1); // for stability of supplies
 433:proximal.c    ****     configureClocks();
 434:proximal.c    ****     _delay_ms(1); // for stability of clocks
 435:proximal.c    ****     configurePortIOProximal();
 1228               		.loc 1 435 0
 1229 0056 0E94 0000 		call configurePortIOProximal
 436:proximal.c    **** 
 437:proximal.c    ****     LEDon();
 1230               		.loc 1 437 0
 1231 005a 0E94 0000 		call LEDon
 438:proximal.c    **** 
 439:proximal.c    ****     //PORTE.OUT &= ~0x01; //BA: turn on sensor board
 440:proximal.c    **** 
 441:proximal.c    ****     configureADC();
 1232               		.loc 1 441 0
 1233 005e 0E94 0000 		call configureADC
 442:proximal.c    **** 
 443:proximal.c    ****     configureDaisyUSART();
 1234               		.loc 1 443 0
 1235 0062 0E94 0000 		call configureDaisyUSART
 444:proximal.c    **** 
 445:proximal.c    ****     initTactileModule(); // initialize variables of the tactile buffer
 1236               		.loc 1 445 0
 1237 0066 0E94 0000 		call initTactileModule
 446:proximal.c    **** 
 447:proximal.c    ****     PMIC.CTRL |= PMIC_LOLVLEN_bm; //tell event system to pay attention to low-priority interrupts
 1238               		.loc 1 447 0
 1239 006a 8091 A200 		lds r24,162
 1240 006e 8160      		ori r24,lo8(1)
 1241 0070 E0EA      		ldi r30,lo8(160)
 1242 0072 F0E0      		ldi r31,hi8(160)
 1243 0074 8283      		std Z+2,r24
 448:proximal.c    ****     sei();
 1244               		.loc 1 448 0
 1245               	/* #APP */
 1246               	 ;  448 "proximal.c" 1
 1247 0076 7894      		sei
 1248               	 ;  0 "" 2
 449:proximal.c    **** 
 450:proximal.c    ****     configureSPIModulesPressure();
 1249               		.loc 1 450 0
 1250               	/* #NOAPP */
 1251 0078 0E94 0000 		call configureSPIModulesPressure
 451:proximal.c    ****     collectAllCalibrationValues();
 1252               		.loc 1 451 0
 1253 007c 0E94 0000 		call collectAllCalibrationValues
 452:proximal.c    **** 
 453:proximal.c    ****     configureSPIModulesAccel();
 1254               		.loc 1 453 0
 1255 0080 0E94 0000 		call configureSPIModulesAccel
 454:proximal.c    ****     configAccel();
 1256               		.loc 1 454 0
 1257 0084 0E94 0000 		call configAccel
 455:proximal.c    **** 
 456:proximal.c    ****     LEDoff();
 1258               		.loc 1 456 0
 1259 0088 0E94 0000 		call LEDoff
 457:proximal.c    **** 
 458:proximal.c    ****     initStateFromEEPROM();
 1260               		.loc 1 458 0
 1261 008c 0E94 0000 		call initStateFromEEPROM
 1262               	.LBB45:
 1263               	.LBB46:
 190:proximal.c    ****     uint32_t readversion = 0;
 1264               		.loc 1 190 0
 1265 0090 1982      		std Y+1,__zero_reg__
 1266 0092 1A82      		std Y+2,__zero_reg__
 1267 0094 1B82      		std Y+3,__zero_reg__
 1268 0096 1C82      		std Y+4,__zero_reg__
 1269               	.LVL75:
 191:proximal.c    ****     ReadIntFromEEPROM(EEPROM_ADDRESS_FIRMWARE_VERSION, (uint8_t*)&readversion);
 1270               		.loc 1 191 0
 1271 0098 8DE1      		ldi r24,lo8(29)
 1272 009a BE01      		movw r22,r28
 1273 009c 6F5F      		subi r22,lo8(-(1))
 1274 009e 7F4F      		sbci r23,hi8(-(1))
 1275 00a0 0E94 0000 		call ReadIntFromEEPROM
 192:proximal.c    ****     if (readversion != FIRMWARE_VERSION)
 1276               		.loc 1 192 0
 1277 00a4 8981      		ldd r24,Y+1
 1278 00a6 9A81      		ldd r25,Y+2
 1279 00a8 AB81      		ldd r26,Y+3
 1280 00aa BC81      		ldd r27,Y+4
 1281 00ac 8D32      		cpi r24,lo8(301)
 1282 00ae 21E0      		ldi r18,hi8(301)
 1283 00b0 9207      		cpc r25,r18
 1284 00b2 20E0      		ldi r18,hlo8(301)
 1285 00b4 A207      		cpc r26,r18
 1286 00b6 20E0      		ldi r18,hhi8(301)
 1287 00b8 B207      		cpc r27,r18
 1288 00ba 01F0      		breq .L87
 194:proximal.c    ****         readversion = FIRMWARE_VERSION;
 1289               		.loc 1 194 0
 1290 00bc 8DE2      		ldi r24,lo8(301)
 1291 00be 91E0      		ldi r25,hi8(301)
 1292 00c0 A0E0      		ldi r26,hlo8(301)
 1293 00c2 B0E0      		ldi r27,hhi8(301)
 1294 00c4 8983      		std Y+1,r24
 1295 00c6 9A83      		std Y+2,r25
 1296 00c8 AB83      		std Y+3,r26
 1297 00ca BC83      		std Y+4,r27
 195:proximal.c    ****         WriteIntToEEPROM(EEPROM_ADDRESS_FIRMWARE_VERSION, (uint8_t*)&readversion);
 1298               		.loc 1 195 0
 1299 00cc 8DE1      		ldi r24,lo8(29)
 1300 00ce BE01      		movw r22,r28
 1301 00d0 6F5F      		subi r22,lo8(-(1))
 1302 00d2 7F4F      		sbci r23,hi8(-(1))
 1303 00d4 0E94 0000 		call WriteIntToEEPROM
 1304               	.L87:
 1305               	.LBE46:
 1306               	.LBE45:
 459:proximal.c    ****     verifyVersion();
 460:proximal.c    ****     
 461:proximal.c    ****     while(1){
 462:proximal.c    ****         
 463:proximal.c    ****         if(notifyDaisy)
 1307               		.loc 1 463 0
 1308 00d8 8091 0000 		lds r24,notifyDaisy
 1309 00dc 8823      		tst r24
 1310 00de 01F0      		breq .L78
 464:proximal.c    ****         {
 465:proximal.c    ****             doDaisyTask();
 1311               		.loc 1 465 0
 1312 00e0 0E94 0000 		call doDaisyTask
 1313               	.L78:
 466:proximal.c    ****         }
 467:proximal.c    ****         handleTC();
 1314               		.loc 1 467 0
 1315 00e4 0E94 0000 		call handleTC
 468:proximal.c    **** 
 469:proximal.c    ****         if(tactReady)
 1316               		.loc 1 469 0
 1317 00e8 8091 0000 		lds r24,tactReady
 1318 00ec 8823      		tst r24
 1319 00ee 01F0      		breq .L87
 470:proximal.c    ****         {
 471:proximal.c    ****             doTactSensors();
 1320               		.loc 1 471 0
 1321 00f0 0E94 0000 		call doTactSensors
 1322 00f4 00C0      		rjmp .L87
 1323               		.cfi_endproc
 1324               	.LFE20:
 1326               		.comm testADC,16,1
 1327               	.global	numPressureSensors
 1328               		.data
 1331               	numPressureSensors:
 1332 0000 0C        		.byte	12
 1333               		.text
 1334               	.Letext0:
 1335               		.file 3 "/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../av
 1336               		.file 4 "/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../av
 1337               		.file 5 "proximal.h"
 1338               		.file 6 "../common/daisycomm.h"
 1339               		.file 7 "tactsense.h"
 1340               		.file 8 "encoder.h"
DEFINED SYMBOLS
                            *ABS*:00000000 proximal.c
     /tmp/ccZJRGSz.s:2      *ABS*:0000003f __SREG__
     /tmp/ccZJRGSz.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccZJRGSz.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccZJRGSz.s:5      *ABS*:00000034 __CCP__
     /tmp/ccZJRGSz.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccZJRGSz.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccZJRGSz.s:14     .text:00000000 ReadIntFromEEPROM
     /tmp/ccZJRGSz.s:101    .text:0000004e WriteIntToEEPROM
     /tmp/ccZJRGSz.s:187    .text:0000009c LEDon
     /tmp/ccZJRGSz.s:209    .text:000000a8 LEDoff
     /tmp/ccZJRGSz.s:230    .text:000000b4 initStateFromEEPROM
     /tmp/ccZJRGSz.s:306    .text:00000112 BootRelay
     /tmp/ccZJRGSz.s:584    .text:0000027e processCommand
     /tmp/ccZJRGSz.s:1331   .data:00000000 numPressureSensors
     /tmp/ccZJRGSz.s:1119   .text:00000540 LEDtoggle
     /tmp/ccZJRGSz.s:1141   .text.startup:00000000 main
                            *COM*:00000010 testADC

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__eerd_byte_x32a4u
__eewr_byte_x32a4u
encoderOffset
captureSweep
readAxes
readEncoder
pressureData
memcpy
RxCheckSumErrCnt
pressureTempData
computeChecksum
pressureDataOffset
readRawEncoder
configurePortIOProximal
configureADC
configureDaisyUSART
initTactileModule
configureSPIModulesPressure
collectAllCalibrationValues
configureSPIModulesAccel
configAccel
notifyDaisy
doDaisyTask
handleTC
tactReady
doTactSensors
