   1               		.file	"velcounter.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  13               	.global	resetVelocityCounter
  15               	resetVelocityCounter:
  16               	.LFB2:
  17               		.file 1 "velcounter.c"
   1:velcounter.c  **** /****************************************************
   2:velcounter.c  **** 
   3:velcounter.c  ****  // Author:            Paul Butler
   4:velcounter.c  ****  // File Name:        C1482-SRC-FGRMCU-0-velcounter.c
   5:velcounter.c  ****  // Creation Date:    28 October, 2011
   6:velcounter.c  ****  // Revision:        01
   7:velcounter.c  ****  // Hardware:        ATxmega32A4
   8:velcounter.c  ****  // Description:    Palm Motor Controller Micro BLDC velocity counter using Hall sensors
   9:velcounter.c  **** 
  10:velcounter.c  **** ****************************************************/
  11:velcounter.c  **** 
  12:velcounter.c  **** /******************************************************************************
  13:velcounter.c  ****     File Revision History:
  14:velcounter.c  **** -------------------------------------------------------------------------------
  15:velcounter.c  **** Revision    Date        Engineer    Description
  16:velcounter.c  **** --------    --------    --------    -------------------------------------------
  17:velcounter.c  **** 00            10/28/11    PDB            Initial Release
  18:velcounter.c  **** 01            12/15/11    ZAC            Added variable to capture maximum RPM
  19:velcounter.c  **** -------------------------------------------------------------------------------
  20:velcounter.c  **** 
  21:velcounter.c  **** ******************************************************************************/
  22:velcounter.c  **** 
  23:velcounter.c  **** #include "velcounter.h"
  24:velcounter.c  **** 
  25:velcounter.c  **** #include <avr/io.h>
  26:velcounter.c  **** #include <avr/interrupt.h>
  27:velcounter.c  **** #include <math.h>
  28:velcounter.c  **** 
  29:velcounter.c  **** //Public variables
  30:velcounter.c  **** volatile uint16_t currentRelativeCount = 0;
  31:velcounter.c  **** float averagePeriod = 65534;
  32:velcounter.c  **** uint16_t averageRPM = 0;
  33:velcounter.c  **** 
  34:velcounter.c  **** //Private variables
  35:velcounter.c  **** static volatile uint16_t periodAccumulator = 0;
  36:velcounter.c  **** static volatile uint8_t samplesAccumulated = 0;
  37:velcounter.c  **** static volatile uint8_t accumulationOverflow = 0;
  38:velcounter.c  **** static volatile uint16_t previousAbsoluteCount = 0;
  39:velcounter.c  **** static volatile uint8_t stallCounter = 0;
  40:velcounter.c  **** //static volatile uint8_t overspeedCounter = 0;
  41:velcounter.c  **** 
  42:velcounter.c  **** static uint16_t periodToRPM(float period);
  43:velcounter.c  **** 
  44:velcounter.c  **** // uint8_t isOverspeed()
  45:velcounter.c  **** // {
  46:velcounter.c  **** //     return overspeedCounter;
  47:velcounter.c  **** // }
  48:velcounter.c  **** 
  49:velcounter.c  **** /************************************************************************
  50:velcounter.c  **** * resetVelocityCounter()
  51:velcounter.c  **** *
  52:velcounter.c  **** * Resets the velocity counter so that the next period
  53:velcounter.c  **** * measurement starts from zero
  54:velcounter.c  **** ************************************************************************/
  55:velcounter.c  **** void resetVelocityCounter(void)
  56:velcounter.c  **** {
  18               		.loc 1 56 0
  19               		.cfi_startproc
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 0 */
  23               	.L__stack_usage = 0
  57:velcounter.c  ****     accumulationOverflow = 0;
  24               		.loc 1 57 0
  25 0000 1092 0000 		sts accumulationOverflow,__zero_reg__
  58:velcounter.c  ****     periodAccumulator = 0;
  26               		.loc 1 58 0
  27 0004 1092 0000 		sts periodAccumulator,__zero_reg__
  28 0008 1092 0000 		sts periodAccumulator+1,__zero_reg__
  59:velcounter.c  ****     samplesAccumulated = 0;
  29               		.loc 1 59 0
  30 000c 1092 0000 		sts samplesAccumulated,__zero_reg__
  60:velcounter.c  ****     averagePeriod = 65534;
  31               		.loc 1 60 0
  32 0010 80E0      		ldi r24,lo8(0x477ffe00)
  33 0012 9EEF      		ldi r25,hi8(0x477ffe00)
  34 0014 AFE7      		ldi r26,hlo8(0x477ffe00)
  35 0016 B7E4      		ldi r27,hhi8(0x477ffe00)
  36 0018 8093 0000 		sts averagePeriod,r24
  37 001c 9093 0000 		sts averagePeriod+1,r25
  38 0020 A093 0000 		sts averagePeriod+2,r26
  39 0024 B093 0000 		sts averagePeriod+3,r27
  61:velcounter.c  ****     averageRPM = 0;
  40               		.loc 1 61 0
  41 0028 1092 0000 		sts averageRPM,__zero_reg__
  42 002c 1092 0000 		sts averageRPM+1,__zero_reg__
  62:velcounter.c  ****     //overspeedCounter = 0;
  63:velcounter.c  ****     stallCounter = 0;
  43               		.loc 1 63 0
  44 0030 1092 0000 		sts stallCounter,__zero_reg__
  45               	/* epilogue start */
  64:velcounter.c  **** }
  46               		.loc 1 64 0
  47 0034 0895      		ret
  48               		.cfi_endproc
  49               	.LFE2:
  51               	.global	readVelocitySignal
  53               	readVelocitySignal:
  54               	.LFB4:
  65:velcounter.c  **** 
  66:velcounter.c  **** /************************************************************************
  67:velcounter.c  **** * uint16_t periodToRPM(period)
  68:velcounter.c  **** *
  69:velcounter.c  **** * Converts the measured Hall sensor period to RPM
  70:velcounter.c  **** ************************************************************************/
  71:velcounter.c  **** static uint16_t periodToRPM(float period)
  72:velcounter.c  **** {
  73:velcounter.c  ****     float rawRPM = 1 / (PERIOD_CONVERSION_CONSTANT*MOTOR_POLE_PAIRS*period);
  74:velcounter.c  ****     if (rawRPM > 65535) return 65535;
  75:velcounter.c  ****     if (rawRPM < 0) return 0;
  76:velcounter.c  ****     return rawRPM;
  77:velcounter.c  **** }
  78:velcounter.c  **** 
  79:velcounter.c  **** /************************************************************************
  80:velcounter.c  **** * readVelocitySignal()
  81:velcounter.c  **** *
  82:velcounter.c  **** * Consumes the period accumulator signal and averages it.  If nothing has
  83:velcounter.c  **** * been accumulated since its last run, it leaves averagePeriod alone.
  84:velcounter.c  **** * This causes the PID loop to get the same input it received previously.
  85:velcounter.c  **** ************************************************************************/
  86:velcounter.c  **** void readVelocitySignal(void)
  87:velcounter.c  **** {
  55               		.loc 1 87 0
  56               		.cfi_startproc
  57 0036 CF92      		push r12
  58               	.LCFI0:
  59               		.cfi_def_cfa_offset 3
  60               		.cfi_offset 12, -2
  61 0038 DF92      		push r13
  62               	.LCFI1:
  63               		.cfi_def_cfa_offset 4
  64               		.cfi_offset 13, -3
  65 003a EF92      		push r14
  66               	.LCFI2:
  67               		.cfi_def_cfa_offset 5
  68               		.cfi_offset 14, -4
  69 003c FF92      		push r15
  70               	.LCFI3:
  71               		.cfi_def_cfa_offset 6
  72               		.cfi_offset 15, -5
  73 003e 1F93      		push r17
  74               	.LCFI4:
  75               		.cfi_def_cfa_offset 7
  76               		.cfi_offset 17, -6
  77 0040 CF93      		push r28
  78               	.LCFI5:
  79               		.cfi_def_cfa_offset 8
  80               		.cfi_offset 28, -7
  81 0042 DF93      		push r29
  82               	.LCFI6:
  83               		.cfi_def_cfa_offset 9
  84               		.cfi_offset 29, -8
  85               	/* prologue: function */
  86               	/* frame size = 0 */
  87               	/* stack size = 7 */
  88               	.L__stack_usage = 7
  88:velcounter.c  ****     float stallTime;
  89:velcounter.c  ****     //Average the accumulator if it is OK.
  90:velcounter.c  ****     //Otherwise fake a period measurement using the stall counter
  91:velcounter.c  ****     //The timer completely overflows with a period of 500 ms, but the control loop is polling at 5 
  92:velcounter.c  ****     //At really slow speeds (or a stall), an appropriate velocity needs to be synthesized.
  93:velcounter.c  ****     //Reset accumulation regardless
  94:velcounter.c  ****     if((accumulationOverflow == 0) && (samplesAccumulated != 0))
  89               		.loc 1 94 0
  90 0044 8091 0000 		lds r24,accumulationOverflow
  91 0048 8823      		tst r24
  92 004a 01F4      		brne .L3
  93               		.loc 1 94 0 is_stmt 0 discriminator 1
  94 004c 8091 0000 		lds r24,samplesAccumulated
  95 0050 8823      		tst r24
  96 0052 01F0      		breq .L3
  95:velcounter.c  ****     {
  96:velcounter.c  ****         averagePeriod = (float) periodAccumulator / (float) samplesAccumulated;
  97               		.loc 1 96 0 is_stmt 1
  98 0054 8091 0000 		lds r24,periodAccumulator
  99 0058 9091 0000 		lds r25,periodAccumulator+1
 100 005c C091 0000 		lds r28,samplesAccumulated
 101 0060 BC01      		movw r22,r24
 102 0062 80E0      		ldi r24,lo8(0)
 103 0064 90E0      		ldi r25,hi8(0)
 104 0066 0E94 0000 		call __floatunsisf
 105 006a 6B01      		movw r12,r22
 106 006c 7C01      		movw r14,r24
 107 006e 6C2F      		mov r22,r28
 108 0070 70E0      		ldi r23,lo8(0)
 109 0072 80E0      		ldi r24,lo8(0)
 110 0074 90E0      		ldi r25,hi8(0)
 111 0076 0E94 0000 		call __floatunsisf
 112 007a 9B01      		movw r18,r22
 113 007c AC01      		movw r20,r24
 114 007e C701      		movw r24,r14
 115 0080 B601      		movw r22,r12
 116 0082 0E94 0000 		call __divsf3
 117 0086 DC01      		movw r26,r24
 118 0088 CB01      		movw r24,r22
 119 008a 8093 0000 		sts averagePeriod,r24
 120 008e 9093 0000 		sts averagePeriod+1,r25
 121 0092 A093 0000 		sts averagePeriod+2,r26
 122 0096 B093 0000 		sts averagePeriod+3,r27
  97:velcounter.c  ****         stallCounter = 0;
 123               		.loc 1 97 0
 124 009a 1092 0000 		sts stallCounter,__zero_reg__
 125 009e 00C0      		rjmp .L4
 126               	.L3:
  98:velcounter.c  ****     } else {
  99:velcounter.c  ****         //Nothing happened since the last check.  Increment the stall counter
 100:velcounter.c  ****         stallCounter++;
 127               		.loc 1 100 0
 128 00a0 8091 0000 		lds r24,stallCounter
 129 00a4 8F5F      		subi r24,lo8(-(1))
 130 00a6 8093 0000 		sts stallCounter,r24
 101:velcounter.c  ****         if(stallCounter >= 100)
 131               		.loc 1 101 0
 132 00aa 8091 0000 		lds r24,stallCounter
 133 00ae 8436      		cpi r24,lo8(100)
 134 00b0 00F0      		brlo .L5
 102:velcounter.c  ****         {
 103:velcounter.c  ****             averagePeriod = 65534;
 135               		.loc 1 103 0
 136 00b2 80E0      		ldi r24,lo8(0x477ffe00)
 137 00b4 9EEF      		ldi r25,hi8(0x477ffe00)
 138 00b6 AFE7      		ldi r26,hlo8(0x477ffe00)
 139 00b8 B7E4      		ldi r27,hhi8(0x477ffe00)
 140 00ba 00C0      		rjmp .L11
 141               	.L5:
 104:velcounter.c  ****         } else {
 105:velcounter.c  ****             stallTime = stallCounter * COUNTS_PER_CONTROL_PERIOD;
 142               		.loc 1 105 0
 143 00bc 2091 0000 		lds r18,stallCounter
 144 00c0 30E0      		ldi r19,lo8(0)
 145 00c2 81E7      		ldi r24,lo8(625)
 146 00c4 92E0      		ldi r25,hi8(625)
 147 00c6 289F      		mul r18,r24
 148 00c8 B001      		movw r22,r0
 149 00ca 299F      		mul r18,r25
 150 00cc 700D      		add r23,r0
 151 00ce 389F      		mul r19,r24
 152 00d0 700D      		add r23,r0
 153 00d2 1124      		clr r1
 154 00d4 8827      		clr r24
 155 00d6 77FD      		sbrc r23,7
 156 00d8 8095      		com r24
 157 00da 982F      		mov r25,r24
 158 00dc 0E94 0000 		call __floatsisf
 159 00e0 C62E      		mov r12,r22
 160 00e2 172F      		mov r17,r23
 161 00e4 D82F      		mov r29,r24
 162 00e6 C92F      		mov r28,r25
 163               	.LVL0:
 106:velcounter.c  ****             if(stallTime > averagePeriod)
 164               		.loc 1 106 0
 165 00e8 9E01      		movw r18,r28
 166 00ea 862F      		mov r24,r22
 167               	.LVL1:
 168 00ec 912F      		mov r25,r17
 169               	.LVL2:
 170 00ee A32F      		mov r26,r19
 171 00f0 B22F      		mov r27,r18
 172 00f2 BC01      		movw r22,r24
 173 00f4 CD01      		movw r24,r26
 174               	.LVL3:
 175 00f6 2091 0000 		lds r18,averagePeriod
 176 00fa 3091 0000 		lds r19,averagePeriod+1
 177 00fe 4091 0000 		lds r20,averagePeriod+2
 178 0102 5091 0000 		lds r21,averagePeriod+3
 179 0106 0E94 0000 		call __gtsf2
 180               	.LVL4:
 181 010a 1816      		cp __zero_reg__,r24
 182 010c 04F4      		brge .L4
 107:velcounter.c  ****             {
 108:velcounter.c  ****                 averagePeriod = stallTime;
 183               		.loc 1 108 0
 184 010e 9E01      		movw r18,r28
 185 0110 8C2D      		mov r24,r12
 186 0112 912F      		mov r25,r17
 187 0114 A32F      		mov r26,r19
 188 0116 B22F      		mov r27,r18
 189               	.LVL5:
 190               	.L11:
 191 0118 8093 0000 		sts averagePeriod,r24
 192 011c 9093 0000 		sts averagePeriod+1,r25
 193 0120 A093 0000 		sts averagePeriod+2,r26
 194 0124 B093 0000 		sts averagePeriod+3,r27
 195               	.L4:
 196               	.LVL6:
 197               	.LBB4:
 198               	.LBB5:
  73:velcounter.c  ****     float rawRPM = 1 / (PERIOD_CONVERSION_CONSTANT*MOTOR_POLE_PAIRS*period);
 199               		.loc 1 73 0
 200 0128 6091 0000 		lds r22,averagePeriod
 201 012c 7091 0000 		lds r23,averagePeriod+1
 202 0130 8091 0000 		lds r24,averagePeriod+2
 203 0134 9091 0000 		lds r25,averagePeriod+3
 204 0138 25E9      		ldi r18,lo8(0x3656bf95)
 205 013a 3FEB      		ldi r19,hi8(0x3656bf95)
 206 013c 46E5      		ldi r20,hlo8(0x3656bf95)
 207 013e 56E3      		ldi r21,hhi8(0x3656bf95)
 208 0140 0E94 0000 		call __mulsf3
 209               	.LVL7:
 210 0144 9B01      		movw r18,r22
 211 0146 AC01      		movw r20,r24
 212 0148 60E0      		ldi r22,lo8(0x3f800000)
 213 014a 70E0      		ldi r23,hi8(0x3f800000)
 214 014c 80E8      		ldi r24,hlo8(0x3f800000)
 215 014e 9FE3      		ldi r25,hhi8(0x3f800000)
 216 0150 0E94 0000 		call __divsf3
 217 0154 162F      		mov r17,r22
 218 0156 D72F      		mov r29,r23
 219 0158 C82F      		mov r28,r24
 220 015a C92E      		mov r12,r25
 221               	.LVL8:
  74:velcounter.c  ****     if (rawRPM > 65535) return 65535;
 222               		.loc 1 74 0
 223 015c 862F      		mov r24,r22
 224               	.LVL9:
 225 015e 9D2F      		mov r25,r29
 226               	.LVL10:
 227 0160 AC2F      		mov r26,r28
 228 0162 BC2D      		mov r27,r12
 229 0164 BC01      		movw r22,r24
 230 0166 CD01      		movw r24,r26
 231               	.LVL11:
 232 0168 20E0      		ldi r18,lo8(0x477fff00)
 233 016a 3FEF      		ldi r19,hi8(0x477fff00)
 234 016c 4FE7      		ldi r20,hlo8(0x477fff00)
 235 016e 57E4      		ldi r21,hhi8(0x477fff00)
 236 0170 0E94 0000 		call __gtsf2
 237               	.LVL12:
 238 0174 1816      		cp __zero_reg__,r24
 239 0176 04F0      		brlt .L8
  75:velcounter.c  ****     if (rawRPM < 0) return 0;
 240               		.loc 1 75 0
 241 0178 812F      		mov r24,r17
 242 017a 9D2F      		mov r25,r29
 243 017c AC2F      		mov r26,r28
 244 017e BC2D      		mov r27,r12
 245 0180 BC01      		movw r22,r24
 246 0182 CD01      		movw r24,r26
 247 0184 20E0      		ldi r18,lo8(0x0)
 248 0186 30E0      		ldi r19,hi8(0x0)
 249 0188 A901      		movw r20,r18
 250 018a 0E94 0000 		call __ltsf2
 251 018e 87FD      		sbrc r24,7
 252 0190 00C0      		rjmp .L9
  76:velcounter.c  ****     return rawRPM;
 253               		.loc 1 76 0
 254 0192 812F      		mov r24,r17
 255 0194 9D2F      		mov r25,r29
 256 0196 AC2F      		mov r26,r28
 257 0198 BC2D      		mov r27,r12
 258 019a BC01      		movw r22,r24
 259 019c CD01      		movw r24,r26
 260 019e 0E94 0000 		call __fixunssfsi
 261 01a2 00C0      		rjmp .L7
 262               	.L8:
  74:velcounter.c  ****     if (rawRPM > 65535) return 65535;
 263               		.loc 1 74 0
 264 01a4 6FEF      		ldi r22,lo8(-1)
 265 01a6 7FEF      		ldi r23,hi8(-1)
 266 01a8 00C0      		rjmp .L7
 267               	.L9:
  75:velcounter.c  ****     if (rawRPM < 0) return 0;
 268               		.loc 1 75 0
 269 01aa 60E0      		ldi r22,lo8(0)
 270 01ac 70E0      		ldi r23,hi8(0)
 271               	.L7:
 272               	.LBE5:
 273               	.LBE4:
 109:velcounter.c  ****             }
 110:velcounter.c  ****         }
 111:velcounter.c  ****     }
 112:velcounter.c  ****     averageRPM = periodToRPM(averagePeriod);
 274               		.loc 1 112 0
 275 01ae 6093 0000 		sts averageRPM,r22
 276 01b2 7093 0000 		sts averageRPM+1,r23
 113:velcounter.c  **** /*    if(averageRPM[selectedMotor] >= maxRPM[selectedMotor])
 114:velcounter.c  ****     {
 115:velcounter.c  ****         overspeedCounter[selectedMotor]++;
 116:velcounter.c  ****         //The motor is being overdriven.  Increment the counter and be prepared for shutdown
 117:velcounter.c  ****         if(overspeedCounter[selectedMotor] > 5)
 118:velcounter.c  ****         {
 119:velcounter.c  ****             updateMotorDirection(selectedMotor,DIRECTION_STOP);
 120:velcounter.c  ****             updateMotorVoltage(0x00);
 121:velcounter.c  ****             overspeedCounter[selectedMotor] = 0;
 122:velcounter.c  ****         }
 123:velcounter.c  ****     } else {
 124:velcounter.c  ****         overspeedCounter[selectedMotor] = 0;
 125:velcounter.c  ****     }
 126:velcounter.c  **** */
 127:velcounter.c  ****     accumulationOverflow = 0;
 277               		.loc 1 127 0
 278 01b6 1092 0000 		sts accumulationOverflow,__zero_reg__
 128:velcounter.c  ****     periodAccumulator = 0;
 279               		.loc 1 128 0
 280 01ba 1092 0000 		sts periodAccumulator,__zero_reg__
 281 01be 1092 0000 		sts periodAccumulator+1,__zero_reg__
 129:velcounter.c  ****     samplesAccumulated = 0;
 282               		.loc 1 129 0
 283 01c2 1092 0000 		sts samplesAccumulated,__zero_reg__
 284               	/* epilogue start */
 130:velcounter.c  ****     return;
 131:velcounter.c  **** }
 285               		.loc 1 131 0
 286 01c6 DF91      		pop r29
 287               	.LVL13:
 288 01c8 CF91      		pop r28
 289 01ca 1F91      		pop r17
 290 01cc FF90      		pop r15
 291 01ce EF90      		pop r14
 292 01d0 DF90      		pop r13
 293 01d2 CF90      		pop r12
 294 01d4 0895      		ret
 295               		.cfi_endproc
 296               	.LFE4:
 298               	.global	configureMotorCounters
 300               	configureMotorCounters:
 301               	.LFB5:
 132:velcounter.c  **** 
 133:velcounter.c  **** /************************************************************************
 134:velcounter.c  **** * configureMotorCounter()
 135:velcounter.c  **** * This function configures a Timer/Counter to time the width of Hall sensor edges
 136:velcounter.c  **** * It makes heavy use of the event system to accurately time captures.  An
 137:velcounter.c  **** * interrupt tied to the key pins records the value captured before it is lost.
 138:velcounter.c  **** ************************************************************************/
 139:velcounter.c  **** void configureMotorCounters(void)
 140:velcounter.c  **** {
 302               		.loc 1 140 0
 303               		.cfi_startproc
 304               	/* prologue: function */
 305               	/* frame size = 0 */
 306               	/* stack size = 0 */
 307               	.L__stack_usage = 0
 141:velcounter.c  ****     //Configure the Event System to route the pin change signals for the Hall Effect sensors to the
 142:velcounter.c  **** 
 143:velcounter.c  ****     EVSYS.CH0MUX = EVENT_HALL_A1;
 308               		.loc 1 143 0
 309 01d6 E0E8      		ldi r30,lo8(384)
 310 01d8 F1E0      		ldi r31,hi8(384)
 311 01da 84E6      		ldi r24,lo8(100)
 312 01dc 8083      		st Z,r24
 144:velcounter.c  ****     EVSYS.CH1MUX = EVENT_HALL_B1;
 313               		.loc 1 144 0
 314 01de 85E6      		ldi r24,lo8(101)
 315 01e0 8183      		std Z+1,r24
 145:velcounter.c  ****     EVSYS.CH2MUX = EVENT_HALL_C1;
 316               		.loc 1 145 0
 317 01e2 86E6      		ldi r24,lo8(102)
 318 01e4 8283      		std Z+2,r24
 146:velcounter.c  **** 
 147:velcounter.c  ****     EVSYS.CH0CTRL = EVSYS_DIGFILT_1SAMPLE_gc;
 319               		.loc 1 147 0
 320 01e6 1086      		std Z+8,__zero_reg__
 148:velcounter.c  ****     EVSYS.CH1CTRL = EVSYS_DIGFILT_1SAMPLE_gc;
 321               		.loc 1 148 0
 322 01e8 1186      		std Z+9,__zero_reg__
 149:velcounter.c  ****     EVSYS.CH2CTRL = EVSYS_DIGFILT_1SAMPLE_gc;
 323               		.loc 1 149 0
 324 01ea 1286      		std Z+10,__zero_reg__
 150:velcounter.c  **** 
 151:velcounter.c  ****     //Now make the final timer/counter sensitive to these events
 152:velcounter.c  ****     //The counter should have a period of 500 ms for now using a prescaler of 256.
 153:velcounter.c  ****     //For the Maxon EC-20, this results in a minimum velocity of 5 RPM
 154:velcounter.c  ****     //24 transitions per revolution (6 transitions per electrical cycle and four cycles per revolut
 155:velcounter.c  ****     //Each transition at 500 ms yields 5 RPM.
 156:velcounter.c  ****     MOTOR1_EVENT_TIMER_TC.CTRLB = TC_WGMODE_NORMAL_gc | MOTOR1_HA_EN | MOTOR1_HB_EN | MOTOR1_HC_EN 
 325               		.loc 1 156 0
 326 01ec E0E0      		ldi r30,lo8(2560)
 327 01ee FAE0      		ldi r31,hi8(2560)
 328 01f0 80E7      		ldi r24,lo8(112)
 329 01f2 8183      		std Z+1,r24
 157:velcounter.c  ****     MOTOR1_EVENT_TIMER_TC.CTRLC = 0x00;
 330               		.loc 1 157 0
 331 01f4 1282      		std Z+2,__zero_reg__
 158:velcounter.c  ****     MOTOR1_EVENT_TIMER_TC.CTRLD = TC_EVACT_CAPT_gc | TC_EVSEL_CH0_gc;
 332               		.loc 1 158 0
 333 01f6 88E2      		ldi r24,lo8(40)
 334 01f8 8383      		std Z+3,r24
 159:velcounter.c  ****     MOTOR1_EVENT_TIMER_TC.CTRLE = 0x00;
 335               		.loc 1 159 0
 336 01fa 1482      		std Z+4,__zero_reg__
 160:velcounter.c  ****     MOTOR1_EVENT_TIMER_TC.PERBUF = 0xFFFF;
 337               		.loc 1 160 0
 338 01fc 8FEF      		ldi r24,lo8(-1)
 339 01fe 9FEF      		ldi r25,hi8(-1)
 340 0200 86AB      		std Z+54,r24
 341 0202 97AB      		std Z+55,r25
 161:velcounter.c  ****     MOTOR1_EVENT_TIMER_TC.CNT = 0x0000;
 342               		.loc 1 161 0
 343 0204 10A2      		std Z+32,__zero_reg__
 344 0206 11A2      		std Z+33,__zero_reg__
 162:velcounter.c  ****     MOTOR1_EVENT_TIMER_TC.CTRLA = TC_CLKSEL_DIV256_gc;
 345               		.loc 1 162 0
 346 0208 86E0      		ldi r24,lo8(6)
 347 020a 8083      		st Z,r24
 348               	/* epilogue start */
 163:velcounter.c  **** }
 349               		.loc 1 163 0
 350 020c 0895      		ret
 351               		.cfi_endproc
 352               	.LFE5:
 354               	.global	updateMotorCount
 356               	updateMotorCount:
 357               	.LFB6:
 164:velcounter.c  **** 
 165:velcounter.c  **** /************************************************************************
 166:velcounter.c  **** * updateMotorCount()
 167:velcounter.c  **** *
 168:velcounter.c  **** * Reads the velocity as a period.  It is called when
 169:velcounter.c  **** * a pin change interrupt fires on the Hall sensors.  At the same time, an
 170:velcounter.c  **** * event triggers a capture of the current state of the period counter to
 171:velcounter.c  **** * a timer register.  This routine picks out the appropriate capture register
 172:velcounter.c  **** * based on the interrupt flags.  It then subtracts the previously recorded
 173:velcounter.c  **** * absolute capture time to get a width of this Hall state in terms of counter
 174:velcounter.c  **** * pulses.  This value is accumulated with other measurements.  The accumulator
 175:velcounter.c  **** * is averaged and emptied by the PID tick.
 176:velcounter.c  **** ************************************************************************/
 177:velcounter.c  **** void updateMotorCount(void)
 178:velcounter.c  **** {
 358               		.loc 1 178 0
 359               		.cfi_startproc
 360               	/* prologue: function */
 361               	/* frame size = 0 */
 362               	/* stack size = 0 */
 363               	.L__stack_usage = 0
 364               	.LVL14:
 179:velcounter.c  ****     //Grab the most recent velocity measurement
 180:velcounter.c  **** 
 181:velcounter.c  ****     TC0_t *motorCounter;
 182:velcounter.c  ****     uint16_t sum;
 183:velcounter.c  **** 
 184:velcounter.c  ****     motorCounter = &MOTOR1_EVENT_TIMER_TC;
 185:velcounter.c  **** 
 186:velcounter.c  ****     uint8_t captureStatus = motorCounter->CTRLGSET & (TC0_CCABV_bm | TC0_CCBBV_bm | TC0_CCCBV_bm);
 365               		.loc 1 186 0
 366 020e E0E0      		ldi r30,lo8(2560)
 367 0210 FAE0      		ldi r31,hi8(2560)
 368 0212 8091 0B0A 		lds r24,2571
 369               	.LVL15:
 370 0216 8E70      		andi r24,lo8(14)
 371               	.LVL16:
 187:velcounter.c  ****     uint16_t currentCapture;
 188:velcounter.c  **** 
 189:velcounter.c  ****     switch(captureStatus)
 372               		.loc 1 189 0
 373 0218 8430      		cpi r24,lo8(4)
 374 021a 01F0      		breq .L16
 375 021c 8830      		cpi r24,lo8(8)
 376 021e 01F0      		breq .L17
 377 0220 8230      		cpi r24,lo8(2)
 378 0222 01F4      		brne .L22
 190:velcounter.c  ****     {
 191:velcounter.c  ****         case TC0_CCABV_bm:
 192:velcounter.c  ****             currentCapture = motorCounter->CCABUF;
 379               		.loc 1 192 0
 380 0224 8091 380A 		lds r24,2616
 381 0228 9091 390A 		lds r25,2616+1
 382               	.LVL17:
 193:velcounter.c  ****             break;
 383               		.loc 1 193 0
 384 022c 00C0      		rjmp .L18
 385               	.LVL18:
 386               	.L16:
 194:velcounter.c  ****         case TC0_CCBBV_bm:
 195:velcounter.c  ****             currentCapture = motorCounter->CCBBUF;
 387               		.loc 1 195 0
 388 022e 8091 3A0A 		lds r24,2618
 389 0232 9091 3B0A 		lds r25,2618+1
 390               	.LVL19:
 196:velcounter.c  ****             break;
 391               		.loc 1 196 0
 392 0236 00C0      		rjmp .L18
 393               	.LVL20:
 394               	.L17:
 197:velcounter.c  ****         case TC0_CCCBV_bm:
 198:velcounter.c  ****             currentCapture = motorCounter->CCCBUF;
 395               		.loc 1 198 0
 396 0238 8091 3C0A 		lds r24,2620
 397 023c 9091 3D0A 		lds r25,2620+1
 398               	.LVL21:
 199:velcounter.c  ****             break;
 399               		.loc 1 199 0
 400 0240 00C0      		rjmp .L18
 401               	.LVL22:
 402               	.L22:
 200:velcounter.c  ****         default:
 201:velcounter.c  ****             //Multiple or no captures.  Clear everything and hope for resynchronization next time a
 202:velcounter.c  ****             motorCounter->CTRLGCLR = TC0_CCABV_bm | TC0_CCBBV_bm | TC0_CCCBV_bm;
 403               		.loc 1 202 0
 404 0242 8EE0      		ldi r24,lo8(14)
 405               	.LVL23:
 406 0244 8287      		std Z+10,r24
 203:velcounter.c  **** 
 204:velcounter.c  ****             //Skip remaining processing and dump this sample
 205:velcounter.c  ****             motorCounter->CNT = 0x0000;
 407               		.loc 1 205 0
 408 0246 10A2      		std Z+32,__zero_reg__
 409 0248 11A2      		std Z+33,__zero_reg__
 206:velcounter.c  ****             previousAbsoluteCount = 0;
 410               		.loc 1 206 0
 411 024a 1092 0000 		sts previousAbsoluteCount,__zero_reg__
 412 024e 1092 0000 		sts previousAbsoluteCount+1,__zero_reg__
 207:velcounter.c  ****             return;
 413               		.loc 1 207 0
 414 0252 0895      		ret
 415               	.LVL24:
 416               	.L18:
 208:velcounter.c  ****     }
 209:velcounter.c  **** 
 210:velcounter.c  ****     //Simplify.  For now, just do the straight subtraction with no information about overflow.  Unl
 211:velcounter.c  ****     //moving very slowly, this will give the correct answer
 212:velcounter.c  ****     currentRelativeCount = currentCapture - previousAbsoluteCount;
 417               		.loc 1 212 0
 418 0254 2091 0000 		lds r18,previousAbsoluteCount
 419 0258 3091 0000 		lds r19,previousAbsoluteCount+1
 420 025c AC01      		movw r20,r24
 421 025e 421B      		sub r20,r18
 422 0260 530B      		sbc r21,r19
 423 0262 4093 0000 		sts currentRelativeCount,r20
 424 0266 5093 0000 		sts currentRelativeCount+1,r21
 213:velcounter.c  ****     previousAbsoluteCount = currentCapture;
 425               		.loc 1 213 0
 426 026a 8093 0000 		sts previousAbsoluteCount,r24
 427 026e 9093 0000 		sts previousAbsoluteCount+1,r25
 214:velcounter.c  **** 
 215:velcounter.c  ****     //Accumulate
 216:velcounter.c  ****     sum = periodAccumulator + currentRelativeCount;
 428               		.loc 1 216 0
 429 0272 2091 0000 		lds r18,periodAccumulator
 430 0276 3091 0000 		lds r19,periodAccumulator+1
 431 027a 8091 0000 		lds r24,currentRelativeCount
 432 027e 9091 0000 		lds r25,currentRelativeCount+1
 433               	.LVL25:
 217:velcounter.c  ****     if((samplesAccumulated == 255) || \
 434               		.loc 1 217 0
 435 0282 4091 0000 		lds r20,samplesAccumulated
 436 0286 4F3F      		cpi r20,lo8(-1)
 437 0288 01F0      		breq .L20
 216:velcounter.c  ****     sum = periodAccumulator + currentRelativeCount;
 438               		.loc 1 216 0 discriminator 1
 439 028a 820F      		add r24,r18
 440 028c 931F      		adc r25,r19
 441               	.LVL26:
 218:velcounter.c  ****        (sum < periodAccumulator))
 442               		.loc 1 218 0 discriminator 1
 443 028e 2091 0000 		lds r18,periodAccumulator
 444 0292 3091 0000 		lds r19,periodAccumulator+1
 217:velcounter.c  ****     if((samplesAccumulated == 255) || \
 445               		.loc 1 217 0 discriminator 1
 446 0296 8217      		cp r24,r18
 447 0298 9307      		cpc r25,r19
 448 029a 00F4      		brsh .L21
 449               	.LVL27:
 450               	.L20:
 219:velcounter.c  ****     {
 220:velcounter.c  ****         //Overflow error
 221:velcounter.c  ****         accumulationOverflow = 1;
 451               		.loc 1 221 0
 452 029c 81E0      		ldi r24,lo8(1)
 453 029e 8093 0000 		sts accumulationOverflow,r24
 222:velcounter.c  ****         periodAccumulator = 0;
 454               		.loc 1 222 0
 455 02a2 1092 0000 		sts periodAccumulator,__zero_reg__
 456 02a6 1092 0000 		sts periodAccumulator+1,__zero_reg__
 223:velcounter.c  ****         samplesAccumulated = 0;
 457               		.loc 1 223 0
 458 02aa 1092 0000 		sts samplesAccumulated,__zero_reg__
 459 02ae 0895      		ret
 460               	.LVL28:
 461               	.L21:
 224:velcounter.c  ****     } else {
 225:velcounter.c  ****         periodAccumulator = sum;
 462               		.loc 1 225 0
 463 02b0 8093 0000 		sts periodAccumulator,r24
 464 02b4 9093 0000 		sts periodAccumulator+1,r25
 226:velcounter.c  ****         samplesAccumulated++;
 465               		.loc 1 226 0
 466 02b8 8091 0000 		lds r24,samplesAccumulated
 467               	.LVL29:
 468 02bc 8F5F      		subi r24,lo8(-(1))
 469 02be 8093 0000 		sts samplesAccumulated,r24
 470 02c2 0895      		ret
 471               		.cfi_endproc
 472               	.LFE6:
 474               		.lcomm stallCounter,1
 475               		.lcomm previousAbsoluteCount,2
 476               		.lcomm accumulationOverflow,1
 477               		.lcomm samplesAccumulated,1
 478               		.lcomm periodAccumulator,2
 479               	.global	averageRPM
 480               	.global	averageRPM
 481               		.section .bss
 484               	averageRPM:
 485 0000 0000      		.skip 2,0
 486               	.global	averagePeriod
 487               		.data
 490               	averagePeriod:
 491 0000 00        		.byte	0
 492 0001 FE        		.byte	-2
 493 0002 7F        		.byte	127
 494 0003 47        		.byte	71
 495               	.global	currentRelativeCount
 496               	.global	currentRelativeCount
 497               		.section .bss
 500               	currentRelativeCount:
 501 0002 0000      		.skip 2,0
 502               		.text
 503               	.Letext0:
 504               		.file 2 "/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../av
 505               		.file 3 "/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../av
 506               		.file 4 "velcounter.h"
DEFINED SYMBOLS
                            *ABS*:00000000 velcounter.c
     /tmp/ccpd4I99.s:2      *ABS*:0000003f __SREG__
     /tmp/ccpd4I99.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccpd4I99.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccpd4I99.s:5      *ABS*:00000034 __CCP__
     /tmp/ccpd4I99.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccpd4I99.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccpd4I99.s:15     .text:00000000 resetVelocityCounter
     /tmp/ccpd4I99.s:475    .bss:00000007 accumulationOverflow
     /tmp/ccpd4I99.s:477    .bss:00000009 periodAccumulator
     /tmp/ccpd4I99.s:476    .bss:00000008 samplesAccumulated
     /tmp/ccpd4I99.s:490    .data:00000000 averagePeriod
     /tmp/ccpd4I99.s:484    .bss:00000000 averageRPM
                             .bss:00000004 stallCounter
     /tmp/ccpd4I99.s:53     .text:00000036 readVelocitySignal
     /tmp/ccpd4I99.s:300    .text:000001d6 configureMotorCounters
     /tmp/ccpd4I99.s:356    .text:0000020e updateMotorCount
     /tmp/ccpd4I99.s:474    .bss:00000005 previousAbsoluteCount
     /tmp/ccpd4I99.s:500    .bss:00000002 currentRelativeCount

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__floatunsisf
__divsf3
__floatsisf
__gtsf2
__mulsf3
__ltsf2
__fixunssfsi
