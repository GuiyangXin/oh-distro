   1               		.file	"thermalModel.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  14               	updateTemperatureEsimate:
  15               	.LFB7:
  16               		.file 1 "thermalModel.c"
   1:thermalModel.c **** /****************************************************
   2:thermalModel.c **** 
   3:thermalModel.c ****  // Author:            Paul Butler
   4:thermalModel.c ****  // File Name:        C1482-SRC-FGRMCU-0-thermalModel.c
   5:thermalModel.c ****  // Creation Date:    22 November, 2011
   6:thermalModel.c ****  // Revision:        02
   7:thermalModel.c ****  // Hardware:        ATxmega32A4
   8:thermalModel.c ****  // Description:    Palm Motor Controller Micro BLDC Thermal Model
   9:thermalModel.c **** 
  10:thermalModel.c **** ****************************************************/
  11:thermalModel.c **** 
  12:thermalModel.c **** /******************************************************************************
  13:thermalModel.c ****     File Revision History:
  14:thermalModel.c **** -------------------------------------------------------------------------------
  15:thermalModel.c **** Revision    Date        Engineer    Description
  16:thermalModel.c **** --------    --------    --------    -------------------------------------------
  17:thermalModel.c **** 00            11/22/11    PDB            Initial Release
  18:thermalModel.c **** 01            12/16/11    ZAC            Update to add Velocity override for thermal control
  19:thermalModel.c **** 02            1/5/12        ZAC            Added slack around velocity override
  20:thermalModel.c **** -------------------------------------------------------------------------------
  21:thermalModel.c **** 
  22:thermalModel.c **** ******************************************************************************/
  23:thermalModel.c **** 
  24:thermalModel.c **** #include <math.h>
  25:thermalModel.c **** #include "thermalModel.h"
  26:thermalModel.c **** #include "PIDcontroller.h"
  27:thermalModel.c **** #include "currentADC.h"
  28:thermalModel.c **** #include "velcounter.h"
  29:thermalModel.c **** 
  30:thermalModel.c **** float oldDeltaT = 0.0;
  31:thermalModel.c **** float realWindingResistance = DEFAULT_WINDING_RESISTANCE;
  32:thermalModel.c **** 
  33:thermalModel.c **** 
  34:thermalModel.c **** //Private functions
  35:thermalModel.c **** static float updateTemperatureEsimate(float newTemp, float newCurrent);
  36:thermalModel.c **** static uint8_t isValidOverride(uint16_t setpoint, PID_SCHEME_t scheme);
  37:thermalModel.c **** 
  38:thermalModel.c **** typedef enum
  39:thermalModel.c **** {
  40:thermalModel.c ****     NORMAL_OPERATION,
  41:thermalModel.c ****     THERMAL_OVERLOAD,
  42:thermalModel.c ****     THERMAL_WARNING,
  43:thermalModel.c ****     NORMAL_COOLDOWN,
  44:thermalModel.c ****     MANDATORY_COOLDOWN,
  45:thermalModel.c ****     STOPPED,
  46:thermalModel.c ****     THERMAL_OVERLOAD_OVERRIDE
  47:thermalModel.c **** } protection_state_t;
  48:thermalModel.c **** 
  49:thermalModel.c **** //Private variables
  50:thermalModel.c **** 
  51:thermalModel.c **** static protection_state_t protectionState = MANDATORY_COOLDOWN;
  52:thermalModel.c **** static float cooldownTimeRemaining = 0;
  53:thermalModel.c **** 
  54:thermalModel.c **** 
  55:thermalModel.c **** 
  56:thermalModel.c **** /************************************************************************
  57:thermalModel.c **** * thermalCheckSetpoint(newScheme,newSetpoint)
  58:thermalModel.c **** *
  59:thermalModel.c **** * Called when a command arrives.  It updates state if appropriate and
  60:thermalModel.c **** * tells the caller whether to accept the setpoint.
  61:thermalModel.c **** *
  62:thermalModel.c **** * At present it does not need to look at the actual new setpoint because its
  63:thermalModel.c **** * decision is entirely based on state.  The state machine itself operates
  64:thermalModel.c **** * on the setpoint and will decide what to do.
  65:thermalModel.c **** *
  66:thermalModel.c **** * return THERMAL_DISCARD for delete entirely
  67:thermalModel.c **** * return THERMAL_DELAY for apply later
  68:thermalModel.c **** * return THERMAL_OK for OK
  69:thermalModel.c **** ************************************************************************/
  70:thermalModel.c **** int thermalCheckSetpoint(PID_SCHEME_t newScheme, int newSetpoint)
  71:thermalModel.c **** {
  72:thermalModel.c ****     switch(protectionState)
  73:thermalModel.c ****     {
  74:thermalModel.c ****         case NORMAL_OPERATION: //Fallthrough intentional
  75:thermalModel.c ****         case NORMAL_COOLDOWN:  //Fallthrough intentional
  76:thermalModel.c ****         case STOPPED:
  77:thermalModel.c ****             //Any command is OK
  78:thermalModel.c ****             return THERMAL_OK;
  79:thermalModel.c ****         case THERMAL_WARNING:
  80:thermalModel.c ****             //This forces us out of thermal warning mode unconditionally
  81:thermalModel.c ****             //Any command is OK
  82:thermalModel.c ****             protectionState = NORMAL_OPERATION;
  83:thermalModel.c ****             return THERMAL_OK;
  84:thermalModel.c ****         case MANDATORY_COOLDOWN:
  85:thermalModel.c ****             //No command is valid.  In addition, do not store the command for application after coo
  86:thermalModel.c ****             return THERMAL_DISCARD;
  87:thermalModel.c ****         case THERMAL_OVERLOAD:
  88:thermalModel.c ****             if(isValidOverride(newSetpoint, newScheme) == 1)
  89:thermalModel.c ****             {
  90:thermalModel.c ****                 //The is a valid override
  91:thermalModel.c ****                 protectionState = THERMAL_OVERLOAD_OVERRIDE;
  92:thermalModel.c ****                 return THERMAL_OK;
  93:thermalModel.c ****             } else {
  94:thermalModel.c ****                 //Delay application.
  95:thermalModel.c ****                 return THERMAL_DELAY;
  96:thermalModel.c ****             }
  97:thermalModel.c ****         case THERMAL_OVERLOAD_OVERRIDE:
  98:thermalModel.c ****             if((statorTemperature + oldDeltaT) < Parameter[PARAMETER_T_PLUS])
  99:thermalModel.c ****             {
 100:thermalModel.c ****                 protectionState = NORMAL_OPERATION;
 101:thermalModel.c ****                 return THERMAL_OK;
 102:thermalModel.c ****             } else if(isValidOverride(newSetpoint, newScheme) == 1)
 103:thermalModel.c ****             {
 104:thermalModel.c ****                 //The motor is still in a valid override, so apply immediately
 105:thermalModel.c ****                 return THERMAL_OK;
 106:thermalModel.c ****             } else {
 107:thermalModel.c ****                 //Not a valid override.  Go back to normal OVERLOAD and delay
 108:thermalModel.c ****                 protectionState = THERMAL_OVERLOAD;
 109:thermalModel.c ****                 PIDPreset(CONTROL_SCHEME_POWER);
 110:thermalModel.c ****                 return THERMAL_DELAY;
 111:thermalModel.c ****             }
 112:thermalModel.c ****         default:
 113:thermalModel.c ****             return THERMAL_DISCARD;
 114:thermalModel.c ****     }
 115:thermalModel.c **** }
 116:thermalModel.c **** /************************************************************************
 117:thermalModel.c **** * getWindingResistance()
 118:thermalModel.c **** *
 119:thermalModel.c **** * Returns the current winding resistance estimate
 120:thermalModel.c **** ************************************************************************/
 121:thermalModel.c **** float getWindingResistance(void)
 122:thermalModel.c **** {
 123:thermalModel.c ****     return realWindingResistance;
 124:thermalModel.c **** }
 125:thermalModel.c **** 
 126:thermalModel.c **** /************************************************************************
 127:thermalModel.c **** * getPowerSetpoint()
 128:thermalModel.c **** *
 129:thermalModel.c **** * Returns the power setpoint appropriate for the motor if in THERMAL_OVERLOAD
 130:thermalModel.c **** * Will return a negative number if power should not be used.
 131:thermalModel.c **** ************************************************************************/
 132:thermalModel.c **** float getPowerSetpoint(void)
 133:thermalModel.c **** {
 134:thermalModel.c ****     float powerSetpoint;
 135:thermalModel.c ****     float maximumDeltaD;
 136:thermalModel.c ****     if((protectionState == THERMAL_OVERLOAD) || \
 137:thermalModel.c ****        (protectionState == THERMAL_WARNING)) {
 138:thermalModel.c ****         maximumDeltaD = Parameter[PARAMETER_T_TARGET] - statorTemperature;
 139:thermalModel.c ****        powerSetpoint = maximumDeltaD / Parameter[PARAMETER_THERMAL_R];
 140:thermalModel.c ****        if (powerSetpoint < 0)
 141:thermalModel.c ****        {
 142:thermalModel.c ****            return 0.0;
 143:thermalModel.c ****        } else {
 144:thermalModel.c ****            return powerSetpoint;
 145:thermalModel.c ****        }
 146:thermalModel.c ****     } else {
 147:thermalModel.c ****        return -1.0;
 148:thermalModel.c ****     }
 149:thermalModel.c **** }
 150:thermalModel.c **** 
 151:thermalModel.c **** /************************************************************************
 152:thermalModel.c **** * isValidOverride( uint16_t setpoint, PID_SCHEME_t scheme)
 153:thermalModel.c **** * returns 1 if the configured setpoint is less than the power limit
 154:thermalModel.c **** * 0 otherwise.
 155:thermalModel.c **** ************************************************************************/
 156:thermalModel.c **** static uint8_t isValidOverride(uint16_t setpoint, PID_SCHEME_t scheme)
 157:thermalModel.c **** {
 158:thermalModel.c ****     float maximumCurrent;
 159:thermalModel.c ****     float maximumDeltaT;
 160:thermalModel.c ****     if(scheme == CONTROL_SCHEME_CURRENT)
 161:thermalModel.c ****     {
 162:thermalModel.c ****         //The maximum current is backed out from the power that would would hit tTarget
 163:thermalModel.c ****         maximumDeltaT = Parameter[PARAMETER_T_TARGET] - statorTemperature;
 164:thermalModel.c ****         maximumCurrent = sqrt(maximumDeltaT / \
 165:thermalModel.c ****                       (Parameter[PARAMETER_THERMAL_R] * realWindingResistance));
 166:thermalModel.c ****         //Setpoint is in milliamperes.
 167:thermalModel.c ****         if(setpoint < maximumCurrent * 1000)
 168:thermalModel.c ****         {
 169:thermalModel.c ****             return 1;
 170:thermalModel.c ****         }
 171:thermalModel.c ****     }
 172:thermalModel.c ****     if(scheme == CONTROL_SCHEME_VELOCITY)
 173:thermalModel.c ****     {
 174:thermalModel.c ****         //For velocity control to take over, it must be asking for less speed out of the motor whil
 175:thermalModel.c ****         //In that case, the velocity controller is definitely the lighter load.
 176:thermalModel.c **** 
 177:thermalModel.c ****         //If the power controller is trying to pull power down, let it have control unconditionally
 178:thermalModel.c ****         //wants less speed, let it take over at that point.  In this way the power controller ceili
 179:thermalModel.c ****         //velocity controller wants to go lower.  Some margin is applied to the power controller ce
 180:thermalModel.c ****         //run steady state at a low velocity setpoint that is heavily loaded.  If this condition is
 181:thermalModel.c ****         //Tmax.
 182:thermalModel.c **** 
 183:thermalModel.c ****         //The maximum current is backed out from the power that would would hit tTarget
 184:thermalModel.c ****         maximumDeltaT = Parameter[PARAMETER_T_TARGET] - statorTemperature;
 185:thermalModel.c ****         maximumCurrent = sqrt(maximumDeltaT / \
 186:thermalModel.c ****                       (Parameter[PARAMETER_THERMAL_R] * realWindingResistance));
 187:thermalModel.c **** 
 188:thermalModel.c **** 
 189:thermalModel.c ****         if((motorCurrent <= (maximumCurrent * 1.25)) && (averageRPM >= setpoint))
 190:thermalModel.c ****         {
 191:thermalModel.c ****             return 1;
 192:thermalModel.c ****         }
 193:thermalModel.c ****         return 0;
 194:thermalModel.c ****     }
 195:thermalModel.c ****     return 0;
 196:thermalModel.c **** }
 197:thermalModel.c **** 
 198:thermalModel.c **** /************************************************************************
 199:thermalModel.c **** * updateThermalModel(newTemp,newCurrent)
 200:thermalModel.c **** *
 201:thermalModel.c **** * Updates the running temperature estimate and updates a thermal state
 202:thermalModel.c **** * variable.  This state can override the PID controller with a power
 203:thermalModel.c **** * limiting mode of operation
 204:thermalModel.c **** ************************************************************************/
 205:thermalModel.c **** 
 206:thermalModel.c **** void updateThermalModel(float newTemp, float newCurrent)
 207:thermalModel.c **** {
 208:thermalModel.c ****     float estimatedWindingTemperature;
 209:thermalModel.c ****     switch(protectionState)
 210:thermalModel.c ****     {
 211:thermalModel.c ****         case MANDATORY_COOLDOWN:
 212:thermalModel.c ****             //It is startup or an over-temperature condition. Decrement the cooldown timer until th
 213:thermalModel.c ****             updateTemperatureEsimate(newTemp, newCurrent);
 214:thermalModel.c ****             if(cooldownTimeRemaining > 0)
 215:thermalModel.c ****             {
 216:thermalModel.c ****                 cooldownTimeRemaining = cooldownTimeRemaining - CONTROL_LOOP_PERIOD_MS;
 217:thermalModel.c ****             } else {
 218:thermalModel.c ****                 //Cooldown done.  Go to stopped
 219:thermalModel.c ****                 oldDeltaT = 0.0;
 220:thermalModel.c ****                 protectionState = STOPPED;
 221:thermalModel.c ****             }
 222:thermalModel.c ****             break;
 223:thermalModel.c ****         case NORMAL_COOLDOWN:
 224:thermalModel.c ****             //The motor has been stopped and is cooling down.  Decrement the counter unless it has 
 225:thermalModel.c ****             updateTemperatureEsimate(newTemp, newCurrent);
 226:thermalModel.c ****             if(cooldownTimeRemaining <= 0)
 227:thermalModel.c ****             {
 228:thermalModel.c ****                 //Cooldown complete.  Force temperature to zero
 229:thermalModel.c ****                 oldDeltaT = 0.0;
 230:thermalModel.c ****                 protectionState = STOPPED;
 231:thermalModel.c ****             } else if(getMotorDirection() == DIRECTION_STOP)
 232:thermalModel.c ****             {
 233:thermalModel.c ****                 cooldownTimeRemaining = cooldownTimeRemaining - CONTROL_LOOP_PERIOD_MS;
 234:thermalModel.c ****             } else {
 235:thermalModel.c ****                 //No longer cooling down.
 236:thermalModel.c ****                 protectionState = NORMAL_OPERATION;
 237:thermalModel.c ****             }
 238:thermalModel.c ****             break;
 239:thermalModel.c ****         case NORMAL_OPERATION:
 240:thermalModel.c ****             //Check for over temperature or cooldown conditions
 241:thermalModel.c ****             estimatedWindingTemperature = updateTemperatureEsimate(newTemp, newCurrent);
 242:thermalModel.c ****             if(getMotorDirection() == DIRECTION_STOP)
 243:thermalModel.c ****             {
 244:thermalModel.c ****                 //Begin cooldown
 245:thermalModel.c ****                 protectionState = NORMAL_COOLDOWN;
 246:thermalModel.c ****                 cooldownTimeRemaining = Parameter[PARAMETER_OFF_TIME] * Parameter[PARAMETER_WINDING
 247:thermalModel.c ****             } else if(estimatedWindingTemperature >= Parameter[PARAMETER_T_MAX])
 248:thermalModel.c ****             {
 249:thermalModel.c ****                 protectionState = MANDATORY_COOLDOWN;
 250:thermalModel.c ****                 cooldownTimeRemaining = Parameter[PARAMETER_OFF_TIME] * Parameter[PARAMETER_WINDING
 251:thermalModel.c ****                 updateMotorDirection(DIRECTION_STOP);
 252:thermalModel.c ****             } else if(estimatedWindingTemperature >= Parameter[PARAMETER_T_PLUS])
 253:thermalModel.c ****             {
 254:thermalModel.c ****                 //Switch to overload mode.  PID loop will catch it
 255:thermalModel.c ****                 protectionState = THERMAL_OVERLOAD;
 256:thermalModel.c ****                 PIDPreset(CONTROL_SCHEME_POWER);
 257:thermalModel.c ****             }
 258:thermalModel.c ****             break;
 259:thermalModel.c ****         case THERMAL_OVERLOAD:
 260:thermalModel.c ****             //Check for a low enough temperature to exit overload or stopped operation
 261:thermalModel.c ****             estimatedWindingTemperature = updateTemperatureEsimate(newTemp, newCurrent);
 262:thermalModel.c ****             if(getMotorDirection() == DIRECTION_STOP)
 263:thermalModel.c ****             {
 264:thermalModel.c ****                 //Begin cooldown
 265:thermalModel.c ****                 protectionState = NORMAL_COOLDOWN;
 266:thermalModel.c ****                 cooldownTimeRemaining = Parameter[PARAMETER_OFF_TIME] * Parameter[PARAMETER_WINDING
 267:thermalModel.c ****             } else if(estimatedWindingTemperature >= Parameter[PARAMETER_T_MAX])
 268:thermalModel.c ****             {
 269:thermalModel.c ****                 protectionState = MANDATORY_COOLDOWN;
 270:thermalModel.c ****                 cooldownTimeRemaining = Parameter[PARAMETER_OFF_TIME] * Parameter[PARAMETER_WINDING
 271:thermalModel.c ****                 updateMotorDirection(DIRECTION_STOP);
 272:thermalModel.c ****             } else if(estimatedWindingTemperature < Parameter[PARAMETER_T_PLUS])
 273:thermalModel.c ****             {
 274:thermalModel.c ****                 //Switch to warning mode.  PID loop will catch it
 275:thermalModel.c ****                 protectionState = THERMAL_WARNING;
 276:thermalModel.c ****             } else if(isValidOverride(PID_state.setpoint,PID_state.controlScheme) == 1)
 277:thermalModel.c ****             {
 278:thermalModel.c ****                 //The setpoint is appropriate for OVERRIDE
 279:thermalModel.c ****                 //Preset the PID
 280:thermalModel.c ****                 PIDPreset(PID_state.controlScheme);
 281:thermalModel.c ****                 protectionState = THERMAL_OVERLOAD_OVERRIDE;
 282:thermalModel.c ****             }
 283:thermalModel.c ****             break;
 284:thermalModel.c ****         case THERMAL_OVERLOAD_OVERRIDE:
 285:thermalModel.c ****             //Check for a low enough temperature to exit overload or stopped operation
 286:thermalModel.c ****             estimatedWindingTemperature = updateTemperatureEsimate(newTemp, newCurrent);
 287:thermalModel.c ****             if(getMotorDirection() == DIRECTION_STOP)
 288:thermalModel.c ****             {
 289:thermalModel.c ****                 //Begin cooldown
 290:thermalModel.c ****                 protectionState = NORMAL_COOLDOWN;
 291:thermalModel.c ****                 cooldownTimeRemaining = Parameter[PARAMETER_OFF_TIME] * Parameter[PARAMETER_WINDING
 292:thermalModel.c ****             } else if(estimatedWindingTemperature >= Parameter[PARAMETER_T_MAX])
 293:thermalModel.c ****             {
 294:thermalModel.c ****                 protectionState = MANDATORY_COOLDOWN;
 295:thermalModel.c ****                 cooldownTimeRemaining = Parameter[PARAMETER_OFF_TIME] * Parameter[PARAMETER_WINDING
 296:thermalModel.c ****                 updateMotorDirection(DIRECTION_STOP);
 297:thermalModel.c ****             } else if(estimatedWindingTemperature < Parameter[PARAMETER_T_MINUS])
 298:thermalModel.c ****             {
 299:thermalModel.c ****                 //Switch to normal mode.  PID loop will catch it
 300:thermalModel.c ****                 protectionState = NORMAL_OPERATION;
 301:thermalModel.c ****                 PIDPreset(PID_state.controlScheme);
 302:thermalModel.c ****             } else if(isValidOverride(PID_state.setpoint,PID_state.controlScheme) == 0)
 303:thermalModel.c ****             {
 304:thermalModel.c ****                 //The setpoint is not appropriate for OVERRIDE.  Go back to OVERLOAD
 305:thermalModel.c ****                 protectionState = THERMAL_OVERLOAD;
 306:thermalModel.c ****                 PIDPreset(CONTROL_SCHEME_POWER);
 307:thermalModel.c ****             }
 308:thermalModel.c ****             break;
 309:thermalModel.c ****         case THERMAL_WARNING:
 310:thermalModel.c ****             //Check for entrance into overload or warning
 311:thermalModel.c ****             estimatedWindingTemperature = updateTemperatureEsimate(newTemp, newCurrent);
 312:thermalModel.c ****             if(getMotorDirection() == DIRECTION_STOP)
 313:thermalModel.c ****             {
 314:thermalModel.c ****                 //Begin cooldown
 315:thermalModel.c ****                 protectionState = NORMAL_COOLDOWN;
 316:thermalModel.c ****                 cooldownTimeRemaining = Parameter[PARAMETER_OFF_TIME] * Parameter[PARAMETER_WINDING
 317:thermalModel.c ****             } else if(estimatedWindingTemperature >= Parameter[PARAMETER_T_MAX])
 318:thermalModel.c ****             {
 319:thermalModel.c ****                 protectionState = MANDATORY_COOLDOWN;
 320:thermalModel.c ****                 cooldownTimeRemaining = Parameter[PARAMETER_OFF_TIME] * Parameter[PARAMETER_WINDING
 321:thermalModel.c ****                 updateMotorDirection(DIRECTION_STOP);
 322:thermalModel.c ****             } else if(estimatedWindingTemperature >= Parameter[PARAMETER_T_PLUS])
 323:thermalModel.c ****             {
 324:thermalModel.c ****                 //Switch to overload mode.  No need to preset because was already in power control
 325:thermalModel.c ****                 protectionState = THERMAL_OVERLOAD;
 326:thermalModel.c ****             } else if(estimatedWindingTemperature < Parameter[PARAMETER_T_MINUS])
 327:thermalModel.c ****             {
 328:thermalModel.c ****                 //Full exit from thermal control
 329:thermalModel.c ****                 protectionState = NORMAL_OPERATION;
 330:thermalModel.c ****                 PIDPreset(PID_state.controlScheme);
 331:thermalModel.c ****             }
 332:thermalModel.c ****             break;
 333:thermalModel.c ****         case STOPPED:
 334:thermalModel.c ****             //Do not update the temperature with the exponential.
 335:thermalModel.c ****             if(getMotorDirection() != DIRECTION_STOP)
 336:thermalModel.c ****             {
 337:thermalModel.c ****                 //Motor has started
 338:thermalModel.c ****                 protectionState = NORMAL_OPERATION;
 339:thermalModel.c ****             }
 340:thermalModel.c ****             break;
 341:thermalModel.c ****         default:
 342:thermalModel.c ****             break;
 343:thermalModel.c ****     }
 344:thermalModel.c ****     return;
 345:thermalModel.c **** }
 346:thermalModel.c **** 
 347:thermalModel.c **** /************************************************************************
 348:thermalModel.c **** * updateTemperatureEstimate(newTemp,newCurrent)
 349:thermalModel.c **** *
 350:thermalModel.c **** * Updates the system estimate of winding temperature
 351:thermalModel.c **** * newTemp is the new stator temperature in degrees Celsius, and newCurrent is
 352:thermalModel.c **** * the new motor current in Amperes
 353:thermalModel.c **** ************************************************************************/
 354:thermalModel.c **** static float updateTemperatureEsimate(float newTemp, float newCurrent)
 355:thermalModel.c **** {
  17               		.loc 1 355 0
  18               		.cfi_startproc
  19               	.LVL0:
  20 0000 4F92      		push r4
  21               	.LCFI0:
  22               		.cfi_def_cfa_offset 3
  23               		.cfi_offset 4, -2
  24 0002 5F92      		push r5
  25               	.LCFI1:
  26               		.cfi_def_cfa_offset 4
  27               		.cfi_offset 5, -3
  28 0004 6F92      		push r6
  29               	.LCFI2:
  30               		.cfi_def_cfa_offset 5
  31               		.cfi_offset 6, -4
  32 0006 7F92      		push r7
  33               	.LCFI3:
  34               		.cfi_def_cfa_offset 6
  35               		.cfi_offset 7, -5
  36 0008 8F92      		push r8
  37               	.LCFI4:
  38               		.cfi_def_cfa_offset 7
  39               		.cfi_offset 8, -6
  40 000a 9F92      		push r9
  41               	.LCFI5:
  42               		.cfi_def_cfa_offset 8
  43               		.cfi_offset 9, -7
  44 000c AF92      		push r10
  45               	.LCFI6:
  46               		.cfi_def_cfa_offset 9
  47               		.cfi_offset 10, -8
  48 000e BF92      		push r11
  49               	.LCFI7:
  50               		.cfi_def_cfa_offset 10
  51               		.cfi_offset 11, -9
  52 0010 CF92      		push r12
  53               	.LCFI8:
  54               		.cfi_def_cfa_offset 11
  55               		.cfi_offset 12, -10
  56 0012 DF92      		push r13
  57               	.LCFI9:
  58               		.cfi_def_cfa_offset 12
  59               		.cfi_offset 13, -11
  60 0014 EF92      		push r14
  61               	.LCFI10:
  62               		.cfi_def_cfa_offset 13
  63               		.cfi_offset 14, -12
  64 0016 FF92      		push r15
  65               	.LCFI11:
  66               		.cfi_def_cfa_offset 14
  67               		.cfi_offset 15, -13
  68 0018 0F93      		push r16
  69               	.LCFI12:
  70               		.cfi_def_cfa_offset 15
  71               		.cfi_offset 16, -14
  72 001a 1F93      		push r17
  73               	.LCFI13:
  74               		.cfi_def_cfa_offset 16
  75               		.cfi_offset 17, -15
  76 001c CF93      		push r28
  77               	.LCFI14:
  78               		.cfi_def_cfa_offset 17
  79               		.cfi_offset 28, -16
  80 001e DF93      		push r29
  81               	.LCFI15:
  82               		.cfi_def_cfa_offset 18
  83               		.cfi_offset 29, -17
  84               	/* prologue: function */
  85               	/* frame size = 0 */
  86               	/* stack size = 16 */
  87               	.L__stack_usage = 16
  88 0020 2B01      		movw r4,r22
  89 0022 3C01      		movw r6,r24
  90 0024 6901      		movw r12,r18
  91 0026 7A01      		movw r14,r20
 356:thermalModel.c ****     float oldWindingTemperature;
 357:thermalModel.c ****     float powerSupplied;
 358:thermalModel.c ****     float deltaTFinal;
 359:thermalModel.c **** 
 360:thermalModel.c ****     //First compute the updated temperature assuming the old deltaT with the new
 361:thermalModel.c ****     //armature reading
 362:thermalModel.c ****     oldWindingTemperature = newTemp + oldDeltaT;
  92               		.loc 1 362 0
  93 0028 8090 0000 		lds r8,oldDeltaT
  94 002c 9090 0000 		lds r9,oldDeltaT+1
  95 0030 A090 0000 		lds r10,oldDeltaT+2
  96 0034 B090 0000 		lds r11,oldDeltaT+3
  97               	.LVL1:
  98 0038 A501      		movw r20,r10
  99 003a 9401      		movw r18,r8
 100               	.LVL2:
 101 003c 0E94 0000 		call __addsf3
 102               	.LVL3:
 363:thermalModel.c **** 
 364:thermalModel.c ****     //Compute winding electrical resistance taking the temperature reading into account
 365:thermalModel.c ****     realWindingResistance = Parameter[PARAMETER_WINDING_R]*(1 + Parameter[PARAMETER_CU_ALPHA]*(oldW
 103               		.loc 1 365 0
 104 0040 20E0      		ldi r18,lo8(0x41c80000)
 105 0042 30E0      		ldi r19,hi8(0x41c80000)
 106 0044 48EC      		ldi r20,hlo8(0x41c80000)
 107 0046 51E4      		ldi r21,hhi8(0x41c80000)
 108 0048 0E94 0000 		call __subsf3
 109 004c 2091 0000 		lds r18,Parameter+60
 110 0050 3091 0000 		lds r19,Parameter+60+1
 111 0054 4091 0000 		lds r20,Parameter+60+2
 112 0058 5091 0000 		lds r21,Parameter+60+3
 113 005c 0E94 0000 		call __mulsf3
 114 0060 20E0      		ldi r18,lo8(0x3f800000)
 115 0062 30E0      		ldi r19,hi8(0x3f800000)
 116 0064 40E8      		ldi r20,hlo8(0x3f800000)
 117 0066 5FE3      		ldi r21,hhi8(0x3f800000)
 118 0068 0E94 0000 		call __addsf3
 119 006c 2091 0000 		lds r18,Parameter+36
 120 0070 3091 0000 		lds r19,Parameter+36+1
 121 0074 4091 0000 		lds r20,Parameter+36+2
 122 0078 5091 0000 		lds r21,Parameter+36+3
 123 007c 0E94 0000 		call __mulsf3
 124 0080 D62F      		mov r29,r22
 125 0082 C72F      		mov r28,r23
 126 0084 182F      		mov r17,r24
 127 0086 092F      		mov r16,r25
 128 0088 AE01      		movw r20,r28
 129 008a 9801      		movw r18,r16
 130 008c 852F      		mov r24,r21
 131 008e 942F      		mov r25,r20
 132 0090 A32F      		mov r26,r19
 133 0092 B22F      		mov r27,r18
 134 0094 8093 0000 		sts realWindingResistance,r24
 135 0098 9093 0000 		sts realWindingResistance+1,r25
 136 009c A093 0000 		sts realWindingResistance+2,r26
 137 00a0 B093 0000 		sts realWindingResistance+3,r27
 138               	.LVL4:
 366:thermalModel.c ****     
 367:thermalModel.c ****     //Compute the power supplied to the motor
 368:thermalModel.c ****     powerSupplied = newCurrent * newCurrent * realWindingResistance;
 139               		.loc 1 368 0
 140 00a4 C701      		movw r24,r14
 141 00a6 B601      		movw r22,r12
 142               	.LVL5:
 143 00a8 A701      		movw r20,r14
 144 00aa 9601      		movw r18,r12
 145 00ac 0E94 0000 		call __mulsf3
 146               	.LVL6:
 147 00b0 FE01      		movw r30,r28
 148 00b2 A801      		movw r20,r16
 149 00b4 0F2F      		mov r16,r31
 150               	.LVL7:
 151 00b6 1E2F      		mov r17,r30
 152 00b8 252F      		mov r18,r21
 153 00ba 342F      		mov r19,r20
 154 00bc A901      		movw r20,r18
 155 00be 9801      		movw r18,r16
 156 00c0 0E94 0000 		call __mulsf3
 369:thermalModel.c **** 
 370:thermalModel.c ****     //Now compute the final temperature delta that would be reached if this power were applied for 
 371:thermalModel.c ****     deltaTFinal = powerSupplied * Parameter[PARAMETER_THERMAL_R];
 157               		.loc 1 371 0
 158 00c4 2091 0000 		lds r18,Parameter+40
 159 00c8 3091 0000 		lds r19,Parameter+40+1
 160 00cc 4091 0000 		lds r20,Parameter+40+2
 161 00d0 5091 0000 		lds r21,Parameter+40+3
 162 00d4 0E94 0000 		call __mulsf3
 163 00d8 D62F      		mov r29,r22
 164 00da C72F      		mov r28,r23
 165 00dc 182F      		mov r17,r24
 166 00de 092F      		mov r16,r25
 167               	.LVL8:
 372:thermalModel.c **** 
 373:thermalModel.c ****     //Update the oldDeltaT value by stepping forward the discrete estimate
 374:thermalModel.c ****     oldDeltaT = deltaTFinal - (deltaTFinal - oldDeltaT) * exp(-CONTROL_LOOP_PERIOD_MS/(Parameter[PA
 168               		.loc 1 374 0
 169 00e0 6AE9      		ldi r22,lo8(0xc0b9999a)
 170 00e2 79E9      		ldi r23,hi8(0xc0b9999a)
 171 00e4 89EB      		ldi r24,hlo8(0xc0b9999a)
 172 00e6 90EC      		ldi r25,hhi8(0xc0b9999a)
 173               	.LVL9:
 174 00e8 2091 0000 		lds r18,Parameter+52
 175 00ec 3091 0000 		lds r19,Parameter+52+1
 176 00f0 4091 0000 		lds r20,Parameter+52+2
 177 00f4 5091 0000 		lds r21,Parameter+52+3
 178 00f8 0E94 0000 		call __divsf3
 179               	.LVL10:
 180 00fc 0E94 0000 		call exp
 181 0100 6B01      		movw r12,r22
 182 0102 7C01      		movw r14,r24
 183               	.LVL11:
 184 0104 AE01      		movw r20,r28
 185 0106 9801      		movw r18,r16
 186 0108 852F      		mov r24,r21
 187 010a 942F      		mov r25,r20
 188 010c A32F      		mov r26,r19
 189 010e B22F      		mov r27,r18
 190 0110 BC01      		movw r22,r24
 191 0112 CD01      		movw r24,r26
 192 0114 A501      		movw r20,r10
 193 0116 9401      		movw r18,r8
 194 0118 0E94 0000 		call __subsf3
 195 011c A701      		movw r20,r14
 196 011e 9601      		movw r18,r12
 197 0120 0E94 0000 		call __mulsf3
 198 0124 9B01      		movw r18,r22
 199 0126 AC01      		movw r20,r24
 200 0128 FE01      		movw r30,r28
 201 012a B801      		movw r22,r16
 202 012c 8F2F      		mov r24,r31
 203 012e 9E2F      		mov r25,r30
 204 0130 A72F      		mov r26,r23
 205 0132 B62F      		mov r27,r22
 206 0134 BC01      		movw r22,r24
 207 0136 CD01      		movw r24,r26
 208 0138 0E94 0000 		call __subsf3
 209 013c F62F      		mov r31,r22
 210 013e E72F      		mov r30,r23
 211 0140 382F      		mov r19,r24
 212 0142 292F      		mov r18,r25
 213 0144 DF01      		movw r26,r30
 214 0146 C901      		movw r24,r18
 215 0148 4B2F      		mov r20,r27
 216 014a 5A2F      		mov r21,r26
 217 014c 692F      		mov r22,r25
 218 014e 782F      		mov r23,r24
 219 0150 4093 0000 		sts oldDeltaT,r20
 220 0154 5093 0000 		sts oldDeltaT+1,r21
 221 0158 6093 0000 		sts oldDeltaT+2,r22
 222 015c 7093 0000 		sts oldDeltaT+3,r23
 375:thermalModel.c **** 
 376:thermalModel.c ****     if(isnan(oldDeltaT)) oldDeltaT = 130;
 223               		.loc 1 376 0
 224 0160 CB01      		movw r24,r22
 225 0162 BA01      		movw r22,r20
 226 0164 A901      		movw r20,r18
 227 0166 0B2F      		mov r16,r27
 228               	.LVL12:
 229 0168 1A2F      		mov r17,r26
 230 016a 252F      		mov r18,r21
 231 016c 342F      		mov r19,r20
 232 016e A901      		movw r20,r18
 233 0170 9801      		movw r18,r16
 234 0172 0E94 0000 		call __unordsf2
 235 0176 8823      		tst r24
 236 0178 01F0      		breq .L2
 237               		.loc 1 376 0 is_stmt 0 discriminator 1
 238 017a 80E0      		ldi r24,lo8(0x43020000)
 239 017c 90E0      		ldi r25,hi8(0x43020000)
 240 017e A2E0      		ldi r26,hlo8(0x43020000)
 241 0180 B3E4      		ldi r27,hhi8(0x43020000)
 242 0182 8093 0000 		sts oldDeltaT,r24
 243 0186 9093 0000 		sts oldDeltaT+1,r25
 244 018a A093 0000 		sts oldDeltaT+2,r26
 245 018e B093 0000 		sts oldDeltaT+3,r27
 246               	.LVL13:
 247               	.L2:
 377:thermalModel.c ****     if(oldDeltaT > 130) oldDeltaT = 130;
 248               		.loc 1 377 0 is_stmt 1
 249 0192 6091 0000 		lds r22,oldDeltaT
 250 0196 7091 0000 		lds r23,oldDeltaT+1
 251 019a 8091 0000 		lds r24,oldDeltaT+2
 252 019e 9091 0000 		lds r25,oldDeltaT+3
 253 01a2 20E0      		ldi r18,lo8(0x43020000)
 254 01a4 30E0      		ldi r19,hi8(0x43020000)
 255 01a6 42E0      		ldi r20,hlo8(0x43020000)
 256 01a8 53E4      		ldi r21,hhi8(0x43020000)
 257 01aa 0E94 0000 		call __gtsf2
 258 01ae 1816      		cp __zero_reg__,r24
 259 01b0 04F4      		brge .L4
 260               		.loc 1 377 0 is_stmt 0 discriminator 1
 261 01b2 80E0      		ldi r24,lo8(0x43020000)
 262 01b4 90E0      		ldi r25,hi8(0x43020000)
 263 01b6 A2E0      		ldi r26,hlo8(0x43020000)
 264 01b8 B3E4      		ldi r27,hhi8(0x43020000)
 265 01ba 8093 0000 		sts oldDeltaT,r24
 266 01be 9093 0000 		sts oldDeltaT+1,r25
 267 01c2 A093 0000 		sts oldDeltaT+2,r26
 268 01c6 B093 0000 		sts oldDeltaT+3,r27
 269               	.L4:
 378:thermalModel.c ****     if(oldDeltaT < 0) oldDeltaT = 0;
 270               		.loc 1 378 0 is_stmt 1
 271 01ca 6091 0000 		lds r22,oldDeltaT
 272 01ce 7091 0000 		lds r23,oldDeltaT+1
 273 01d2 8091 0000 		lds r24,oldDeltaT+2
 274 01d6 9091 0000 		lds r25,oldDeltaT+3
 275 01da 20E0      		ldi r18,lo8(0x0)
 276 01dc 30E0      		ldi r19,hi8(0x0)
 277 01de A901      		movw r20,r18
 278 01e0 0E94 0000 		call __ltsf2
 279 01e4 87FF      		sbrs r24,7
 280 01e6 00C0      		rjmp .L6
 281               		.loc 1 378 0 is_stmt 0 discriminator 1
 282 01e8 80E0      		ldi r24,lo8(0x0)
 283 01ea 90E0      		ldi r25,hi8(0x0)
 284 01ec DC01      		movw r26,r24
 285 01ee 8093 0000 		sts oldDeltaT,r24
 286 01f2 9093 0000 		sts oldDeltaT+1,r25
 287 01f6 A093 0000 		sts oldDeltaT+2,r26
 288 01fa B093 0000 		sts oldDeltaT+3,r27
 289               	.L6:
 379:thermalModel.c **** 
 380:thermalModel.c ****     return oldDeltaT + newTemp;
 290               		.loc 1 380 0 is_stmt 1
 291 01fe C301      		movw r24,r6
 292 0200 B201      		movw r22,r4
 293 0202 2091 0000 		lds r18,oldDeltaT
 294 0206 3091 0000 		lds r19,oldDeltaT+1
 295 020a 4091 0000 		lds r20,oldDeltaT+2
 296 020e 5091 0000 		lds r21,oldDeltaT+3
 297 0212 0E94 0000 		call __addsf3
 381:thermalModel.c **** }
 298               		.loc 1 381 0
 299 0216 462F      		mov r20,r22
 300 0218 572F      		mov r21,r23
 301 021a 682F      		mov r22,r24
 302 021c 792F      		mov r23,r25
 303 021e CB01      		movw r24,r22
 304 0220 BA01      		movw r22,r20
 305               	/* epilogue start */
 306 0222 DF91      		pop r29
 307 0224 CF91      		pop r28
 308 0226 1F91      		pop r17
 309 0228 0F91      		pop r16
 310 022a FF90      		pop r15
 311 022c EF90      		pop r14
 312 022e DF90      		pop r13
 313 0230 CF90      		pop r12
 314 0232 BF90      		pop r11
 315 0234 AF90      		pop r10
 316 0236 9F90      		pop r9
 317 0238 8F90      		pop r8
 318               	.LVL14:
 319 023a 7F90      		pop r7
 320 023c 6F90      		pop r6
 321 023e 5F90      		pop r5
 322 0240 4F90      		pop r4
 323               	.LVL15:
 324 0242 0895      		ret
 325               		.cfi_endproc
 326               	.LFE7:
 329               	isValidOverride:
 330               	.LFB5:
 157:thermalModel.c **** {
 331               		.loc 1 157 0
 332               		.cfi_startproc
 333               	.LVL16:
 334 0244 8F92      		push r8
 335               	.LCFI16:
 336               		.cfi_def_cfa_offset 3
 337               		.cfi_offset 8, -2
 338 0246 9F92      		push r9
 339               	.LCFI17:
 340               		.cfi_def_cfa_offset 4
 341               		.cfi_offset 9, -3
 342 0248 AF92      		push r10
 343               	.LCFI18:
 344               		.cfi_def_cfa_offset 5
 345               		.cfi_offset 10, -4
 346 024a BF92      		push r11
 347               	.LCFI19:
 348               		.cfi_def_cfa_offset 6
 349               		.cfi_offset 11, -5
 350 024c CF92      		push r12
 351               	.LCFI20:
 352               		.cfi_def_cfa_offset 7
 353               		.cfi_offset 12, -6
 354 024e DF92      		push r13
 355               	.LCFI21:
 356               		.cfi_def_cfa_offset 8
 357               		.cfi_offset 13, -7
 358 0250 EF92      		push r14
 359               	.LCFI22:
 360               		.cfi_def_cfa_offset 9
 361               		.cfi_offset 14, -8
 362 0252 FF92      		push r15
 363               	.LCFI23:
 364               		.cfi_def_cfa_offset 10
 365               		.cfi_offset 15, -9
 366               	/* prologue: function */
 367               	/* frame size = 0 */
 368               	/* stack size = 8 */
 369               	.L__stack_usage = 8
 370 0254 4C01      		movw r8,r24
 160:thermalModel.c ****     if(scheme == CONTROL_SCHEME_CURRENT)
 371               		.loc 1 160 0
 372 0256 6230      		cpi r22,lo8(2)
 373 0258 01F0      		breq .+2
 374 025a 00C0      		rjmp .L12
 375               	.LVL17:
 163:thermalModel.c ****         maximumDeltaT = Parameter[PARAMETER_T_TARGET] - statorTemperature;
 376               		.loc 1 163 0
 377 025c 6091 0000 		lds r22,Parameter+68
 378 0260 7091 0000 		lds r23,Parameter+68+1
 379 0264 8091 0000 		lds r24,Parameter+68+2
 380 0268 9091 0000 		lds r25,Parameter+68+3
 381               	.LVL18:
 382 026c 2091 0000 		lds r18,statorTemperature
 383 0270 3091 0000 		lds r19,statorTemperature+1
 384 0274 4091 0000 		lds r20,statorTemperature+2
 385 0278 5091 0000 		lds r21,statorTemperature+3
 386 027c 0E94 0000 		call __subsf3
 387               	.LVL19:
 388 0280 6B01      		movw r12,r22
 389 0282 7C01      		movw r14,r24
 165:thermalModel.c ****                       (Parameter[PARAMETER_THERMAL_R] * realWindingResistance));
 390               		.loc 1 165 0
 391 0284 6091 0000 		lds r22,Parameter+40
 392 0288 7091 0000 		lds r23,Parameter+40+1
 393 028c 8091 0000 		lds r24,Parameter+40+2
 394 0290 9091 0000 		lds r25,Parameter+40+3
 395 0294 2091 0000 		lds r18,realWindingResistance
 396 0298 3091 0000 		lds r19,realWindingResistance+1
 397 029c 4091 0000 		lds r20,realWindingResistance+2
 398 02a0 5091 0000 		lds r21,realWindingResistance+3
 399 02a4 0E94 0000 		call __mulsf3
 400 02a8 9B01      		movw r18,r22
 401 02aa AC01      		movw r20,r24
 164:thermalModel.c ****         maximumCurrent = sqrt(maximumDeltaT / \
 402               		.loc 1 164 0
 403 02ac C701      		movw r24,r14
 404 02ae B601      		movw r22,r12
 405 02b0 0E94 0000 		call __divsf3
 406 02b4 0E94 0000 		call sqrt
 407 02b8 6B01      		movw r12,r22
 408 02ba 7C01      		movw r14,r24
 409               	.LVL20:
 167:thermalModel.c ****         if(setpoint < maximumCurrent * 1000)
 410               		.loc 1 167 0
 411 02bc B401      		movw r22,r8
 412               	.LVL21:
 413 02be 80E0      		ldi r24,lo8(0)
 414 02c0 90E0      		ldi r25,hi8(0)
 415 02c2 0E94 0000 		call __floatunsisf
 416 02c6 4B01      		movw r8,r22
 417 02c8 5C01      		movw r10,r24
 418               	.LVL22:
 419 02ca C701      		movw r24,r14
 420 02cc B601      		movw r22,r12
 421 02ce 20E0      		ldi r18,lo8(0x447a0000)
 422 02d0 30E0      		ldi r19,hi8(0x447a0000)
 423 02d2 4AE7      		ldi r20,hlo8(0x447a0000)
 424 02d4 54E4      		ldi r21,hhi8(0x447a0000)
 425 02d6 0E94 0000 		call __mulsf3
 426 02da 9B01      		movw r18,r22
 427 02dc AC01      		movw r20,r24
 169:thermalModel.c ****             return 1;
 428               		.loc 1 169 0
 429 02de C501      		movw r24,r10
 430 02e0 B401      		movw r22,r8
 431 02e2 0E94 0000 		call __ltsf2
 432 02e6 881F      		rol r24
 433 02e8 8827      		clr r24
 434 02ea 881F      		rol r24
 435 02ec 00C0      		rjmp .L14
 436               	.LVL23:
 437               	.L12:
 172:thermalModel.c ****     if(scheme == CONTROL_SCHEME_VELOCITY)
 438               		.loc 1 172 0
 439 02ee 6130      		cpi r22,lo8(1)
 440 02f0 01F0      		breq .+2
 441 02f2 00C0      		rjmp .L18
 442               	.LVL24:
 443               	.LBB4:
 444               	.LBB5:
 184:thermalModel.c ****         maximumDeltaT = Parameter[PARAMETER_T_TARGET] - statorTemperature;
 445               		.loc 1 184 0
 446 02f4 6091 0000 		lds r22,Parameter+68
 447 02f8 7091 0000 		lds r23,Parameter+68+1
 448 02fc 8091 0000 		lds r24,Parameter+68+2
 449 0300 9091 0000 		lds r25,Parameter+68+3
 450               	.LVL25:
 451 0304 2091 0000 		lds r18,statorTemperature
 452 0308 3091 0000 		lds r19,statorTemperature+1
 453 030c 4091 0000 		lds r20,statorTemperature+2
 454 0310 5091 0000 		lds r21,statorTemperature+3
 455 0314 0E94 0000 		call __subsf3
 456               	.LVL26:
 457 0318 6B01      		movw r12,r22
 458 031a 7C01      		movw r14,r24
 186:thermalModel.c ****                       (Parameter[PARAMETER_THERMAL_R] * realWindingResistance));
 459               		.loc 1 186 0
 460 031c 6091 0000 		lds r22,Parameter+40
 461 0320 7091 0000 		lds r23,Parameter+40+1
 462 0324 8091 0000 		lds r24,Parameter+40+2
 463 0328 9091 0000 		lds r25,Parameter+40+3
 464 032c 2091 0000 		lds r18,realWindingResistance
 465 0330 3091 0000 		lds r19,realWindingResistance+1
 466 0334 4091 0000 		lds r20,realWindingResistance+2
 467 0338 5091 0000 		lds r21,realWindingResistance+3
 468 033c 0E94 0000 		call __mulsf3
 469 0340 9B01      		movw r18,r22
 470 0342 AC01      		movw r20,r24
 185:thermalModel.c ****         maximumCurrent = sqrt(maximumDeltaT / \
 471               		.loc 1 185 0
 472 0344 C701      		movw r24,r14
 473 0346 B601      		movw r22,r12
 474 0348 0E94 0000 		call __divsf3
 475 034c 0E94 0000 		call sqrt
 476               	.LVL27:
 189:thermalModel.c ****         if((motorCurrent <= (maximumCurrent * 1.25)) && (averageRPM >= setpoint))
 477               		.loc 1 189 0
 478 0350 20E0      		ldi r18,lo8(0x3fa00000)
 479 0352 30E0      		ldi r19,hi8(0x3fa00000)
 480 0354 40EA      		ldi r20,hlo8(0x3fa00000)
 481 0356 5FE3      		ldi r21,hhi8(0x3fa00000)
 482 0358 0E94 0000 		call __mulsf3
 483               	.LVL28:
 484 035c 9B01      		movw r18,r22
 485 035e AC01      		movw r20,r24
 486 0360 6091 0000 		lds r22,motorCurrent
 487 0364 7091 0000 		lds r23,motorCurrent+1
 488 0368 8091 0000 		lds r24,motorCurrent+2
 489 036c 9091 0000 		lds r25,motorCurrent+3
 490 0370 0E94 0000 		call __lesf2
 491 0374 1816      		cp __zero_reg__,r24
 492 0376 04F0      		brlt .L18
 156:thermalModel.c **** static uint8_t isValidOverride(uint16_t setpoint, PID_SCHEME_t scheme)
 493               		.loc 1 156 0
 494 0378 81E0      		ldi r24,lo8(1)
 495 037a 2091 0000 		lds r18,averageRPM
 496 037e 3091 0000 		lds r19,averageRPM+1
 497 0382 2815      		cp r18,r8
 498 0384 3905      		cpc r19,r9
 499 0386 00F4      		brsh .L14
 500               	.LVL29:
 501               	.L18:
 502               	.LBE5:
 503               	.LBE4:
 195:thermalModel.c ****     return 0;
 504               		.loc 1 195 0
 505 0388 80E0      		ldi r24,lo8(0)
 506               	.LVL30:
 507               	.L14:
 508               	/* epilogue start */
 196:thermalModel.c **** }
 509               		.loc 1 196 0
 510 038a FF90      		pop r15
 511 038c EF90      		pop r14
 512 038e DF90      		pop r13
 513 0390 CF90      		pop r12
 514 0392 BF90      		pop r11
 515 0394 AF90      		pop r10
 516 0396 9F90      		pop r9
 517 0398 8F90      		pop r8
 518 039a 0895      		ret
 519               		.cfi_endproc
 520               	.LFE5:
 522               	.global	thermalCheckSetpoint
 524               	thermalCheckSetpoint:
 525               	.LFB2:
  71:thermalModel.c **** {
 526               		.loc 1 71 0
 527               		.cfi_startproc
 528               	.LVL31:
 529 039c 1F93      		push r17
 530               	.LCFI24:
 531               		.cfi_def_cfa_offset 3
 532               		.cfi_offset 17, -2
 533 039e CF93      		push r28
 534               	.LCFI25:
 535               		.cfi_def_cfa_offset 4
 536               		.cfi_offset 28, -3
 537 03a0 DF93      		push r29
 538               	.LCFI26:
 539               		.cfi_def_cfa_offset 5
 540               		.cfi_offset 29, -4
 541               	/* prologue: function */
 542               	/* frame size = 0 */
 543               	/* stack size = 3 */
 544               	.L__stack_usage = 3
 545 03a2 182F      		mov r17,r24
 546 03a4 EB01      		movw r28,r22
  72:thermalModel.c ****     switch(protectionState)
 547               		.loc 1 72 0
 548 03a6 8091 0000 		lds r24,protectionState
 549               	.LVL32:
 550 03aa 8230      		cpi r24,lo8(2)
 551 03ac 01F0      		breq .L36
 552 03ae 8330      		cpi r24,lo8(3)
 553 03b0 00F4      		brsh .L28
 554 03b2 8823      		tst r24
 555 03b4 01F4      		brne .+2
 556 03b6 00C0      		rjmp .L33
 557 03b8 8130      		cpi r24,lo8(1)
 558 03ba 01F0      		breq .+2
 559 03bc 00C0      		rjmp .L31
 560 03be 00C0      		rjmp .L37
 561               	.L28:
 562 03c0 8530      		cpi r24,lo8(5)
 563 03c2 01F4      		brne .+2
 564 03c4 00C0      		rjmp .L33
 565 03c6 8630      		cpi r24,lo8(6)
 566 03c8 01F0      		breq .L27
 567 03ca 8330      		cpi r24,lo8(3)
 568 03cc 01F4      		brne .L31
 569 03ce 00C0      		rjmp .L33
 570               	.L37:
  88:thermalModel.c ****             if(isValidOverride(newSetpoint, newScheme) == 1)
 571               		.loc 1 88 0
 572 03d0 CB01      		movw r24,r22
 573 03d2 612F      		mov r22,r17
 574               	.LVL33:
 575 03d4 0E94 0000 		call isValidOverride
 576 03d8 8130      		cpi r24,lo8(1)
 577 03da 01F4      		brne .L32
  91:thermalModel.c ****                 protectionState = THERMAL_OVERLOAD_OVERRIDE;
 578               		.loc 1 91 0
 579 03dc 86E0      		ldi r24,lo8(6)
 580 03de 8093 0000 		sts protectionState,r24
 581 03e2 00C0      		rjmp .L33
 582               	.L27:
  98:thermalModel.c ****             if((statorTemperature + oldDeltaT) < Parameter[PARAMETER_T_PLUS])
 583               		.loc 1 98 0
 584 03e4 6091 0000 		lds r22,statorTemperature
 585 03e8 7091 0000 		lds r23,statorTemperature+1
 586 03ec 8091 0000 		lds r24,statorTemperature+2
 587 03f0 9091 0000 		lds r25,statorTemperature+3
 588 03f4 2091 0000 		lds r18,oldDeltaT
 589 03f8 3091 0000 		lds r19,oldDeltaT+1
 590 03fc 4091 0000 		lds r20,oldDeltaT+2
 591 0400 5091 0000 		lds r21,oldDeltaT+3
 592 0404 0E94 0000 		call __addsf3
 593 0408 2091 0000 		lds r18,Parameter+44
 594 040c 3091 0000 		lds r19,Parameter+44+1
 595 0410 4091 0000 		lds r20,Parameter+44+2
 596 0414 5091 0000 		lds r21,Parameter+44+3
 597 0418 0E94 0000 		call __ltsf2
 598 041c 87FF      		sbrs r24,7
 599 041e 00C0      		rjmp .L35
 600               	.L36:
 100:thermalModel.c ****                 protectionState = NORMAL_OPERATION;
 601               		.loc 1 100 0
 602 0420 1092 0000 		sts protectionState,__zero_reg__
 603 0424 00C0      		rjmp .L33
 604               	.L35:
 102:thermalModel.c ****             } else if(isValidOverride(newSetpoint, newScheme) == 1)
 605               		.loc 1 102 0
 606 0426 CE01      		movw r24,r28
 607 0428 612F      		mov r22,r17
 608 042a 0E94 0000 		call isValidOverride
 609 042e 8130      		cpi r24,lo8(1)
 610 0430 01F0      		breq .L33
 108:thermalModel.c ****                 protectionState = THERMAL_OVERLOAD;
 611               		.loc 1 108 0
 612 0432 81E0      		ldi r24,lo8(1)
 613 0434 8093 0000 		sts protectionState,r24
 109:thermalModel.c ****                 PIDPreset(CONTROL_SCHEME_POWER);
 614               		.loc 1 109 0
 615 0438 83E0      		ldi r24,lo8(3)
 616 043a 0E94 0000 		call PIDPreset
 617 043e 00C0      		rjmp .L32
 618               	.L31:
  86:thermalModel.c ****             return THERMAL_DISCARD;
 619               		.loc 1 86 0
 620 0440 80E0      		ldi r24,lo8(0)
 621 0442 90E0      		ldi r25,hi8(0)
 622 0444 00C0      		rjmp .L23
 623               	.L32:
  95:thermalModel.c ****                 return THERMAL_DELAY;
 624               		.loc 1 95 0
 625 0446 81E0      		ldi r24,lo8(1)
 626 0448 90E0      		ldi r25,hi8(1)
 627 044a 00C0      		rjmp .L23
 628               	.L33:
 105:thermalModel.c ****                 return THERMAL_OK;
 629               		.loc 1 105 0
 630 044c 82E0      		ldi r24,lo8(2)
 631 044e 90E0      		ldi r25,hi8(2)
 632               	.L23:
 633               	/* epilogue start */
 115:thermalModel.c **** }
 634               		.loc 1 115 0
 635 0450 DF91      		pop r29
 636 0452 CF91      		pop r28
 637               	.LVL34:
 638 0454 1F91      		pop r17
 639               	.LVL35:
 640 0456 0895      		ret
 641               		.cfi_endproc
 642               	.LFE2:
 644               	.global	getWindingResistance
 646               	getWindingResistance:
 647               	.LFB3:
 122:thermalModel.c **** {
 648               		.loc 1 122 0
 649               		.cfi_startproc
 650               	/* prologue: function */
 651               	/* frame size = 0 */
 652               	/* stack size = 0 */
 653               	.L__stack_usage = 0
 124:thermalModel.c **** }
 654               		.loc 1 124 0
 655 0458 5091 0000 		lds r21,realWindingResistance
 656 045c 4091 0000 		lds r20,realWindingResistance+1
 657 0460 3091 0000 		lds r19,realWindingResistance+2
 658 0464 2091 0000 		lds r18,realWindingResistance+3
 659 0468 852F      		mov r24,r21
 660 046a 942F      		mov r25,r20
 661 046c A32F      		mov r26,r19
 662 046e B22F      		mov r27,r18
 663 0470 BC01      		movw r22,r24
 664 0472 CD01      		movw r24,r26
 665               	/* epilogue start */
 666 0474 0895      		ret
 667               		.cfi_endproc
 668               	.LFE3:
 670               	.global	getPowerSetpoint
 672               	getPowerSetpoint:
 673               	.LFB4:
 133:thermalModel.c **** {
 674               		.loc 1 133 0
 675               		.cfi_startproc
 676 0476 0F93      		push r16
 677               	.LCFI27:
 678               		.cfi_def_cfa_offset 3
 679               		.cfi_offset 16, -2
 680 0478 1F93      		push r17
 681               	.LCFI28:
 682               		.cfi_def_cfa_offset 4
 683               		.cfi_offset 17, -3
 684 047a CF93      		push r28
 685               	.LCFI29:
 686               		.cfi_def_cfa_offset 5
 687               		.cfi_offset 28, -4
 688 047c DF93      		push r29
 689               	.LCFI30:
 690               		.cfi_def_cfa_offset 6
 691               		.cfi_offset 29, -5
 692               	/* prologue: function */
 693               	/* frame size = 0 */
 694               	/* stack size = 4 */
 695               	.L__stack_usage = 4
 136:thermalModel.c ****     if((protectionState == THERMAL_OVERLOAD) || \
 696               		.loc 1 136 0
 697 047e 8091 0000 		lds r24,protectionState
 698 0482 8150      		subi r24,lo8(-(-1))
 699 0484 8230      		cpi r24,lo8(2)
 700 0486 00F4      		brsh .L42
 701               	.LVL36:
 138:thermalModel.c ****         maximumDeltaD = Parameter[PARAMETER_T_TARGET] - statorTemperature;
 702               		.loc 1 138 0
 703 0488 6091 0000 		lds r22,Parameter+68
 704 048c 7091 0000 		lds r23,Parameter+68+1
 705 0490 8091 0000 		lds r24,Parameter+68+2
 706 0494 9091 0000 		lds r25,Parameter+68+3
 707 0498 2091 0000 		lds r18,statorTemperature
 708 049c 3091 0000 		lds r19,statorTemperature+1
 709 04a0 4091 0000 		lds r20,statorTemperature+2
 710 04a4 5091 0000 		lds r21,statorTemperature+3
 711 04a8 0E94 0000 		call __subsf3
 712               	.LVL37:
 139:thermalModel.c ****        powerSetpoint = maximumDeltaD / Parameter[PARAMETER_THERMAL_R];
 713               		.loc 1 139 0
 714 04ac 2091 0000 		lds r18,Parameter+40
 715 04b0 3091 0000 		lds r19,Parameter+40+1
 716 04b4 4091 0000 		lds r20,Parameter+40+2
 717 04b8 5091 0000 		lds r21,Parameter+40+3
 718 04bc 0E94 0000 		call __divsf3
 719 04c0 8B01      		movw r16,r22
 720 04c2 D82F      		mov r29,r24
 721 04c4 C92F      		mov r28,r25
 722               	.LVL38:
 140:thermalModel.c ****        if (powerSetpoint < 0)
 723               		.loc 1 140 0
 724 04c6 9E01      		movw r18,r28
 725 04c8 862F      		mov r24,r22
 726               	.LVL39:
 727 04ca 912F      		mov r25,r17
 728               	.LVL40:
 729 04cc A32F      		mov r26,r19
 730 04ce B22F      		mov r27,r18
 731 04d0 BC01      		movw r22,r24
 732 04d2 CD01      		movw r24,r26
 733               	.LVL41:
 734 04d4 20E0      		ldi r18,lo8(0x0)
 735 04d6 30E0      		ldi r19,hi8(0x0)
 736 04d8 A901      		movw r20,r18
 737 04da 0E94 0000 		call __ltsf2
 738               	.LVL42:
 739 04de 87FF      		sbrs r24,7
 740 04e0 00C0      		rjmp .L40
 142:thermalModel.c ****            return 0.0;
 741               		.loc 1 142 0
 742 04e2 00E0      		ldi r16,lo8(0)
 743 04e4 10E0      		ldi r17,lo8(0)
 744 04e6 D0E0      		ldi r29,lo8(0)
 745 04e8 C0E0      		ldi r28,lo8(0)
 746 04ea 00C0      		rjmp .L40
 747               	.L42:
 147:thermalModel.c ****        return -1.0;
 748               		.loc 1 147 0
 749 04ec 00E0      		ldi r16,lo8(0)
 750 04ee 10E0      		ldi r17,lo8(0)
 751 04f0 D0E8      		ldi r29,lo8(-128)
 752 04f2 CFEB      		ldi r28,lo8(-65)
 753               	.L40:
 149:thermalModel.c **** }
 754               		.loc 1 149 0
 755 04f4 9E01      		movw r18,r28
 756 04f6 802F      		mov r24,r16
 757 04f8 912F      		mov r25,r17
 758 04fa A32F      		mov r26,r19
 759 04fc BC2F      		mov r27,r28
 760 04fe BC01      		movw r22,r24
 761 0500 CD01      		movw r24,r26
 762               	/* epilogue start */
 763 0502 DF91      		pop r29
 764 0504 CF91      		pop r28
 765 0506 1F91      		pop r17
 766 0508 0F91      		pop r16
 767 050a 0895      		ret
 768               		.cfi_endproc
 769               	.LFE4:
 771               	.global	updateThermalModel
 773               	updateThermalModel:
 774               	.LFB6:
 207:thermalModel.c **** {
 775               		.loc 1 207 0
 776               		.cfi_startproc
 777               	.LVL43:
 778 050c CF92      		push r12
 779               	.LCFI31:
 780               		.cfi_def_cfa_offset 3
 781               		.cfi_offset 12, -2
 782 050e DF92      		push r13
 783               	.LCFI32:
 784               		.cfi_def_cfa_offset 4
 785               		.cfi_offset 13, -3
 786 0510 EF92      		push r14
 787               	.LCFI33:
 788               		.cfi_def_cfa_offset 5
 789               		.cfi_offset 14, -4
 790 0512 FF92      		push r15
 791               	.LCFI34:
 792               		.cfi_def_cfa_offset 6
 793               		.cfi_offset 15, -5
 794               	/* prologue: function */
 795               	/* frame size = 0 */
 796               	/* stack size = 4 */
 797               	.L__stack_usage = 4
 209:thermalModel.c ****     switch(protectionState)
 798               		.loc 1 209 0
 799 0514 E091 0000 		lds r30,protectionState
 800 0518 E330      		cpi r30,lo8(3)
 801 051a 01F0      		breq .L49
 802 051c E430      		cpi r30,lo8(4)
 803 051e 00F4      		brsh .L53
 804 0520 E130      		cpi r30,lo8(1)
 805 0522 01F4      		brne .+2
 806 0524 00C0      		rjmp .L47
 807 0526 E230      		cpi r30,lo8(2)
 808 0528 00F0      		brlo .+2
 809 052a 00C0      		rjmp .L48
 810 052c 00C0      		rjmp .L110
 811               	.L53:
 812 052e E530      		cpi r30,lo8(5)
 813 0530 01F4      		brne .+2
 814 0532 00C0      		rjmp .L51
 815 0534 E530      		cpi r30,lo8(5)
 816 0536 00F0      		brlo .L50
 817 0538 E630      		cpi r30,lo8(6)
 818 053a 01F0      		breq .+2
 819 053c 00C0      		rjmp .L44
 820 053e 00C0      		rjmp .L111
 821               	.L50:
 213:thermalModel.c ****             updateTemperatureEsimate(newTemp, newCurrent);
 822               		.loc 1 213 0
 823 0540 0E94 0000 		call updateTemperatureEsimate
 824               	.LVL44:
 214:thermalModel.c ****             if(cooldownTimeRemaining > 0)
 825               		.loc 1 214 0
 826 0544 C090 0000 		lds r12,cooldownTimeRemaining
 827 0548 D090 0000 		lds r13,cooldownTimeRemaining+1
 828 054c E090 0000 		lds r14,cooldownTimeRemaining+2
 829 0550 F090 0000 		lds r15,cooldownTimeRemaining+3
 830 0554 C701      		movw r24,r14
 831 0556 B601      		movw r22,r12
 832 0558 20E0      		ldi r18,lo8(0x0)
 833 055a 30E0      		ldi r19,hi8(0x0)
 834 055c A901      		movw r20,r18
 835 055e 0E94 0000 		call __gtsf2
 836 0562 1816      		cp __zero_reg__,r24
 837 0564 04F4      		brge .L101
 216:thermalModel.c ****                 cooldownTimeRemaining = cooldownTimeRemaining - CONTROL_LOOP_PERIOD_MS;
 838               		.loc 1 216 0
 839 0566 C701      		movw r24,r14
 840 0568 B601      		movw r22,r12
 841 056a 00C0      		rjmp .L100
 842               	.LVL45:
 843               	.L49:
 225:thermalModel.c ****             updateTemperatureEsimate(newTemp, newCurrent);
 844               		.loc 1 225 0
 845 056c 0E94 0000 		call updateTemperatureEsimate
 846               	.LVL46:
 226:thermalModel.c ****             if(cooldownTimeRemaining <= 0)
 847               		.loc 1 226 0
 848 0570 6091 0000 		lds r22,cooldownTimeRemaining
 849 0574 7091 0000 		lds r23,cooldownTimeRemaining+1
 850 0578 8091 0000 		lds r24,cooldownTimeRemaining+2
 851 057c 9091 0000 		lds r25,cooldownTimeRemaining+3
 852 0580 20E0      		ldi r18,lo8(0x0)
 853 0582 30E0      		ldi r19,hi8(0x0)
 854 0584 A901      		movw r20,r18
 855 0586 0E94 0000 		call __lesf2
 856 058a 1816      		cp __zero_reg__,r24
 857 058c 04F0      		brlt .L92
 858               	.L101:
 229:thermalModel.c ****                 oldDeltaT = 0.0;
 859               		.loc 1 229 0
 860 058e 80E0      		ldi r24,lo8(0x0)
 861 0590 90E0      		ldi r25,hi8(0x0)
 862 0592 DC01      		movw r26,r24
 863 0594 8093 0000 		sts oldDeltaT,r24
 864 0598 9093 0000 		sts oldDeltaT+1,r25
 865 059c A093 0000 		sts oldDeltaT+2,r26
 866 05a0 B093 0000 		sts oldDeltaT+3,r27
 230:thermalModel.c ****                 protectionState = STOPPED;
 867               		.loc 1 230 0
 868 05a4 85E0      		ldi r24,lo8(5)
 869 05a6 00C0      		rjmp .L102
 870               	.L92:
 231:thermalModel.c ****             } else if(getMotorDirection() == DIRECTION_STOP)
 871               		.loc 1 231 0
 872 05a8 0E94 0000 		call getMotorDirection
 873 05ac 8823      		tst r24
 874 05ae 01F0      		breq .+2
 875 05b0 00C0      		rjmp .L103
 233:thermalModel.c ****                 cooldownTimeRemaining = cooldownTimeRemaining - CONTROL_LOOP_PERIOD_MS;
 876               		.loc 1 233 0
 877 05b2 6091 0000 		lds r22,cooldownTimeRemaining
 878 05b6 7091 0000 		lds r23,cooldownTimeRemaining+1
 879 05ba 8091 0000 		lds r24,cooldownTimeRemaining+2
 880 05be 9091 0000 		lds r25,cooldownTimeRemaining+3
 881               	.L100:
 882 05c2 2AE9      		ldi r18,lo8(0x40b9999a)
 883 05c4 39E9      		ldi r19,hi8(0x40b9999a)
 884 05c6 49EB      		ldi r20,hlo8(0x40b9999a)
 885 05c8 50E4      		ldi r21,hhi8(0x40b9999a)
 886 05ca 0E94 0000 		call __subsf3
 887               	.L104:
 888 05ce DC01      		movw r26,r24
 889 05d0 CB01      		movw r24,r22
 890 05d2 8093 0000 		sts cooldownTimeRemaining,r24
 891 05d6 9093 0000 		sts cooldownTimeRemaining+1,r25
 892 05da A093 0000 		sts cooldownTimeRemaining+2,r26
 893 05de B093 0000 		sts cooldownTimeRemaining+3,r27
 894 05e2 00C0      		rjmp .L44
 895               	.LVL47:
 896               	.L110:
 241:thermalModel.c ****             estimatedWindingTemperature = updateTemperatureEsimate(newTemp, newCurrent);
 897               		.loc 1 241 0
 898 05e4 0E94 0000 		call updateTemperatureEsimate
 899               	.LVL48:
 900 05e8 6B01      		movw r12,r22
 901 05ea 7C01      		movw r14,r24
 902               	.LVL49:
 242:thermalModel.c ****             if(getMotorDirection() == DIRECTION_STOP)
 903               		.loc 1 242 0
 904 05ec 0E94 0000 		call getMotorDirection
 905               	.LVL50:
 906 05f0 8823      		tst r24
 907 05f2 01F4      		brne .+2
 908 05f4 00C0      		rjmp .L107
 909               	.L59:
 247:thermalModel.c ****             } else if(estimatedWindingTemperature >= Parameter[PARAMETER_T_MAX])
 910               		.loc 1 247 0
 911 05f6 C701      		movw r24,r14
 912 05f8 B601      		movw r22,r12
 913 05fa 2091 0000 		lds r18,Parameter+56
 914 05fe 3091 0000 		lds r19,Parameter+56+1
 915 0602 4091 0000 		lds r20,Parameter+56+2
 916 0606 5091 0000 		lds r21,Parameter+56+3
 917 060a 0E94 0000 		call __gesf2
 918 060e 87FF      		sbrs r24,7
 919 0610 00C0      		rjmp .L106
 920               	.L93:
 252:thermalModel.c ****             } else if(estimatedWindingTemperature >= Parameter[PARAMETER_T_PLUS])
 921               		.loc 1 252 0
 922 0612 C701      		movw r24,r14
 923 0614 B601      		movw r22,r12
 924 0616 2091 0000 		lds r18,Parameter+44
 925 061a 3091 0000 		lds r19,Parameter+44+1
 926 061e 4091 0000 		lds r20,Parameter+44+2
 927 0622 5091 0000 		lds r21,Parameter+44+3
 928 0626 0E94 0000 		call __gesf2
 929 062a 87FD      		sbrc r24,7
 930 062c 00C0      		rjmp .L44
 931 062e 00C0      		rjmp .L109
 932               	.LVL51:
 933               	.L47:
 261:thermalModel.c ****             estimatedWindingTemperature = updateTemperatureEsimate(newTemp, newCurrent);
 934               		.loc 1 261 0
 935 0630 0E94 0000 		call updateTemperatureEsimate
 936               	.LVL52:
 937 0634 6B01      		movw r12,r22
 938 0636 7C01      		movw r14,r24
 939               	.LVL53:
 262:thermalModel.c ****             if(getMotorDirection() == DIRECTION_STOP)
 940               		.loc 1 262 0
 941 0638 0E94 0000 		call getMotorDirection
 942               	.LVL54:
 943 063c 8823      		tst r24
 944 063e 01F4      		brne .+2
 945 0640 00C0      		rjmp .L107
 946               	.L63:
 267:thermalModel.c ****             } else if(estimatedWindingTemperature >= Parameter[PARAMETER_T_MAX])
 947               		.loc 1 267 0
 948 0642 C701      		movw r24,r14
 949 0644 B601      		movw r22,r12
 950 0646 2091 0000 		lds r18,Parameter+56
 951 064a 3091 0000 		lds r19,Parameter+56+1
 952 064e 4091 0000 		lds r20,Parameter+56+2
 953 0652 5091 0000 		lds r21,Parameter+56+3
 954 0656 0E94 0000 		call __gesf2
 955 065a 87FF      		sbrs r24,7
 956 065c 00C0      		rjmp .L106
 957               	.L94:
 272:thermalModel.c ****             } else if(estimatedWindingTemperature < Parameter[PARAMETER_T_PLUS])
 958               		.loc 1 272 0
 959 065e C701      		movw r24,r14
 960 0660 B601      		movw r22,r12
 961 0662 2091 0000 		lds r18,Parameter+44
 962 0666 3091 0000 		lds r19,Parameter+44+1
 963 066a 4091 0000 		lds r20,Parameter+44+2
 964 066e 5091 0000 		lds r21,Parameter+44+3
 965 0672 0E94 0000 		call __ltsf2
 966 0676 87FF      		sbrs r24,7
 967 0678 00C0      		rjmp .L95
 275:thermalModel.c ****                 protectionState = THERMAL_WARNING;
 968               		.loc 1 275 0
 969 067a 82E0      		ldi r24,lo8(2)
 970 067c 00C0      		rjmp .L102
 971               	.L95:
 276:thermalModel.c ****             } else if(isValidOverride(PID_state.setpoint,PID_state.controlScheme) == 1)
 972               		.loc 1 276 0
 973 067e C090 0000 		lds r12,PID_state+8
 974               	.LVL55:
 975 0682 8091 0000 		lds r24,PID_state+9
 976 0686 9091 0000 		lds r25,PID_state+9+1
 977 068a 6C2D      		mov r22,r12
 978 068c 0E94 0000 		call isValidOverride
 979 0690 8130      		cpi r24,lo8(1)
 980 0692 01F0      		breq .+2
 981 0694 00C0      		rjmp .L44
 280:thermalModel.c ****                 PIDPreset(PID_state.controlScheme);
 982               		.loc 1 280 0
 983 0696 8C2D      		mov r24,r12
 984 0698 0E94 0000 		call PIDPreset
 281:thermalModel.c ****                 protectionState = THERMAL_OVERLOAD_OVERRIDE;
 985               		.loc 1 281 0
 986 069c 86E0      		ldi r24,lo8(6)
 987 069e 00C0      		rjmp .L102
 988               	.LVL56:
 989               	.L111:
 286:thermalModel.c ****             estimatedWindingTemperature = updateTemperatureEsimate(newTemp, newCurrent);
 990               		.loc 1 286 0
 991 06a0 0E94 0000 		call updateTemperatureEsimate
 992               	.LVL57:
 993 06a4 6B01      		movw r12,r22
 994 06a6 7C01      		movw r14,r24
 995               	.LVL58:
 287:thermalModel.c ****             if(getMotorDirection() == DIRECTION_STOP)
 996               		.loc 1 287 0
 997 06a8 0E94 0000 		call getMotorDirection
 998               	.LVL59:
 999 06ac 8823      		tst r24
 1000 06ae 01F0      		breq .L107
 1001               	.L68:
 292:thermalModel.c ****             } else if(estimatedWindingTemperature >= Parameter[PARAMETER_T_MAX])
 1002               		.loc 1 292 0
 1003 06b0 C701      		movw r24,r14
 1004 06b2 B601      		movw r22,r12
 1005 06b4 2091 0000 		lds r18,Parameter+56
 1006 06b8 3091 0000 		lds r19,Parameter+56+1
 1007 06bc 4091 0000 		lds r20,Parameter+56+2
 1008 06c0 5091 0000 		lds r21,Parameter+56+3
 1009 06c4 0E94 0000 		call __gesf2
 1010 06c8 87FF      		sbrs r24,7
 1011 06ca 00C0      		rjmp .L106
 1012               	.L96:
 297:thermalModel.c ****             } else if(estimatedWindingTemperature < Parameter[PARAMETER_T_MINUS])
 1013               		.loc 1 297 0
 1014 06cc C701      		movw r24,r14
 1015 06ce B601      		movw r22,r12
 1016 06d0 2091 0000 		lds r18,Parameter+48
 1017 06d4 3091 0000 		lds r19,Parameter+48+1
 1018 06d8 4091 0000 		lds r20,Parameter+48+2
 1019 06dc 5091 0000 		lds r21,Parameter+48+3
 1020 06e0 0E94 0000 		call __ltsf2
 1021 06e4 87FD      		sbrc r24,7
 1022 06e6 00C0      		rjmp .L108
 1023               	.L97:
 302:thermalModel.c ****             } else if(isValidOverride(PID_state.setpoint,PID_state.controlScheme) == 0)
 1024               		.loc 1 302 0
 1025 06e8 8091 0000 		lds r24,PID_state+9
 1026 06ec 9091 0000 		lds r25,PID_state+9+1
 1027 06f0 6091 0000 		lds r22,PID_state+8
 1028 06f4 0E94 0000 		call isValidOverride
 1029 06f8 8823      		tst r24
 1030 06fa 01F0      		breq .+2
 1031 06fc 00C0      		rjmp .L44
 1032               	.L109:
 305:thermalModel.c ****                 protectionState = THERMAL_OVERLOAD;
 1033               		.loc 1 305 0
 1034 06fe 81E0      		ldi r24,lo8(1)
 1035 0700 8093 0000 		sts protectionState,r24
 306:thermalModel.c ****                 PIDPreset(CONTROL_SCHEME_POWER);
 1036               		.loc 1 306 0
 1037 0704 83E0      		ldi r24,lo8(3)
 1038 0706 00C0      		rjmp .L105
 1039               	.LVL60:
 1040               	.L48:
 311:thermalModel.c ****             estimatedWindingTemperature = updateTemperatureEsimate(newTemp, newCurrent);
 1041               		.loc 1 311 0
 1042 0708 0E94 0000 		call updateTemperatureEsimate
 1043               	.LVL61:
 1044 070c 6B01      		movw r12,r22
 1045 070e 7C01      		movw r14,r24
 1046               	.LVL62:
 312:thermalModel.c ****             if(getMotorDirection() == DIRECTION_STOP)
 1047               		.loc 1 312 0
 1048 0710 0E94 0000 		call getMotorDirection
 1049               	.LVL63:
 1050 0714 8823      		tst r24
 1051 0716 01F4      		brne .L73
 1052               	.L107:
 315:thermalModel.c ****                 protectionState = NORMAL_COOLDOWN;
 1053               		.loc 1 315 0
 1054 0718 83E0      		ldi r24,lo8(3)
 1055 071a 8093 0000 		sts protectionState,r24
 316:thermalModel.c ****                 cooldownTimeRemaining = Parameter[PARAMETER_OFF_TIME] * Parameter[PARAMETER_WINDING
 1056               		.loc 1 316 0
 1057 071e 6091 0000 		lds r22,Parameter+64
 1058 0722 7091 0000 		lds r23,Parameter+64+1
 1059 0726 8091 0000 		lds r24,Parameter+64+2
 1060 072a 9091 0000 		lds r25,Parameter+64+3
 1061 072e 2091 0000 		lds r18,Parameter+52
 1062 0732 3091 0000 		lds r19,Parameter+52+1
 1063 0736 4091 0000 		lds r20,Parameter+52+2
 1064 073a 5091 0000 		lds r21,Parameter+52+3
 1065 073e 0E94 0000 		call __mulsf3
 1066 0742 00C0      		rjmp .L104
 1067               	.L73:
 317:thermalModel.c ****             } else if(estimatedWindingTemperature >= Parameter[PARAMETER_T_MAX])
 1068               		.loc 1 317 0
 1069 0744 C701      		movw r24,r14
 1070 0746 B601      		movw r22,r12
 1071 0748 2091 0000 		lds r18,Parameter+56
 1072 074c 3091 0000 		lds r19,Parameter+56+1
 1073 0750 4091 0000 		lds r20,Parameter+56+2
 1074 0754 5091 0000 		lds r21,Parameter+56+3
 1075 0758 0E94 0000 		call __gesf2
 1076 075c 87FD      		sbrc r24,7
 1077 075e 00C0      		rjmp .L98
 1078               	.L106:
 319:thermalModel.c ****                 protectionState = MANDATORY_COOLDOWN;
 1079               		.loc 1 319 0
 1080 0760 84E0      		ldi r24,lo8(4)
 1081 0762 8093 0000 		sts protectionState,r24
 320:thermalModel.c ****                 cooldownTimeRemaining = Parameter[PARAMETER_OFF_TIME] * Parameter[PARAMETER_WINDING
 1082               		.loc 1 320 0
 1083 0766 6091 0000 		lds r22,Parameter+64
 1084 076a 7091 0000 		lds r23,Parameter+64+1
 1085 076e 8091 0000 		lds r24,Parameter+64+2
 1086 0772 9091 0000 		lds r25,Parameter+64+3
 1087 0776 2091 0000 		lds r18,Parameter+52
 1088 077a 3091 0000 		lds r19,Parameter+52+1
 1089 077e 4091 0000 		lds r20,Parameter+52+2
 1090 0782 5091 0000 		lds r21,Parameter+52+3
 1091 0786 0E94 0000 		call __mulsf3
 1092 078a DC01      		movw r26,r24
 1093 078c CB01      		movw r24,r22
 1094 078e 8093 0000 		sts cooldownTimeRemaining,r24
 1095 0792 9093 0000 		sts cooldownTimeRemaining+1,r25
 1096 0796 A093 0000 		sts cooldownTimeRemaining+2,r26
 1097 079a B093 0000 		sts cooldownTimeRemaining+3,r27
 321:thermalModel.c ****                 updateMotorDirection(DIRECTION_STOP);
 1098               		.loc 1 321 0
 1099 079e 80E0      		ldi r24,lo8(0)
 1100 07a0 0E94 0000 		call updateMotorDirection
 1101 07a4 00C0      		rjmp .L44
 1102               	.L98:
 322:thermalModel.c ****             } else if(estimatedWindingTemperature >= Parameter[PARAMETER_T_PLUS])
 1103               		.loc 1 322 0
 1104 07a6 C701      		movw r24,r14
 1105 07a8 B601      		movw r22,r12
 1106 07aa 2091 0000 		lds r18,Parameter+44
 1107 07ae 3091 0000 		lds r19,Parameter+44+1
 1108 07b2 4091 0000 		lds r20,Parameter+44+2
 1109 07b6 5091 0000 		lds r21,Parameter+44+3
 1110 07ba 0E94 0000 		call __gesf2
 1111 07be 87FD      		sbrc r24,7
 1112 07c0 00C0      		rjmp .L99
 325:thermalModel.c ****                 protectionState = THERMAL_OVERLOAD;
 1113               		.loc 1 325 0
 1114 07c2 81E0      		ldi r24,lo8(1)
 1115               	.LVL64:
 1116               	.L102:
 1117 07c4 8093 0000 		sts protectionState,r24
 1118 07c8 00C0      		rjmp .L44
 1119               	.LVL65:
 1120               	.L99:
 326:thermalModel.c ****             } else if(estimatedWindingTemperature < Parameter[PARAMETER_T_MINUS])
 1121               		.loc 1 326 0
 1122 07ca C701      		movw r24,r14
 1123 07cc B601      		movw r22,r12
 1124 07ce 2091 0000 		lds r18,Parameter+48
 1125 07d2 3091 0000 		lds r19,Parameter+48+1
 1126 07d6 4091 0000 		lds r20,Parameter+48+2
 1127 07da 5091 0000 		lds r21,Parameter+48+3
 1128 07de 0E94 0000 		call __ltsf2
 1129 07e2 87FF      		sbrs r24,7
 1130 07e4 00C0      		rjmp .L44
 1131               	.L108:
 329:thermalModel.c ****                 protectionState = NORMAL_OPERATION;
 1132               		.loc 1 329 0
 1133 07e6 1092 0000 		sts protectionState,__zero_reg__
 330:thermalModel.c ****                 PIDPreset(PID_state.controlScheme);
 1134               		.loc 1 330 0
 1135 07ea 8091 0000 		lds r24,PID_state+8
 1136               	.L105:
 1137 07ee 0E94 0000 		call PIDPreset
 1138 07f2 00C0      		rjmp .L44
 1139               	.LVL66:
 1140               	.L51:
 335:thermalModel.c ****             if(getMotorDirection() != DIRECTION_STOP)
 1141               		.loc 1 335 0
 1142 07f4 0E94 0000 		call getMotorDirection
 1143               	.LVL67:
 1144 07f8 8823      		tst r24
 1145 07fa 01F0      		breq .L44
 1146               	.L103:
 338:thermalModel.c ****                 protectionState = NORMAL_OPERATION;
 1147               		.loc 1 338 0
 1148 07fc 1092 0000 		sts protectionState,__zero_reg__
 1149               	.L44:
 1150               	/* epilogue start */
 345:thermalModel.c **** }
 1151               		.loc 1 345 0
 1152 0800 FF90      		pop r15
 1153 0802 EF90      		pop r14
 1154 0804 DF90      		pop r13
 1155 0806 CF90      		pop r12
 1156 0808 0895      		ret
 1157               		.cfi_endproc
 1158               	.LFE6:
 1160               	.global	Thermistor_VtoR
 1162               	Thermistor_VtoR:
 1163               	.LFB8:
 382:thermalModel.c **** 
 383:thermalModel.c **** 
 384:thermalModel.c **** 
 385:thermalModel.c **** /************************************************************************
 386:thermalModel.c **** * FUNCTION:    Thermistor_VtoR
 387:thermalModel.c **** *
 388:thermalModel.c **** * Description: Converts a thermistor voltage to a resistance.
 389:thermalModel.c **** *                Takes thermistor voltage, pullup voltage,
 390:thermalModel.c **** *                pullup fixed R inputs.
 391:thermalModel.c **** *                Vt = Vp * (Rt / (Rt + Rp))
 392:thermalModel.c **** *                -> Rt = (Vt*Rp)/(Vp - Vt)
 393:thermalModel.c **** ************************************************************************/
 394:thermalModel.c **** float Thermistor_VtoR(float ThermistorVoltage)
 395:thermalModel.c **** {
 1164               		.loc 1 395 0
 1165               		.cfi_startproc
 1166               	.LVL68:
 1167 080a CF92      		push r12
 1168               	.LCFI35:
 1169               		.cfi_def_cfa_offset 3
 1170               		.cfi_offset 12, -2
 1171 080c DF92      		push r13
 1172               	.LCFI36:
 1173               		.cfi_def_cfa_offset 4
 1174               		.cfi_offset 13, -3
 1175 080e EF92      		push r14
 1176               	.LCFI37:
 1177               		.cfi_def_cfa_offset 5
 1178               		.cfi_offset 14, -4
 1179 0810 FF92      		push r15
 1180               	.LCFI38:
 1181               		.cfi_def_cfa_offset 6
 1182               		.cfi_offset 15, -5
 1183 0812 0F93      		push r16
 1184               	.LCFI39:
 1185               		.cfi_def_cfa_offset 7
 1186               		.cfi_offset 16, -6
 1187 0814 1F93      		push r17
 1188               	.LCFI40:
 1189               		.cfi_def_cfa_offset 8
 1190               		.cfi_offset 17, -7
 1191 0816 CF93      		push r28
 1192               	.LCFI41:
 1193               		.cfi_def_cfa_offset 9
 1194               		.cfi_offset 28, -8
 1195 0818 DF93      		push r29
 1196               	.LCFI42:
 1197               		.cfi_def_cfa_offset 10
 1198               		.cfi_offset 29, -9
 1199               	/* prologue: function */
 1200               	/* frame size = 0 */
 1201               	/* stack size = 8 */
 1202               	.L__stack_usage = 8
 1203 081a 6B01      		movw r12,r22
 1204 081c 7C01      		movw r14,r24
 396:thermalModel.c ****     float ThermistorR;
 397:thermalModel.c **** 
 398:thermalModel.c ****     ThermistorR = ThermistorVoltage * THERMISTOR_FIXED_R;
 1205               		.loc 1 398 0
 1206 081e 20E0      		ldi r18,lo8(0x461c4000)
 1207 0820 30E4      		ldi r19,hi8(0x461c4000)
 1208 0822 4CE1      		ldi r20,hlo8(0x461c4000)
 1209 0824 56E4      		ldi r21,hhi8(0x461c4000)
 1210 0826 0E94 0000 		call __mulsf3
 1211               	.LVL69:
 1212 082a D62F      		mov r29,r22
 1213 082c C72F      		mov r28,r23
 1214 082e 182F      		mov r17,r24
 1215 0830 092F      		mov r16,r25
 1216               	.LVL70:
 399:thermalModel.c ****     ThermistorR /= (THERMISTOR_PULLUP_VOLTAGE - ThermistorVoltage);
 1217               		.loc 1 399 0
 1218 0832 60E0      		ldi r22,lo8(0x40200000)
 1219 0834 70E0      		ldi r23,hi8(0x40200000)
 1220 0836 80E2      		ldi r24,hlo8(0x40200000)
 1221 0838 90E4      		ldi r25,hhi8(0x40200000)
 1222               	.LVL71:
 1223 083a A701      		movw r20,r14
 1224 083c 9601      		movw r18,r12
 1225 083e 0E94 0000 		call __subsf3
 1226               	.LVL72:
 1227 0842 9B01      		movw r18,r22
 1228 0844 AC01      		movw r20,r24
 1229 0846 FE01      		movw r30,r28
 1230 0848 B801      		movw r22,r16
 1231 084a 8F2F      		mov r24,r31
 1232 084c 9E2F      		mov r25,r30
 1233 084e A72F      		mov r26,r23
 1234 0850 B62F      		mov r27,r22
 1235 0852 BC01      		movw r22,r24
 1236 0854 CD01      		movw r24,r26
 1237 0856 0E94 0000 		call __divsf3
 400:thermalModel.c **** 
 401:thermalModel.c ****     return ThermistorR;
 402:thermalModel.c **** 
 403:thermalModel.c **** }    // End of Thermistor_VtoR //
 1238               		.loc 1 403 0
 1239 085a 462F      		mov r20,r22
 1240 085c 572F      		mov r21,r23
 1241 085e 682F      		mov r22,r24
 1242 0860 792F      		mov r23,r25
 1243 0862 CB01      		movw r24,r22
 1244 0864 BA01      		movw r22,r20
 1245               	/* epilogue start */
 1246 0866 DF91      		pop r29
 1247               	.LVL73:
 1248 0868 CF91      		pop r28
 1249 086a 1F91      		pop r17
 1250 086c 0F91      		pop r16
 1251 086e FF90      		pop r15
 1252 0870 EF90      		pop r14
 1253 0872 DF90      		pop r13
 1254 0874 CF90      		pop r12
 1255               	.LVL74:
 1256 0876 0895      		ret
 1257               		.cfi_endproc
 1258               	.LFE8:
 1260               	.global	Thermistor_RtoT
 1262               	Thermistor_RtoT:
 1263               	.LFB9:
 404:thermalModel.c **** 
 405:thermalModel.c **** 
 406:thermalModel.c **** 
 407:thermalModel.c **** /************************************************************************
 408:thermalModel.c **** * FUNCTION:    Thermistor_RtoT
 409:thermalModel.c **** *
 410:thermalModel.c **** * Description: Converts a thermistor resistance to a temperature.
 411:thermalModel.c **** *                Takes measured thermistor resistance, nominal resistance,
 412:thermalModel.c **** *                nominal temperature, and thermistor B constant as inputs.
 413:thermalModel.c **** *                (1/T) = (1/Tnom) + (1/B)* ln(R/Rnom)
 414:thermalModel.c **** ************************************************************************/
 415:thermalModel.c **** float Thermistor_RtoT(float MeasR)
 416:thermalModel.c **** {
 1264               		.loc 1 416 0
 1265               		.cfi_startproc
 1266               	.LVL75:
 1267 0878 0F93      		push r16
 1268               	.LCFI43:
 1269               		.cfi_def_cfa_offset 3
 1270               		.cfi_offset 16, -2
 1271 087a 1F93      		push r17
 1272               	.LCFI44:
 1273               		.cfi_def_cfa_offset 4
 1274               		.cfi_offset 17, -3
 1275               	/* prologue: function */
 1276               	/* frame size = 0 */
 1277               	/* stack size = 2 */
 1278               	.L__stack_usage = 2
 417:thermalModel.c ****     float T;
 418:thermalModel.c **** 
 419:thermalModel.c ****     T = log(MeasR / THERMISTOR_NOMINAL_R);
 1279               		.loc 1 419 0
 1280 087c 20E0      		ldi r18,lo8(0x461c4000)
 1281 087e 30E4      		ldi r19,hi8(0x461c4000)
 1282 0880 4CE1      		ldi r20,hlo8(0x461c4000)
 1283 0882 56E4      		ldi r21,hhi8(0x461c4000)
 1284 0884 0E94 0000 		call __divsf3
 1285               	.LVL76:
 1286 0888 0E94 0000 		call log
 1287               	.LVL77:
 420:thermalModel.c ****     T *= (1/THERMISTOR_B);
 1288               		.loc 1 420 0
 1289 088c 26EF      		ldi r18,lo8(0x3983edf6)
 1290 088e 3DEE      		ldi r19,hi8(0x3983edf6)
 1291 0890 43E8      		ldi r20,hlo8(0x3983edf6)
 1292 0892 59E3      		ldi r21,hhi8(0x3983edf6)
 1293 0894 0E94 0000 		call __mulsf3
 1294               	.LVL78:
 421:thermalModel.c ****     T += (1/THERMISTOR_NOMINAL_T);
 1295               		.loc 1 421 0
 1296 0898 462F      		mov r20,r22
 1297 089a 572F      		mov r21,r23
 1298 089c 682F      		mov r22,r24
 1299               	.LVL79:
 1300 089e 792F      		mov r23,r25
 1301               	.LVL80:
 1302 08a0 CB01      		movw r24,r22
 1303 08a2 BA01      		movw r22,r20
 1304 08a4 2FE0      		ldi r18,lo8(0x3b5bcf0f)
 1305 08a6 3FEC      		ldi r19,hi8(0x3b5bcf0f)
 1306 08a8 4BE5      		ldi r20,hlo8(0x3b5bcf0f)
 1307 08aa 5BE3      		ldi r21,hhi8(0x3b5bcf0f)
 1308 08ac 0E94 0000 		call __addsf3
 1309               	.LVL81:
 1310 08b0 B62F      		mov r27,r22
 1311 08b2 A72F      		mov r26,r23
 1312 08b4 382F      		mov r19,r24
 1313 08b6 292F      		mov r18,r25
 1314               	.LVL82:
 422:thermalModel.c ****     T = (1/T);
 1315               		.loc 1 422 0
 1316 08b8 60E0      		ldi r22,lo8(0x3f800000)
 1317 08ba 70E0      		ldi r23,hi8(0x3f800000)
 1318 08bc 80E8      		ldi r24,hlo8(0x3f800000)
 1319 08be 9FE3      		ldi r25,hhi8(0x3f800000)
 1320               	.LVL83:
 1321 08c0 FD01      		movw r30,r26
 1322 08c2 A901      		movw r20,r18
 1323 08c4 0F2F      		mov r16,r31
 1324 08c6 1E2F      		mov r17,r30
 1325 08c8 252F      		mov r18,r21
 1326 08ca 342F      		mov r19,r20
 1327 08cc A901      		movw r20,r18
 1328 08ce 9801      		movw r18,r16
 1329 08d0 0E94 0000 		call __divsf3
 1330               	.LVL84:
 423:thermalModel.c ****     T -= 273.15;         //Convert from K to C
 1331               		.loc 1 423 0
 1332 08d4 462F      		mov r20,r22
 1333 08d6 572F      		mov r21,r23
 1334 08d8 682F      		mov r22,r24
 1335               	.LVL85:
 1336 08da 792F      		mov r23,r25
 1337               	.LVL86:
 1338 08dc CB01      		movw r24,r22
 1339 08de BA01      		movw r22,r20
 1340 08e0 23E3      		ldi r18,lo8(0x43889333)
 1341 08e2 33E9      		ldi r19,hi8(0x43889333)
 1342 08e4 48E8      		ldi r20,hlo8(0x43889333)
 1343 08e6 53E4      		ldi r21,hhi8(0x43889333)
 1344 08e8 0E94 0000 		call __subsf3
 1345               	.LVL87:
 424:thermalModel.c **** 
 425:thermalModel.c ****     return T;
 426:thermalModel.c **** 
 427:thermalModel.c **** }    // End of Thermistor_RtoT //
 1346               		.loc 1 427 0
 1347 08ec 462F      		mov r20,r22
 1348 08ee 572F      		mov r21,r23
 1349 08f0 682F      		mov r22,r24
 1350 08f2 792F      		mov r23,r25
 1351 08f4 CB01      		movw r24,r22
 1352 08f6 BA01      		movw r22,r20
 1353               	/* epilogue start */
 1354 08f8 1F91      		pop r17
 1355 08fa 0F91      		pop r16
 1356 08fc 0895      		ret
 1357               		.cfi_endproc
 1358               	.LFE9:
 1360               	.global	realWindingResistance
 1361               		.data
 1364               	realWindingResistance:
 1365 0000 CD        		.byte	-51
 1366 0001 CC        		.byte	-52
 1367 0002 E4        		.byte	-28
 1368 0003 41        		.byte	65
 1369               	.global	oldDeltaT
 1370               	.global	oldDeltaT
 1371               		.section .bss
 1374               	oldDeltaT:
 1375 0000 0000 0000 		.skip 4,0
 1376               		.data
 1379               	protectionState:
 1380 0004 04        		.byte	4
 1381               		.lcomm cooldownTimeRemaining,4
 1382               		.text
 1383               	.Letext0:
 1384               		.file 2 "/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../av
 1385               		.file 3 "hallctrl.h"
 1386               		.file 4 "PIDcontroller.h"
 1387               		.file 5 "motor.h"
 1388               		.file 6 "thermalModel.h"
 1389               		.file 7 "currentADC.h"
 1390               		.file 8 "velcounter.h"
DEFINED SYMBOLS
                            *ABS*:00000000 thermalModel.c
     /tmp/ccg35s43.s:2      *ABS*:0000003f __SREG__
     /tmp/ccg35s43.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccg35s43.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccg35s43.s:5      *ABS*:00000034 __CCP__
     /tmp/ccg35s43.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccg35s43.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccg35s43.s:14     .text:00000000 updateTemperatureEsimate
     /tmp/ccg35s43.s:1374   .bss:00000000 oldDeltaT
     /tmp/ccg35s43.s:1364   .data:00000000 realWindingResistance
     /tmp/ccg35s43.s:329    .text:00000244 isValidOverride
     /tmp/ccg35s43.s:524    .text:0000039c thermalCheckSetpoint
     /tmp/ccg35s43.s:1379   .data:00000004 protectionState
     /tmp/ccg35s43.s:646    .text:00000458 getWindingResistance
     /tmp/ccg35s43.s:672    .text:00000476 getPowerSetpoint
     /tmp/ccg35s43.s:773    .text:0000050c updateThermalModel
                             .bss:00000004 cooldownTimeRemaining
     /tmp/ccg35s43.s:1162   .text:0000080a Thermistor_VtoR
     /tmp/ccg35s43.s:1262   .text:00000878 Thermistor_RtoT

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__addsf3
__subsf3
Parameter
__mulsf3
__divsf3
exp
__unordsf2
__gtsf2
__ltsf2
statorTemperature
sqrt
__floatunsisf
motorCurrent
__lesf2
averageRPM
PIDPreset
getMotorDirection
__gesf2
PID_state
updateMotorDirection
log
