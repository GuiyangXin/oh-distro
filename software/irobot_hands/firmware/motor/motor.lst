   1               		.file	"motor.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  14               	ReadIntFromEEPROM:
  15               	.LFB13:
  16               		.file 1 "motor.c"
   1:motor.c       **** /****************************************************
   2:motor.c       **** 
   3:motor.c       ****  // Author:            Paul Butler
   4:motor.c       ****  // File Name:        C1482-SRC-FGRMCU-0.c
   5:motor.c       ****  // Creation Date:    18 October, 2011
   6:motor.c       ****  // Revision:        04
   7:motor.c       ****  // Hardware:        ATxmega32A4
   8:motor.c       ****  // Description:    Palm Motor Controller Micro Top Level Implementation
   9:motor.c       **** 
  10:motor.c       ****  ****************************************************/
  11:motor.c       **** 
  12:motor.c       **** /******************************************************************************
  13:motor.c       ****     Project Build Summary:
  14:motor.c       **** -------------------------------------------------------------------------------
  15:motor.c       **** Source File                                Cur. Rev. Level        Prev. Rev. Level
  16:motor.c       **** --------------------------------        ----------------    ----------------
  17:motor.c       **** C1482-SRC-FGRMCU-0.c                    04                    03
  18:motor.c       **** C1482-SRC-FGRMCU-0.h                    03                    02
  19:motor.c       **** C1482-SRC-FGRMCU-0-currentADC.c            01                    00
  20:motor.c       **** C1482-SRC-FGRMCU-0-currentADC.h            00                    N/A
  21:motor.c       **** C1482-SRC-FGRMCU-0-hallctrl.c            00                    N/A
  22:motor.c       **** C1482-SRC-FGRMCU-0-hallctrl.h            00                    N/A
  23:motor.c       **** C1482-SRC-FGRMCU-0-PIDcontroller.c        02                    01
  24:motor.c       **** C1482-SRC-FGRMCU-0-PIDcontroller.h        02                    01
  25:motor.c       **** C1482-SRC-FGRMCU-0-thermalModel.c        02                    01
  26:motor.c       **** C1482-SRC-FGRMCU-0-thermalModel.h        01                    00
  27:motor.c       **** C1482-SRC-FGRMCU-0-USART.c                00                    N/A
  28:motor.c       **** C1482-SRC-FGRMCU-0-USART.h                01                    00
  29:motor.c       **** C1482-SRC-FGRMCU-0-velcounter.c            01                    00
  30:motor.c       **** C1482-SRC-FGRMCU-0-velcounter.h            01                    00
  31:motor.c       **** 
  32:motor.c       **** -------------------------------------------------------------------------------
  33:motor.c       **** 
  34:motor.c       ****     Project Revision History:
  35:motor.c       **** -------------------------------------------------------------------------------
  36:motor.c       **** Revision    Date        Engineer    Description
  37:motor.c       **** --------    --------    --------    -------------------------------------------
  38:motor.c       **** 00            10/18/11    PDB            Initial Release
  39:motor.c       ****                                     (Started from "ARMH Roadkill.avrgccproj")
  40:motor.c       **** 01            12/15/11    ZAC            Added support for parametrized MAX RPM
  41:motor.c       ****                                     Added extra debug output for motor case temp
  42:motor.c       **** 02            12/20/11    ZAC            Added velocity override functionality
  43:motor.c       ****                                     Improved PID loop processing
  44:motor.c       **** 03            1/5/12        ZAC            Fixed case temperature output
  45:motor.c       ****                                     Added slack around velocity override function
  46:motor.c       **** 04            01/16/12    ZAC            Added MAXIMUM_COMMAND parameter and bounds checking
  47:motor.c       **** 05            03/12/12    ZAC            Rewrite of USART code to match new protocol.
  48:motor.c       **** -------------------------------------------------------------------------------
  49:motor.c       **** 
  50:motor.c       ****     File Revision History:
  51:motor.c       **** -------------------------------------------------------------------------------
  52:motor.c       **** Revision    Date        Engineer    Description
  53:motor.c       **** --------    --------    --------    -------------------------------------------
  54:motor.c       **** 00            10/18/11    PDB            Initial Release
  55:motor.c       ****                                     (Started from "ARMH Roadkill.c")
  56:motor.c       **** 01            12/15/11    ZAC            Added MAX RPM to command parser
  57:motor.c       ****                                     Added debug output for motor case temp
  58:motor.c       **** 02            12/20/11    ZAC            Added preset to command parser and SPEED CONSTANT
  59:motor.c       **** 03            01/05/12    ZAC            Fixed case temperature output
  60:motor.c       **** 04            01/16/12    ZAC            Added parameter for MAXIMUM_COMMAND
  61:motor.c       **** -------------------------------------------------------------------------------
  62:motor.c       **** 
  63:motor.c       **** 
  64:motor.c       ****     Firmware Revision History:
  65:motor.c       **** -------------------------------------------------------------------------------
  66:motor.c       **** Revision    Date        Engineer    Description
  67:motor.c       **** --------    --------    --------    -------------------------------------------
  68:motor.c       **** 100         2012-11-08  BA          Initial version
  69:motor.c       **** 101         2012-12-03  BA          Fix motor and encoder directions, fix bug in thermal model
  70:motor.c       **** 102         2013-02-20  BA          Remove LED toggle in main loop
  71:motor.c       **** 
  72:motor.c       **** ******************************************************************************/
  73:motor.c       **** 
  74:motor.c       **** #include "motor.h"
  75:motor.c       **** #include "velcounter.h"
  76:motor.c       **** #include "currentADC.h"
  77:motor.c       **** #include "hallctrl.h"
  78:motor.c       **** #include "PIDcontroller.h"
  79:motor.c       **** #include "thermalModel.h"
  80:motor.c       **** #include "../common/daisycomm.h"
  81:motor.c       **** #include "daisyconfig.h"
  82:motor.c       **** 
  83:motor.c       **** #include <avr/io.h>
  84:motor.c       **** #include <avr/interrupt.h>
  85:motor.c       **** #include <avr/eeprom.h>
  86:motor.c       **** #include <math.h>
  87:motor.c       **** #include <string.h>
  88:motor.c       **** #include <util/delay.h>
  89:motor.c       **** #include <avr/wdt.h>
  90:motor.c       **** 
  91:motor.c       **** #define FIRMWARE_VERSION 300
  92:motor.c       **** 
  93:motor.c       **** //Global variables
  94:motor.c       **** //int isThumb;
  95:motor.c       **** float Parameter[INT_PARAMETER_START];
  96:motor.c       **** 
  97:motor.c       **** //Private Functions
  98:motor.c       **** static void configureClocks(void);
  99:motor.c       **** //static void detectFingerThumb(void);
 100:motor.c       **** static float convertArrayToFloat(uint8_t *packedInteger);
 101:motor.c       **** static void convertFloatToArray(float inputFloat, uint8_t *outputArray);
 102:motor.c       **** static void WriteIntToEEPROM(uint8_t address, uint8_t* value);
 103:motor.c       **** static void ReadIntFromEEPROM(uint8_t address, uint8_t* destination);
 104:motor.c       **** static void verifyVersion(void);
 105:motor.c       **** static void initStateFromEEPROM(void);
 106:motor.c       **** 
 107:motor.c       **** //Private variables
 108:motor.c       **** // #ifdef USE_FAULT_PIN
 109:motor.c       **** // static uint8_t faultCounter = 0;
 110:motor.c       **** // #endif
 111:motor.c       **** 
 112:motor.c       **** /************************************************************************
 113:motor.c       ****  * Debug macros to control a line for viewing with an oscilloscope and
 114:motor.c       ****  * benchmarking the CPU load
 115:motor.c       ****  ************************************************************************/
 116:motor.c       **** #define ASSERT_DEBUG_LINE() PORTB.OUTSET = 0x04
 117:motor.c       **** #define DEASSERT_DEBUG_LINE() PORTB.OUTCLR = 0x04
 118:motor.c       **** 
 119:motor.c       **** /******************************************************************************
 120:motor.c       ****  * Interrupt service routines
 121:motor.c       ****  *******************************************************************************/
 122:motor.c       **** 
 123:motor.c       **** /************************************************************************
 124:motor.c       ****  * The timer tick interrupt.
 125:motor.c       ****  * this fires every 5 ms to increment a USART timeout register and signal the
 126:motor.c       ****  * PID control loop to fire in a non-interrupt context
 127:motor.c       ****  *************************************************************************/
 128:motor.c       **** ISR(CONTROL_TIMER_vect)
 129:motor.c       **** {
 130:motor.c       ****     cli();
 131:motor.c       ****     PID_runPID = 1;
 132:motor.c       **** // #ifdef USE_FAULT_PIN
 133:motor.c       **** //     if((MOTOR1FAULTPORT.IN & (1 << MOTOR1_FAULT_PIN)) == 0 ||
 134:motor.c       **** //        (MOTOR1OTWPORT.IN & (1 << MOTOR1_OTW_PIN)) == 0)
 135:motor.c       **** //     {
 136:motor.c       **** //         if (faultCounter == FAULT_TIMEOUT_COUNT)
 137:motor.c       **** //         {
 138:motor.c       **** //             resetPIDController(0);
 139:motor.c       **** //             updateMotorDirection(DIRECTION_STOP);
 140:motor.c       **** //             updateMotorVoltage(0x00);
 141:motor.c       **** //             updateMotor(); //forceMotorUpdate();
 142:motor.c       **** //             faultCounter = 0;
 143:motor.c       **** //         } else {
 144:motor.c       **** //             faultCounter++;
 145:motor.c       **** //         }
 146:motor.c       **** //     } else {
 147:motor.c       **** //         faultCounter = 0;
 148:motor.c       **** //     }
 149:motor.c       **** // #endif
 150:motor.c       **** }
 151:motor.c       **** 
 152:motor.c       **** /************************************************************************
 153:motor.c       ****  * Private function definitions
 154:motor.c       ****  ************************************************************************/
 155:motor.c       **** 
 156:motor.c       **** /************************************************************************
 157:motor.c       ****  * configureClocks()
 158:motor.c       ****  *
 159:motor.c       ****  * Configure system clocks
 160:motor.c       ****  * The RTC is being used to generate PID ticks, so ensure that the 32 kHz oscillator
 161:motor.c       ****  * is running.  This will feed a 1.024 kHz clock to the RTC.
 162:motor.c       ****  * The system clock will use the onboard 32MHz oscillator
 163:motor.c       ****  ************************************************************************/
 164:motor.c       **** static void configureClocks(void)
 165:motor.c       **** {
 166:motor.c       ****     OSC.CTRL = OSC_RC32MEN_bm | OSC_RC32KEN_bm;            //enable the 32MHz ring oscillator and t
 167:motor.c       ****     while(!(OSC.STATUS & OSC_RC32MRDY_bm));                //wait for 32MHz to stabilize
 168:motor.c       ****     while(!(OSC.STATUS & OSC_RC32KRDY_bm));                //wait for 32kHz to stabilize
 169:motor.c       **** 
 170:motor.c       ****     DFLLRC32M.CTRL = DFLL_ENABLE_bm;
 171:motor.c       ****     DFLLRC2M.CTRL = DFLL_ENABLE_bm;
 172:motor.c       **** 
 173:motor.c       ****     CCP = CCP_IOREG_gc;                                    //clock is protected by Configuration Ch
 174:motor.c       ****     CLK.CTRL = CLK_SCLKSEL_RC32M_gc;                    //switch to 32MHz oscillator
 175:motor.c       ****     CLK.RTCCTRL = CLK_RTCSRC_RCOSC_gc | CLK_RTCEN_bm;    //Select 1.024 kHz from internal oscillato
 176:motor.c       **** }
 177:motor.c       **** 
 178:motor.c       **** // /************************************************************************
 179:motor.c       **** // * detectFingerThumb()
 180:motor.c       **** // * Sets the global variable isThumb to 1 if this is the Thumb and 0 if
 181:motor.c       **** // * this is the Finger
 182:motor.c       **** // ************************************************************************/
 183:motor.c       **** // static void detectFingerThumb(void)
 184:motor.c       **** // {
 185:motor.c       **** //     PORTR.DIR = 0x00;
 186:motor.c       **** //     isThumb = ((PORTR.IN & 0x01) ? 1 : 0);
 187:motor.c       **** // }
 188:motor.c       **** 
 189:motor.c       **** /************************************************************************
 190:motor.c       ****  * convertArrayToFloat(int *packedInteger)
 191:motor.c       ****  *
 192:motor.c       ****  * Blindly assumes that packedInteger is really a pointer to a float.
 193:motor.c       ****  * This is broken out as a function in case more complex manipulation is
 194:motor.c       ****  * required for potential other host architectures.
 195:motor.c       ****  *
 196:motor.c       ****  * Currently only used in USART communication with a host PC or other
 197:motor.c       ****  * micro.
 198:motor.c       ****  ************************************************************************/
 199:motor.c       **** static float convertArrayToFloat(uint8_t *packedInteger)
 200:motor.c       **** {
 201:motor.c       ****     return *(float *)packedInteger;
 202:motor.c       **** }
 203:motor.c       **** 
 204:motor.c       **** /************************************************************************
 205:motor.c       ****  * convertArrayToFloat(float inputFloat, uint8_t *outputArray)
 206:motor.c       ****  *
 207:motor.c       ****  * Blindly places the bytes from inputFloat into outputArray.
 208:motor.c       ****  * This is broken out as a function in case more complex manipulation is
 209:motor.c       ****  * required for potential other host architectures.
 210:motor.c       ****  ************************************************************************/
 211:motor.c       **** static void convertFloatToArray(float inputFloat, uint8_t *outputArray)
 212:motor.c       **** {
 213:motor.c       ****     memcpy(outputArray,&inputFloat,4);
 214:motor.c       ****     return;
 215:motor.c       **** }
 216:motor.c       **** 
 217:motor.c       **** static void initStateFromEEPROM(void)
 218:motor.c       **** {
 219:motor.c       ****     uint32_t zero_check = 0;
 220:motor.c       ****     ReadIntFromEEPROM(EEPROM_ADDRESS_LED, (uint8_t*)&zero_check);
 221:motor.c       ****     
 222:motor.c       ****     if(zero_check)
 223:motor.c       ****         LEDon();
 224:motor.c       ****     else
 225:motor.c       ****         LEDoff();
 226:motor.c       **** }
 227:motor.c       **** 
 228:motor.c       **** 
 229:motor.c       **** void WriteFloatToEEPROM(uint8_t address, float val)
 230:motor.c       **** {
 231:motor.c       ****     // Write to EEPROM
 232:motor.c       ****     uint32_t data;
 233:motor.c       ****     memcpy(&data,&val,4);
 234:motor.c       ****     // little endian
 235:motor.c       ****     eeprom_write_byte((uint8_t *) (address*4+0), data & 0xff);
 236:motor.c       ****     data >>= 8;
 237:motor.c       ****     eeprom_write_byte((uint8_t *) (address*4+1), data & 0xff);
 238:motor.c       ****     data >>= 8;
 239:motor.c       ****     eeprom_write_byte((uint8_t *) (address*4+2), data & 0xff);
 240:motor.c       ****     data >>= 8;
 241:motor.c       ****     eeprom_write_byte((uint8_t *) (address*4+3), data & 0xff);
 242:motor.c       **** }
 243:motor.c       **** 
 244:motor.c       **** static void WriteIntToEEPROM(uint8_t address, uint8_t* value)
 245:motor.c       **** {
 246:motor.c       ****     for(uint8_t i=0; i<4; i++)
 247:motor.c       ****         eeprom_write_byte((uint8_t *) (address*4+i), *(value+i));
 248:motor.c       **** }
 249:motor.c       **** 
 250:motor.c       **** static void ReadIntFromEEPROM(uint8_t address, uint8_t* destination)
 251:motor.c       **** {
  17               		.loc 1 251 0
  18               		.cfi_startproc
  19               	.LVL0:
  20 0000 EF92      		push r14
  21               	.LCFI0:
  22               		.cfi_def_cfa_offset 3
  23               		.cfi_offset 14, -2
  24 0002 FF92      		push r15
  25               	.LCFI1:
  26               		.cfi_def_cfa_offset 4
  27               		.cfi_offset 15, -3
  28 0004 0F93      		push r16
  29               	.LCFI2:
  30               		.cfi_def_cfa_offset 5
  31               		.cfi_offset 16, -4
  32 0006 1F93      		push r17
  33               	.LCFI3:
  34               		.cfi_def_cfa_offset 6
  35               		.cfi_offset 17, -5
  36 0008 CF93      		push r28
  37               	.LCFI4:
  38               		.cfi_def_cfa_offset 7
  39               		.cfi_offset 28, -6
  40 000a DF93      		push r29
  41               	.LCFI5:
  42               		.cfi_def_cfa_offset 8
  43               		.cfi_offset 29, -7
  44 000c 0F92      		push __tmp_reg__
  45               	.LCFI6:
  46               		.cfi_def_cfa_offset 9
  47 000e CDB7      		in r28,__SP_L__
  48 0010 DEB7      		in r29,__SP_H__
  49               	.LCFI7:
  50               		.cfi_def_cfa_register 28
  51               	/* prologue: function */
  52               	/* frame size = 1 */
  53               	/* stack size = 7 */
  54               	.L__stack_usage = 7
  55               	.LVL1:
  56               	.LBB41:
 252:motor.c       ****     for(uint8_t i=0; i<4;i++)
 253:motor.c       ****         *(destination+i) = eeprom_read_byte((uint8_t *) (address*4+i));
  57               		.loc 1 253 0
  58 0012 E82E      		mov r14,r24
  59 0014 FF24      		clr r15
  60 0016 EE0C      		lsl r14
  61 0018 FF1C      		rol r15
  62 001a EE0C      		lsl r14
  63 001c FF1C      		rol r15
  64               	.LVL2:
  65 001e 8B01      		movw r16,r22
 252:motor.c       ****     for(uint8_t i=0; i<4;i++)
  66               		.loc 1 252 0
  67 0020 20E0      		ldi r18,lo8(0)
  68               	.LVL3:
  69               	.L2:
  70               		.loc 1 253 0 discriminator 2
  71 0022 C701      		movw r24,r14
  72 0024 2983      		std Y+1,r18
  73 0026 0E94 0000 		call __eerd_byte_x32a4u
  74 002a F801      		movw r30,r16
  75 002c 8193      		st Z+,r24
  76 002e 8F01      		movw r16,r30
 252:motor.c       ****     for(uint8_t i=0; i<4;i++)
  77               		.loc 1 252 0 discriminator 2
  78 0030 2981      		ldd r18,Y+1
  79 0032 2F5F      		subi r18,lo8(-(1))
  80               	.LVL4:
  81 0034 0894      		sec
  82 0036 E11C      		adc r14,__zero_reg__
  83 0038 F11C      		adc r15,__zero_reg__
  84 003a 2430      		cpi r18,lo8(4)
  85 003c 01F4      		brne .L2
  86               	/* epilogue start */
  87               	.LBE41:
 254:motor.c       **** }
  88               		.loc 1 254 0
  89 003e 0F90      		pop __tmp_reg__
  90 0040 DF91      		pop r29
  91 0042 CF91      		pop r28
  92 0044 1F91      		pop r17
  93 0046 0F91      		pop r16
  94 0048 FF90      		pop r15
  95 004a EF90      		pop r14
  96 004c 0895      		ret
  97               		.cfi_endproc
  98               	.LFE13:
 101               	WriteIntToEEPROM:
 102               	.LFB12:
 245:motor.c       **** {
 103               		.loc 1 245 0
 104               		.cfi_startproc
 105               	.LVL5:
 106 004e EF92      		push r14
 107               	.LCFI8:
 108               		.cfi_def_cfa_offset 3
 109               		.cfi_offset 14, -2
 110 0050 FF92      		push r15
 111               	.LCFI9:
 112               		.cfi_def_cfa_offset 4
 113               		.cfi_offset 15, -3
 114 0052 0F93      		push r16
 115               	.LCFI10:
 116               		.cfi_def_cfa_offset 5
 117               		.cfi_offset 16, -4
 118 0054 1F93      		push r17
 119               	.LCFI11:
 120               		.cfi_def_cfa_offset 6
 121               		.cfi_offset 17, -5
 122 0056 CF93      		push r28
 123               	.LCFI12:
 124               		.cfi_def_cfa_offset 7
 125               		.cfi_offset 28, -6
 126 0058 DF93      		push r29
 127               	.LCFI13:
 128               		.cfi_def_cfa_offset 8
 129               		.cfi_offset 29, -7
 130 005a 0F92      		push __tmp_reg__
 131               	.LCFI14:
 132               		.cfi_def_cfa_offset 9
 133 005c CDB7      		in r28,__SP_L__
 134 005e DEB7      		in r29,__SP_H__
 135               	.LCFI15:
 136               		.cfi_def_cfa_register 28
 137               	/* prologue: function */
 138               	/* frame size = 1 */
 139               	/* stack size = 7 */
 140               	.L__stack_usage = 7
 141               	.LVL6:
 142               	.LBB42:
 247:motor.c       ****         eeprom_write_byte((uint8_t *) (address*4+i), *(value+i));
 143               		.loc 1 247 0
 144 0060 8B01      		movw r16,r22
 145 0062 E82E      		mov r14,r24
 146 0064 FF24      		clr r15
 147 0066 EE0C      		lsl r14
 148 0068 FF1C      		rol r15
 149 006a EE0C      		lsl r14
 150 006c FF1C      		rol r15
 246:motor.c       ****     for(uint8_t i=0; i<4; i++)
 151               		.loc 1 246 0
 152 006e 20E0      		ldi r18,lo8(0)
 153               	.LVL7:
 154               	.L5:
 247:motor.c       ****         eeprom_write_byte((uint8_t *) (address*4+i), *(value+i));
 155               		.loc 1 247 0 discriminator 2
 156 0070 F801      		movw r30,r16
 157 0072 6191      		ld r22,Z+
 158 0074 8F01      		movw r16,r30
 159 0076 C701      		movw r24,r14
 160 0078 2983      		std Y+1,r18
 161 007a 0E94 0000 		call __eewr_byte_x32a4u
 246:motor.c       ****     for(uint8_t i=0; i<4; i++)
 162               		.loc 1 246 0 discriminator 2
 163 007e 2981      		ldd r18,Y+1
 164 0080 2F5F      		subi r18,lo8(-(1))
 165               	.LVL8:
 166 0082 0894      		sec
 167 0084 E11C      		adc r14,__zero_reg__
 168 0086 F11C      		adc r15,__zero_reg__
 169 0088 2430      		cpi r18,lo8(4)
 170 008a 01F4      		brne .L5
 171               	/* epilogue start */
 172               	.LBE42:
 248:motor.c       **** }
 173               		.loc 1 248 0
 174 008c 0F90      		pop __tmp_reg__
 175 008e DF91      		pop r29
 176 0090 CF91      		pop r28
 177 0092 1F91      		pop r17
 178 0094 0F91      		pop r16
 179 0096 FF90      		pop r15
 180 0098 EF90      		pop r14
 181 009a 0895      		ret
 182               		.cfi_endproc
 183               	.LFE12:
 185               	.global	__vector_10
 187               	__vector_10:
 188               	.LFB6:
 129:motor.c       **** {
 189               		.loc 1 129 0
 190               		.cfi_startproc
 191 009c 1F92      		push r1
 192               	.LCFI16:
 193               		.cfi_def_cfa_offset 3
 194               		.cfi_offset 1, -2
 195 009e 0F92      		push r0
 196               	.LCFI17:
 197               		.cfi_def_cfa_offset 4
 198               		.cfi_offset 0, -3
 199 00a0 0FB6      		in r0,__SREG__
 200 00a2 0F92      		push r0
 201 00a4 1124      		clr __zero_reg__
 202 00a6 8F93      		push r24
 203               	.LCFI18:
 204               		.cfi_def_cfa_offset 5
 205               		.cfi_offset 24, -4
 206               	/* prologue: Signal */
 207               	/* frame size = 0 */
 208               	/* stack size = 4 */
 209               	.L__stack_usage = 4
 130:motor.c       ****     cli();
 210               		.loc 1 130 0
 211               	/* #APP */
 212               	 ;  130 "motor.c" 1
 213 00a8 F894      		cli
 214               	 ;  0 "" 2
 131:motor.c       ****     PID_runPID = 1;
 215               		.loc 1 131 0
 216               	/* #NOAPP */
 217 00aa 81E0      		ldi r24,lo8(1)
 218 00ac 8093 0000 		sts PID_runPID,r24
 219               	/* epilogue start */
 150:motor.c       **** }
 220               		.loc 1 150 0
 221 00b0 8F91      		pop r24
 222 00b2 0F90      		pop r0
 223 00b4 0FBE      		out __SREG__,r0
 224 00b6 0F90      		pop r0
 225 00b8 1F90      		pop r1
 226 00ba 1895      		reti
 227               		.cfi_endproc
 228               	.LFE6:
 230               	.global	WriteFloatToEEPROM
 232               	WriteFloatToEEPROM:
 233               	.LFB11:
 230:motor.c       **** {
 234               		.loc 1 230 0
 235               		.cfi_startproc
 236               	.LVL9:
 237 00bc CF92      		push r12
 238               	.LCFI19:
 239               		.cfi_def_cfa_offset 3
 240               		.cfi_offset 12, -2
 241 00be DF92      		push r13
 242               	.LCFI20:
 243               		.cfi_def_cfa_offset 4
 244               		.cfi_offset 13, -3
 245 00c0 EF92      		push r14
 246               	.LCFI21:
 247               		.cfi_def_cfa_offset 5
 248               		.cfi_offset 14, -4
 249 00c2 FF92      		push r15
 250               	.LCFI22:
 251               		.cfi_def_cfa_offset 6
 252               		.cfi_offset 15, -5
 253 00c4 CF93      		push r28
 254               	.LCFI23:
 255               		.cfi_def_cfa_offset 7
 256               		.cfi_offset 28, -6
 257 00c6 DF93      		push r29
 258               	.LCFI24:
 259               		.cfi_def_cfa_offset 8
 260               		.cfi_offset 29, -7
 261               	/* prologue: function */
 262               	/* frame size = 0 */
 263               	/* stack size = 6 */
 264               	.L__stack_usage = 6
 233:motor.c       ****     memcpy(&data,&val,4);
 265               		.loc 1 233 0
 266 00c8 6A01      		movw r12,r20
 267 00ca 7B01      		movw r14,r22
 268               	.LVL10:
 235:motor.c       ****     eeprom_write_byte((uint8_t *) (address*4+0), data & 0xff);
 269               		.loc 1 235 0
 270 00cc C82F      		mov r28,r24
 271 00ce D0E0      		ldi r29,lo8(0)
 272 00d0 CC0F      		lsl r28
 273 00d2 DD1F      		rol r29
 274 00d4 CC0F      		lsl r28
 275 00d6 DD1F      		rol r29
 276 00d8 CE01      		movw r24,r28
 277               	.LVL11:
 278 00da 642F      		mov r22,r20
 279 00dc 0E94 0000 		call __eewr_byte_x32a4u
 280               	.LVL12:
 236:motor.c       ****     data >>= 8;
 281               		.loc 1 236 0
 282 00e0 7727      		clr r23
 283 00e2 6F2D      		mov r22,r15
 284 00e4 5E2D      		mov r21,r14
 285 00e6 4D2D      		mov r20,r13
 286               	.LVL13:
 237:motor.c       ****     eeprom_write_byte((uint8_t *) (address*4+1), data & 0xff);
 287               		.loc 1 237 0
 288 00e8 CE01      		movw r24,r28
 289 00ea 0196      		adiw r24,1
 290 00ec 642F      		mov r22,r20
 291 00ee 0E94 0000 		call __eewr_byte_x32a4u
 238:motor.c       ****     data >>= 8;
 292               		.loc 1 238 0
 293 00f2 A701      		movw r20,r14
 294 00f4 6627      		clr r22
 295 00f6 7727      		clr r23
 239:motor.c       ****     eeprom_write_byte((uint8_t *) (address*4+2), data & 0xff);
 296               		.loc 1 239 0
 297 00f8 CE01      		movw r24,r28
 298 00fa 0296      		adiw r24,2
 299 00fc 642F      		mov r22,r20
 300 00fe 0E94 0000 		call __eewr_byte_x32a4u
 240:motor.c       ****     data >>= 8;
 301               		.loc 1 240 0
 302 0102 CF2C      		mov r12,r15
 303 0104 DD24      		clr r13
 304 0106 EE24      		clr r14
 305 0108 FF24      		clr r15
 241:motor.c       ****     eeprom_write_byte((uint8_t *) (address*4+3), data & 0xff);
 306               		.loc 1 241 0
 307 010a CE01      		movw r24,r28
 308 010c 0396      		adiw r24,3
 309 010e 6C2D      		mov r22,r12
 310 0110 0E94 0000 		call __eewr_byte_x32a4u
 311               	/* epilogue start */
 242:motor.c       **** }
 312               		.loc 1 242 0
 313 0114 DF91      		pop r29
 314 0116 CF91      		pop r28
 315 0118 FF90      		pop r15
 316 011a EF90      		pop r14
 317 011c DF90      		pop r13
 318 011e CF90      		pop r12
 319 0120 0895      		ret
 320               		.cfi_endproc
 321               	.LFE11:
 323               	.global	initializeEEPROM
 325               	initializeEEPROM:
 326               	.LFB15:
 255:motor.c       **** 
 256:motor.c       **** static void verifyVersion()
 257:motor.c       **** {
 258:motor.c       ****     uint32_t readversion = 0;
 259:motor.c       ****     ReadIntFromEEPROM(EEPROM_ADDRESS_FIRMWARE_VERSION, (uint8_t*)&readversion);
 260:motor.c       ****     if (readversion != FIRMWARE_VERSION)
 261:motor.c       ****     {
 262:motor.c       ****         readversion = FIRMWARE_VERSION;
 263:motor.c       ****         WriteIntToEEPROM(EEPROM_ADDRESS_FIRMWARE_VERSION, (uint8_t*)&readversion);
 264:motor.c       ****     }
 265:motor.c       **** }
 266:motor.c       **** 
 267:motor.c       **** void initializeEEPROM(void)
 268:motor.c       **** {
 327               		.loc 1 268 0
 328               		.cfi_startproc
 329 0122 1F93      		push r17
 330               	.LCFI25:
 331               		.cfi_def_cfa_offset 3
 332               		.cfi_offset 17, -2
 333 0124 CF93      		push r28
 334               	.LCFI26:
 335               		.cfi_def_cfa_offset 4
 336               		.cfi_offset 28, -3
 337 0126 DF93      		push r29
 338               	.LCFI27:
 339               		.cfi_def_cfa_offset 5
 340               		.cfi_offset 29, -4
 341               	/* prologue: function */
 342               	/* frame size = 0 */
 343               	/* stack size = 3 */
 344               	.L__stack_usage = 3
 269:motor.c       ****     // default values for parameters
 270:motor.c       ****     Parameter[PARAMETER_TORQUE_KP] = 0.03;
 345               		.loc 1 270 0
 346 0128 8FE8      		ldi r24,lo8(0x3cf5c28f)
 347 012a 92EC      		ldi r25,hi8(0x3cf5c28f)
 348 012c A5EF      		ldi r26,hlo8(0x3cf5c28f)
 349 012e BCE3      		ldi r27,hhi8(0x3cf5c28f)
 350 0130 8093 0000 		sts Parameter,r24
 351 0134 9093 0000 		sts Parameter+1,r25
 352 0138 A093 0000 		sts Parameter+2,r26
 353 013c B093 0000 		sts Parameter+3,r27
 271:motor.c       ****     Parameter[PARAMETER_TORQUE_KI] = 0.01;
 354               		.loc 1 271 0
 355 0140 8AE0      		ldi r24,lo8(0x3c23d70a)
 356 0142 97ED      		ldi r25,hi8(0x3c23d70a)
 357 0144 A3E2      		ldi r26,hlo8(0x3c23d70a)
 358 0146 BCE3      		ldi r27,hhi8(0x3c23d70a)
 359 0148 8093 0000 		sts Parameter+4,r24
 360 014c 9093 0000 		sts Parameter+4+1,r25
 361 0150 A093 0000 		sts Parameter+4+2,r26
 362 0154 B093 0000 		sts Parameter+4+3,r27
 272:motor.c       ****     Parameter[PARAMETER_TORQUE_KD] = 0.0;
 363               		.loc 1 272 0
 364 0158 80E0      		ldi r24,lo8(0x0)
 365 015a 90E0      		ldi r25,hi8(0x0)
 366 015c DC01      		movw r26,r24
 367 015e 8093 0000 		sts Parameter+8,r24
 368 0162 9093 0000 		sts Parameter+8+1,r25
 369 0166 A093 0000 		sts Parameter+8+2,r26
 370 016a B093 0000 		sts Parameter+8+3,r27
 273:motor.c       ****     Parameter[PARAMETER_VELOCITY_KP] = 0.005;
 371               		.loc 1 273 0
 372 016e 4AE0      		ldi r20,lo8(0x3ba3d70a)
 373 0170 57ED      		ldi r21,hi8(0x3ba3d70a)
 374 0172 63EA      		ldi r22,hlo8(0x3ba3d70a)
 375 0174 7BE3      		ldi r23,hhi8(0x3ba3d70a)
 376 0176 4093 0000 		sts Parameter+12,r20
 377 017a 5093 0000 		sts Parameter+12+1,r21
 378 017e 6093 0000 		sts Parameter+12+2,r22
 379 0182 7093 0000 		sts Parameter+12+3,r23
 274:motor.c       ****     Parameter[PARAMETER_VELOCITY_KI] = 0.0025;
 380               		.loc 1 274 0
 381 0186 4AE0      		ldi r20,lo8(0x3b23d70a)
 382 0188 57ED      		ldi r21,hi8(0x3b23d70a)
 383 018a 63E2      		ldi r22,hlo8(0x3b23d70a)
 384 018c 7BE3      		ldi r23,hhi8(0x3b23d70a)
 385 018e 4093 0000 		sts Parameter+16,r20
 386 0192 5093 0000 		sts Parameter+16+1,r21
 387 0196 6093 0000 		sts Parameter+16+2,r22
 388 019a 7093 0000 		sts Parameter+16+3,r23
 275:motor.c       ****     Parameter[PARAMETER_VELOCITY_KD] = 0.0;
 389               		.loc 1 275 0
 390 019e 8093 0000 		sts Parameter+20,r24
 391 01a2 9093 0000 		sts Parameter+20+1,r25
 392 01a6 A093 0000 		sts Parameter+20+2,r26
 393 01aa B093 0000 		sts Parameter+20+3,r27
 276:motor.c       ****     Parameter[PARAMETER_POWER_KP] = 1.0;
 394               		.loc 1 276 0
 395 01ae 40E0      		ldi r20,lo8(0x3f800000)
 396 01b0 50E0      		ldi r21,hi8(0x3f800000)
 397 01b2 60E8      		ldi r22,hlo8(0x3f800000)
 398 01b4 7FE3      		ldi r23,hhi8(0x3f800000)
 399 01b6 4093 0000 		sts Parameter+24,r20
 400 01ba 5093 0000 		sts Parameter+24+1,r21
 401 01be 6093 0000 		sts Parameter+24+2,r22
 402 01c2 7093 0000 		sts Parameter+24+3,r23
 277:motor.c       ****     Parameter[PARAMETER_POWER_KI] = 0.3;
 403               		.loc 1 277 0
 404 01c6 4AE9      		ldi r20,lo8(0x3e99999a)
 405 01c8 59E9      		ldi r21,hi8(0x3e99999a)
 406 01ca 69E9      		ldi r22,hlo8(0x3e99999a)
 407 01cc 7EE3      		ldi r23,hhi8(0x3e99999a)
 408 01ce 4093 0000 		sts Parameter+28,r20
 409 01d2 5093 0000 		sts Parameter+28+1,r21
 410 01d6 6093 0000 		sts Parameter+28+2,r22
 411 01da 7093 0000 		sts Parameter+28+3,r23
 278:motor.c       ****     Parameter[PARAMETER_POWER_KD] = 0.0;
 412               		.loc 1 278 0
 413 01de 8093 0000 		sts Parameter+32,r24
 414 01e2 9093 0000 		sts Parameter+32+1,r25
 415 01e6 A093 0000 		sts Parameter+32+2,r26
 416 01ea B093 0000 		sts Parameter+32+3,r27
 279:motor.c       ****     Parameter[PARAMETER_WINDING_R] = DEFAULT_WINDING_RESISTANCE; // winding resitance
 417               		.loc 1 279 0
 418 01ee 8DEC      		ldi r24,lo8(0x41e4cccd)
 419 01f0 9CEC      		ldi r25,hi8(0x41e4cccd)
 420 01f2 A4EE      		ldi r26,hlo8(0x41e4cccd)
 421 01f4 B1E4      		ldi r27,hhi8(0x41e4cccd)
 422 01f6 8093 0000 		sts Parameter+36,r24
 423 01fa 9093 0000 		sts Parameter+36+1,r25
 424 01fe A093 0000 		sts Parameter+36+2,r26
 425 0202 B093 0000 		sts Parameter+36+3,r27
 280:motor.c       ****     Parameter[PARAMETER_THERMAL_R] = 2.66; // Thermal restance to case
 426               		.loc 1 280 0
 427 0206 81E7      		ldi r24,lo8(0x402a3d71)
 428 0208 9DE3      		ldi r25,hi8(0x402a3d71)
 429 020a AAE2      		ldi r26,hlo8(0x402a3d71)
 430 020c B0E4      		ldi r27,hhi8(0x402a3d71)
 431 020e 8093 0000 		sts Parameter+40,r24
 432 0212 9093 0000 		sts Parameter+40+1,r25
 433 0216 A093 0000 		sts Parameter+40+2,r26
 434 021a B093 0000 		sts Parameter+40+3,r27
 281:motor.c       ****     Parameter[PARAMETER_T_PLUS] = 90.0;
 435               		.loc 1 281 0
 436 021e 80E0      		ldi r24,lo8(0x42b40000)
 437 0220 90E0      		ldi r25,hi8(0x42b40000)
 438 0222 A4EB      		ldi r26,hlo8(0x42b40000)
 439 0224 B2E4      		ldi r27,hhi8(0x42b40000)
 440 0226 8093 0000 		sts Parameter+44,r24
 441 022a 9093 0000 		sts Parameter+44+1,r25
 442 022e A093 0000 		sts Parameter+44+2,r26
 443 0232 B093 0000 		sts Parameter+44+3,r27
 282:motor.c       ****     Parameter[PARAMETER_T_MINUS] = 90.0;
 444               		.loc 1 282 0
 445 0236 8093 0000 		sts Parameter+48,r24
 446 023a 9093 0000 		sts Parameter+48+1,r25
 447 023e A093 0000 		sts Parameter+48+2,r26
 448 0242 B093 0000 		sts Parameter+48+3,r27
 283:motor.c       ****     Parameter[PARAMETER_WINDING_TAU] = 1777.0;
 449               		.loc 1 283 0
 450 0246 40E0      		ldi r20,lo8(0x44de2000)
 451 0248 50E2      		ldi r21,hi8(0x44de2000)
 452 024a 6EED      		ldi r22,hlo8(0x44de2000)
 453 024c 74E4      		ldi r23,hhi8(0x44de2000)
 454 024e 4093 0000 		sts Parameter+52,r20
 455 0252 5093 0000 		sts Parameter+52+1,r21
 456 0256 6093 0000 		sts Parameter+52+2,r22
 457 025a 7093 0000 		sts Parameter+52+3,r23
 284:motor.c       ****     Parameter[PARAMETER_T_MAX] = 110.0;
 458               		.loc 1 284 0
 459 025e 40E0      		ldi r20,lo8(0x42dc0000)
 460 0260 50E0      		ldi r21,hi8(0x42dc0000)
 461 0262 6CED      		ldi r22,hlo8(0x42dc0000)
 462 0264 72E4      		ldi r23,hhi8(0x42dc0000)
 463 0266 4093 0000 		sts Parameter+56,r20
 464 026a 5093 0000 		sts Parameter+56+1,r21
 465 026e 6093 0000 		sts Parameter+56+2,r22
 466 0272 7093 0000 		sts Parameter+56+3,r23
 285:motor.c       ****     Parameter[PARAMETER_CU_ALPHA] = 0.0039;
 467               		.loc 1 285 0
 468 0276 44E2      		ldi r20,lo8(0x3b7f9724)
 469 0278 57E9      		ldi r21,hi8(0x3b7f9724)
 470 027a 6FE7      		ldi r22,hlo8(0x3b7f9724)
 471 027c 7BE3      		ldi r23,hhi8(0x3b7f9724)
 472 027e 4093 0000 		sts Parameter+60,r20
 473 0282 5093 0000 		sts Parameter+60+1,r21
 474 0286 6093 0000 		sts Parameter+60+2,r22
 475 028a 7093 0000 		sts Parameter+60+3,r23
 286:motor.c       ****     Parameter[PARAMETER_OFF_TIME] = 5.0; // number of time constants until reset
 476               		.loc 1 286 0
 477 028e 40E0      		ldi r20,lo8(0x40a00000)
 478 0290 50E0      		ldi r21,hi8(0x40a00000)
 479 0292 60EA      		ldi r22,hlo8(0x40a00000)
 480 0294 70E4      		ldi r23,hhi8(0x40a00000)
 481 0296 4093 0000 		sts Parameter+64,r20
 482 029a 5093 0000 		sts Parameter+64+1,r21
 483 029e 6093 0000 		sts Parameter+64+2,r22
 484 02a2 7093 0000 		sts Parameter+64+3,r23
 287:motor.c       ****     Parameter[PARAMETER_T_TARGET] = 90.0; 
 485               		.loc 1 287 0
 486 02a6 8093 0000 		sts Parameter+68,r24
 487 02aa 9093 0000 		sts Parameter+68+1,r25
 488 02ae A093 0000 		sts Parameter+68+2,r26
 489 02b2 B093 0000 		sts Parameter+68+3,r27
 288:motor.c       ****     Parameter[PARAMETER_MAXIMUM_RPM] = 12000.0;
 490               		.loc 1 288 0
 491 02b6 80E0      		ldi r24,lo8(0x463b8000)
 492 02b8 90E8      		ldi r25,hi8(0x463b8000)
 493 02ba ABE3      		ldi r26,hlo8(0x463b8000)
 494 02bc B6E4      		ldi r27,hhi8(0x463b8000)
 495 02be 8093 0000 		sts Parameter+72,r24
 496 02c2 9093 0000 		sts Parameter+72+1,r25
 497 02c6 A093 0000 		sts Parameter+72+2,r26
 498 02ca B093 0000 		sts Parameter+72+3,r27
 289:motor.c       ****     Parameter[PARAMETER_SPEED_CONSTANT] = 402.0;
 499               		.loc 1 289 0
 500 02ce 80E0      		ldi r24,lo8(0x43c90000)
 501 02d0 90E0      		ldi r25,hi8(0x43c90000)
 502 02d2 A9EC      		ldi r26,hlo8(0x43c90000)
 503 02d4 B3E4      		ldi r27,hhi8(0x43c90000)
 504 02d6 8093 0000 		sts Parameter+76,r24
 505 02da 9093 0000 		sts Parameter+76+1,r25
 506 02de A093 0000 		sts Parameter+76+2,r26
 507 02e2 B093 0000 		sts Parameter+76+3,r27
 290:motor.c       ****     Parameter[PARAMETER_MAXIMUM_PWM] = 150.0;
 508               		.loc 1 290 0
 509 02e6 80E0      		ldi r24,lo8(0x43160000)
 510 02e8 90E0      		ldi r25,hi8(0x43160000)
 511 02ea A6E1      		ldi r26,hlo8(0x43160000)
 512 02ec B3E4      		ldi r27,hhi8(0x43160000)
 513 02ee 8093 0000 		sts Parameter+80,r24
 514 02f2 9093 0000 		sts Parameter+80+1,r25
 515 02f6 A093 0000 		sts Parameter+80+2,r26
 516 02fa B093 0000 		sts Parameter+80+3,r27
 291:motor.c       ****     Parameter[PARAMETER_POSITION_KP] = 15.0;
 517               		.loc 1 291 0
 518 02fe 80E0      		ldi r24,lo8(0x41700000)
 519 0300 90E0      		ldi r25,hi8(0x41700000)
 520 0302 A0E7      		ldi r26,hlo8(0x41700000)
 521 0304 B1E4      		ldi r27,hhi8(0x41700000)
 522 0306 8093 0000 		sts Parameter+84,r24
 523 030a 9093 0000 		sts Parameter+84+1,r25
 524 030e A093 0000 		sts Parameter+84+2,r26
 525 0312 B093 0000 		sts Parameter+84+3,r27
 292:motor.c       ****     Parameter[PARAMETER_POSITION_DEADBAND] = 25.0;
 526               		.loc 1 292 0
 527 0316 80E0      		ldi r24,lo8(0x41c80000)
 528 0318 90E0      		ldi r25,hi8(0x41c80000)
 529 031a A8EC      		ldi r26,hlo8(0x41c80000)
 530 031c B1E4      		ldi r27,hhi8(0x41c80000)
 531 031e 8093 0000 		sts Parameter+88,r24
 532 0322 9093 0000 		sts Parameter+88+1,r25
 533 0326 A093 0000 		sts Parameter+88+2,r26
 534 032a B093 0000 		sts Parameter+88+3,r27
 535               	.LVL14:
 536 032e C0E0      		ldi r28,lo8(Parameter)
 537 0330 D0E0      		ldi r29,hi8(Parameter)
 293:motor.c       ****     //Parameter[PARAMETER_LED] = 1;
 294:motor.c       **** 
 295:motor.c       ****     // Write to EEPROM
 296:motor.c       ****     for(uint8_t i=0; i<INT_PARAMETER_START; i++) 
 538               		.loc 1 296 0
 539 0332 10E0      		ldi r17,lo8(0)
 540               	.LVL15:
 541               	.L10:
 542               	.LBB43:
 297:motor.c       ****     {
 298:motor.c       ****         WriteFloatToEEPROM(i, Parameter[i]);
 543               		.loc 1 298 0 discriminator 2
 544 0334 4991      		ld r20,Y+
 545 0336 5991      		ld r21,Y+
 546 0338 6991      		ld r22,Y+
 547 033a 7991      		ld r23,Y+
 548 033c 812F      		mov r24,r17
 549 033e 0E94 0000 		call WriteFloatToEEPROM
 296:motor.c       ****     for(uint8_t i=0; i<INT_PARAMETER_START; i++) 
 550               		.loc 1 296 0 discriminator 2
 551 0342 1F5F      		subi r17,lo8(-(1))
 552               	.LVL16:
 553 0344 1931      		cpi r17,lo8(25)
 554 0346 01F4      		brne .L10
 555               	.LBE43:
 299:motor.c       ****     }
 300:motor.c       ****     
 301:motor.c       ****     // set the magic number to indicate initialized EEPROM
 302:motor.c       ****     eeprom_write_byte((uint8_t *) (PARAM_EEPROM_INIT*4+0), 0);
 556               		.loc 1 302 0
 557 0348 80E8      		ldi r24,lo8(128)
 558 034a 90E0      		ldi r25,hi8(128)
 559 034c 60E0      		ldi r22,lo8(0)
 560 034e 0E94 0000 		call __eewr_byte_x32a4u
 303:motor.c       ****     eeprom_write_byte((uint8_t *) (PARAM_EEPROM_INIT*4+1), PARAM_EEPROM_INIT);
 561               		.loc 1 303 0
 562 0352 81E8      		ldi r24,lo8(129)
 563 0354 90E0      		ldi r25,hi8(129)
 564 0356 60E2      		ldi r22,lo8(32)
 565 0358 0E94 0000 		call __eewr_byte_x32a4u
 566               	/* epilogue start */
 304:motor.c       **** }
 567               		.loc 1 304 0
 568 035c DF91      		pop r29
 569 035e CF91      		pop r28
 570 0360 1F91      		pop r17
 571               	.LVL17:
 572 0362 0895      		ret
 573               		.cfi_endproc
 574               	.LFE15:
 576               	.global	initializeParameters
 578               	initializeParameters:
 579               	.LFB16:
 305:motor.c       **** 
 306:motor.c       **** /*************************************
 307:motor.c       ****  // initializeParameters()
 308:motor.c       ****  // check to see if EEPROM has bee initilailized
 309:motor.c       ****  // if yes, read the params from it
 310:motor.c       ****  // if not, set default values into EEPROM, then read them out
 311:motor.c       ****  ************************************/
 312:motor.c       **** void initializeParameters(void)
 313:motor.c       **** {
 580               		.loc 1 313 0
 581               		.cfi_startproc
 582 0364 CF92      		push r12
 583               	.LCFI28:
 584               		.cfi_def_cfa_offset 3
 585               		.cfi_offset 12, -2
 586 0366 DF92      		push r13
 587               	.LCFI29:
 588               		.cfi_def_cfa_offset 4
 589               		.cfi_offset 13, -3
 590 0368 EF92      		push r14
 591               	.LCFI30:
 592               		.cfi_def_cfa_offset 5
 593               		.cfi_offset 14, -4
 594 036a FF92      		push r15
 595               	.LCFI31:
 596               		.cfi_def_cfa_offset 6
 597               		.cfi_offset 15, -5
 598 036c 0F93      		push r16
 599               	.LCFI32:
 600               		.cfi_def_cfa_offset 7
 601               		.cfi_offset 16, -6
 602 036e 1F93      		push r17
 603               	.LCFI33:
 604               		.cfi_def_cfa_offset 8
 605               		.cfi_offset 17, -7
 606 0370 CF93      		push r28
 607               	.LCFI34:
 608               		.cfi_def_cfa_offset 9
 609               		.cfi_offset 28, -8
 610 0372 DF93      		push r29
 611               	.LCFI35:
 612               		.cfi_def_cfa_offset 10
 613               		.cfi_offset 29, -9
 614               	/* prologue: function */
 615               	/* frame size = 0 */
 616               	/* stack size = 8 */
 617               	.L__stack_usage = 8
 314:motor.c       ****     // check to see if EEPROM is initialized
 315:motor.c       ****     if((0 != eeprom_read_byte((uint8_t *) (PARAM_EEPROM_INIT*4+0))) || 
 618               		.loc 1 315 0
 619 0374 80E8      		ldi r24,lo8(128)
 620 0376 90E0      		ldi r25,hi8(128)
 621 0378 0E94 0000 		call __eerd_byte_x32a4u
 622 037c 8823      		tst r24
 623 037e 01F4      		brne .L13
 316:motor.c       ****        (PARAM_EEPROM_INIT != eeprom_read_byte((uint8_t *) (PARAM_EEPROM_INIT*4+1)))) 
 624               		.loc 1 316 0 discriminator 1
 625 0380 81E8      		ldi r24,lo8(129)
 626 0382 90E0      		ldi r25,hi8(129)
 627 0384 0E94 0000 		call __eerd_byte_x32a4u
 315:motor.c       ****     if((0 != eeprom_read_byte((uint8_t *) (PARAM_EEPROM_INIT*4+0))) || 
 628               		.loc 1 315 0 discriminator 1
 629 0388 8032      		cpi r24,lo8(32)
 630 038a 01F0      		breq .L14
 631               	.L13:
 317:motor.c       ****     {
 318:motor.c       ****         initializeEEPROM();
 632               		.loc 1 318 0
 633 038c 0E94 0000 		call initializeEEPROM
 634               	.L14:
 635               	.LVL18:
 313:motor.c       **** {
 636               		.loc 1 313 0 discriminator 1
 637 0390 C0E0      		ldi r28,lo8(0)
 638 0392 D0E0      		ldi r29,hi8(0)
 639 0394 00E0      		ldi r16,lo8(0)
 640 0396 10E0      		ldi r17,hi8(0)
 641               	.LVL19:
 642               	.L15:
 643               	.LBB44:
 644               	.LBB45:
 319:motor.c       ****     }
 320:motor.c       ****     
 321:motor.c       ****     // read out the Parameters
 322:motor.c       ****     for(uint8_t i=0; i<INT_PARAMETER_START; i++)
 323:motor.c       ****     {
 324:motor.c       ****         uint32_t data;
 325:motor.c       ****         // little endian
 326:motor.c       ****         data = eeprom_read_byte((uint8_t *) (i*4+3));
 645               		.loc 1 326 0 discriminator 2
 646 0398 CE01      		movw r24,r28
 647 039a 0396      		adiw r24,3
 648 039c 0E94 0000 		call __eerd_byte_x32a4u
 649 03a0 C82E      		mov r12,r24
 650               	.LVL20:
 327:motor.c       ****         data <<= 8;
 328:motor.c       ****         data |= eeprom_read_byte((uint8_t *) (i*4+2));
 651               		.loc 1 328 0 discriminator 2
 652 03a2 CE01      		movw r24,r28
 653               	.LVL21:
 654 03a4 0296      		adiw r24,2
 655 03a6 0E94 0000 		call __eerd_byte_x32a4u
 326:motor.c       ****         data = eeprom_read_byte((uint8_t *) (i*4+3));
 656               		.loc 1 326 0 discriminator 2
 657 03aa DD24      		clr r13
 658 03ac EE24      		clr r14
 659 03ae FF24      		clr r15
 327:motor.c       ****         data <<= 8;
 660               		.loc 1 327 0 discriminator 2
 661 03b0 FE2C      		mov r15,r14
 662 03b2 ED2C      		mov r14,r13
 663 03b4 DC2C      		mov r13,r12
 664 03b6 CC24      		clr r12
 665               	.LVL22:
 666               		.loc 1 328 0 discriminator 2
 667 03b8 90E0      		ldi r25,lo8(0)
 668 03ba A0E0      		ldi r26,lo8(0)
 669 03bc B0E0      		ldi r27,hi8(0)
 670 03be C82A      		or r12,r24
 671 03c0 D92A      		or r13,r25
 672 03c2 EA2A      		or r14,r26
 673 03c4 FB2A      		or r15,r27
 674               	.LVL23:
 329:motor.c       ****         data <<= 8;
 330:motor.c       ****         data |= eeprom_read_byte((uint8_t *) (i*4+1));
 675               		.loc 1 330 0 discriminator 2
 676 03c6 CE01      		movw r24,r28
 677 03c8 0196      		adiw r24,1
 678 03ca 0E94 0000 		call __eerd_byte_x32a4u
 329:motor.c       ****         data <<= 8;
 679               		.loc 1 329 0 discriminator 2
 680 03ce FE2C      		mov r15,r14
 681 03d0 ED2C      		mov r14,r13
 682 03d2 DC2C      		mov r13,r12
 683 03d4 CC24      		clr r12
 684               	.LVL24:
 685               		.loc 1 330 0 discriminator 2
 686 03d6 90E0      		ldi r25,lo8(0)
 687 03d8 A0E0      		ldi r26,lo8(0)
 688 03da B0E0      		ldi r27,hi8(0)
 689 03dc C82A      		or r12,r24
 690 03de D92A      		or r13,r25
 691 03e0 EA2A      		or r14,r26
 692 03e2 FB2A      		or r15,r27
 693               	.LVL25:
 331:motor.c       ****         data <<= 8;
 332:motor.c       ****         data |= eeprom_read_byte((uint8_t *) (i*4+0));
 694               		.loc 1 332 0 discriminator 2
 695 03e4 CE01      		movw r24,r28
 696 03e6 0E94 0000 		call __eerd_byte_x32a4u
 697               	.LVL26:
 333:motor.c       ****         memcpy(&Parameter[i], &data, 4);
 698               		.loc 1 333 0 discriminator 2
 699 03ea F801      		movw r30,r16
 700 03ec EE0F      		lsl r30
 701 03ee FF1F      		rol r31
 702 03f0 EE0F      		lsl r30
 703 03f2 FF1F      		rol r31
 704 03f4 E050      		subi r30,lo8(-(Parameter))
 705 03f6 F040      		sbci r31,hi8(-(Parameter))
 331:motor.c       ****         data <<= 8;
 706               		.loc 1 331 0 discriminator 2
 707 03f8 FE2C      		mov r15,r14
 708 03fa ED2C      		mov r14,r13
 709 03fc DC2C      		mov r13,r12
 710 03fe CC24      		clr r12
 711               	.LVL27:
 332:motor.c       ****         data |= eeprom_read_byte((uint8_t *) (i*4+0));
 712               		.loc 1 332 0 discriminator 2
 713 0400 90E0      		ldi r25,lo8(0)
 714 0402 A0E0      		ldi r26,lo8(0)
 715 0404 B0E0      		ldi r27,hi8(0)
 716 0406 C82A      		or r12,r24
 717 0408 D92A      		or r13,r25
 718 040a EA2A      		or r14,r26
 719 040c FB2A      		or r15,r27
 720               		.loc 1 333 0 discriminator 2
 721 040e C082      		st Z,r12
 722 0410 D182      		std Z+1,r13
 723 0412 E282      		std Z+2,r14
 724 0414 F382      		std Z+3,r15
 725 0416 0F5F      		subi r16,lo8(-(1))
 726 0418 1F4F      		sbci r17,hi8(-(1))
 727 041a 2496      		adiw r28,4
 728               	.LBE45:
 322:motor.c       ****     for(uint8_t i=0; i<INT_PARAMETER_START; i++)
 729               		.loc 1 322 0 discriminator 2
 730 041c 0931      		cpi r16,25
 731 041e 1105      		cpc r17,__zero_reg__
 732 0420 01F0      		breq .+2
 733 0422 00C0      		rjmp .L15
 734               	/* epilogue start */
 735               	.LBE44:
 334:motor.c       ****     }
 335:motor.c       **** }
 736               		.loc 1 335 0
 737 0424 DF91      		pop r29
 738 0426 CF91      		pop r28
 739 0428 1F91      		pop r17
 740 042a 0F91      		pop r16
 741 042c FF90      		pop r15
 742 042e EF90      		pop r14
 743 0430 DF90      		pop r13
 744 0432 CF90      		pop r12
 745 0434 0895      		ret
 746               		.cfi_endproc
 747               	.LFE16:
 749               	.global	BootRelay
 751               	BootRelay:
 752               	.LFB21:
 336:motor.c       **** 
 337:motor.c       **** static int handleCollectionCommand(uint8_t *commandPacket, uint8_t *outputBuffer)
 338:motor.c       **** {
 339:motor.c       ****     uint8_t responseSize = 0;
 340:motor.c       ****     uint16_t collectionBitfield;
 341:motor.c       ****     uint16_t controlSignal;
 342:motor.c       **** 
 343:motor.c       ****     //collectionBitfield = (uint16_t) (commandPacket[PAYLOAD_OFFSET]);
 344:motor.c       ****     memcpy(&collectionBitfield,&commandPacket[PAYLOAD_OFFSET],2);
 345:motor.c       **** 
 346:motor.c       ****     if(collectionBitfield & DATA_COLLECTION_TENSION_BITMASK)
 347:motor.c       ****     {
 348:motor.c       ****         memcpy(&outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize],&tension,4);
 349:motor.c       ****         responseSize += 4;
 350:motor.c       ****     }
 351:motor.c       **** 
 352:motor.c       ****     if(collectionBitfield & DATA_COLLECTION_MOTORCURRENT_BITMASK)
 353:motor.c       ****     {
 354:motor.c       ****         controlSignal = round(motorCurrent * 1000.0); //convert to mA
 355:motor.c       ****         outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize] = controlSignal & 0x00FF;
 356:motor.c       ****         outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize+1] = (controlSignal & 0xFF00) >> 8;
 357:motor.c       ****         responseSize += 2;
 358:motor.c       ****     }
 359:motor.c       **** 
 360:motor.c       ****     if(collectionBitfield & DATA_COLLECTION_MOTORSTATORTEMP_BITMASK)
 361:motor.c       ****     {
 362:motor.c       ****         controlSignal = round(statorTemperature * 100.0); //convert to hundredths of a degree
 363:motor.c       ****         outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize] = controlSignal & 0x00FF;
 364:motor.c       ****         outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize+1] = (controlSignal & 0xFF00) >> 8;
 365:motor.c       ****         responseSize += 2;
 366:motor.c       ****     }
 367:motor.c       **** 
 368:motor.c       ****     if(collectionBitfield & DATA_COLLECTION_MOTORVELOCITY_BITMASK)
 369:motor.c       ****     {
 370:motor.c       ****         controlSignal = averageRPM;
 371:motor.c       ****         outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize] = controlSignal & 0x00FF;
 372:motor.c       ****         outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize+1] = (controlSignal & 0xFF00) >> 8;
 373:motor.c       ****         responseSize += 2;
 374:motor.c       ****     }
 375:motor.c       **** 
 376:motor.c       ****     if(collectionBitfield & DATA_COLLECTION_MOTORWINDINGTEMP_BITMASK)
 377:motor.c       ****     {
 378:motor.c       ****         controlSignal = round((oldDeltaT + statorTemperature) * 100.0); //convert to hundredths of 
 379:motor.c       ****         outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize] = controlSignal & 0x00FF;
 380:motor.c       ****         outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize+1] = (controlSignal & 0xFF00) >> 8;
 381:motor.c       ****         responseSize += 2;
 382:motor.c       ****     }
 383:motor.c       **** 
 384:motor.c       ****     if(collectionBitfield & DATA_COLLECTION_MOTORHALL_BITMASK)
 385:motor.c       ****     {
 386:motor.c       ****         outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize] = encoder & 0x00FF;
 387:motor.c       ****         outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize+1] = (encoder & 0xFF00) >> 8;
 388:motor.c       ****         responseSize += 2;
 389:motor.c       ****     }
 390:motor.c       **** 
 391:motor.c       ****     if(collectionBitfield & DATA_COLLECTION_DEBUG_BITMASK)
 392:motor.c       ****     {
 393:motor.c       ****         memcpy(&outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize],&RxCheckSumErrCnt,4);
 394:motor.c       ****         responseSize += 4;
 395:motor.c       ****     }
 396:motor.c       **** 
 397:motor.c       ****     outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3+responseSize;
 398:motor.c       ****     outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = DATA_COLLECTION_OPCODE;
 399:motor.c       ****     outputBuffer[RESPONSE_STATUSCODE_OFFSET] = STATUS_OK;
 400:motor.c       ****     outputBuffer[3+responseSize] = computeChecksum(outputBuffer,3+responseSize); //this is the chec
 401:motor.c       ****     return 4+responseSize;
 402:motor.c       **** 
 403:motor.c       **** }
 404:motor.c       **** 
 405:motor.c       **** /************************************************************************
 406:motor.c       ****  * handleParameterCommand(uint8_t *commandPacket, uint8_t *outputBuffer)
 407:motor.c       ****  *
 408:motor.c       ****  * handles the Parameter Commands
 409:motor.c       ****  ************************************************************************/
 410:motor.c       **** static int handleParameterCommand(uint8_t *commandPacket, uint8_t *outputBuffer)
 411:motor.c       **** {
 412:motor.c       ****     uint8_t opcode = commandPacket[COMMAND_OFFSET] & OPCODE_BITMASK;
 413:motor.c       ****     uint8_t selectedParameter = commandPacket[COMMAND_OFFSET] & PARAMETER_ADDRESS_BITMASK;
 414:motor.c       ****     
 415:motor.c       ****     if(selectedParameter < INT_PARAMETER_START) // float parameter
 416:motor.c       ****     {
 417:motor.c       ****         float* parameterPointer = &Parameter[selectedParameter];
 418:motor.c       ****         
 419:motor.c       ****         //Finally check for READ/WRITE direction
 420:motor.c       ****         if((opcode == MOTOR_PARAMETER_RE_H_OPCODE) || (opcode == MOTOR_PARAMETER_RE_L_OPCODE)) //re
 421:motor.c       ****         {
 422:motor.c       ****             convertFloatToArray(*parameterPointer, &outputBuffer[RESPONSE_PAYLOAD_OFFSET]);
 423:motor.c       ****             outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 7;
 424:motor.c       ****             outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = opcode;
 425:motor.c       ****             outputBuffer[RESPONSE_STATUSCODE_OFFSET] = STATUS_OK;
 426:motor.c       ****             outputBuffer[7] = computeChecksum(outputBuffer,7); //this is the checksum
 427:motor.c       ****             return 8;
 428:motor.c       ****         }
 429:motor.c       ****         else //write
 430:motor.c       ****         {
 431:motor.c       ****             float convertedData = convertArrayToFloat(&commandPacket[PAYLOAD_OFFSET]);
 432:motor.c       ****             *parameterPointer = convertedData;
 433:motor.c       ****             WriteFloatToEEPROM(selectedParameter, convertedData);
 434:motor.c       **** 
 435:motor.c       ****             outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3;
 436:motor.c       ****             outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = opcode;
 437:motor.c       ****             outputBuffer[RESPONSE_STATUSCODE_OFFSET] = STATUS_OK;
 438:motor.c       ****             outputBuffer[3] = computeChecksum(outputBuffer,3); //this is the checksum
 439:motor.c       ****             return 4;
 440:motor.c       ****         }
 441:motor.c       ****     }
 442:motor.c       ****     else // int parameter
 443:motor.c       ****     {
 444:motor.c       ****         //Finally check for READ/WRITE direction
 445:motor.c       ****         if((opcode == MOTOR_PARAMETER_RE_H_OPCODE) || (opcode == MOTOR_PARAMETER_RE_L_OPCODE)) //re
 446:motor.c       ****         {
 447:motor.c       ****             ReadIntFromEEPROM(selectedParameter, &outputBuffer[RESPONSE_PAYLOAD_OFFSET]);
 448:motor.c       ****             outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 7;
 449:motor.c       ****             outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = opcode;
 450:motor.c       ****             outputBuffer[RESPONSE_STATUSCODE_OFFSET] = STATUS_OK;
 451:motor.c       ****             outputBuffer[7] = computeChecksum(outputBuffer, 7); //this is the checksum
 452:motor.c       ****             return 8;
 453:motor.c       ****         }
 454:motor.c       ****         else //write
 455:motor.c       ****         {
 456:motor.c       ****             WriteIntToEEPROM(selectedParameter, &commandPacket[PAYLOAD_OFFSET]);
 457:motor.c       ****             
 458:motor.c       ****             if(selectedParameter == EEPROM_ADDRESS_LED) 
 459:motor.c       ****             {
 460:motor.c       ****                 if(commandPacket[PAYLOAD_OFFSET+0] |
 461:motor.c       ****                    commandPacket[PAYLOAD_OFFSET+1] |
 462:motor.c       ****                    commandPacket[PAYLOAD_OFFSET+2] |
 463:motor.c       ****                    commandPacket[PAYLOAD_OFFSET+3])
 464:motor.c       ****                     LEDon();
 465:motor.c       ****                 else
 466:motor.c       ****                     LEDoff();
 467:motor.c       ****             }
 468:motor.c       **** 
 469:motor.c       ****             outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3;
 470:motor.c       ****             outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = opcode;
 471:motor.c       ****             outputBuffer[RESPONSE_STATUSCODE_OFFSET] = STATUS_OK;
 472:motor.c       ****             outputBuffer[3] = computeChecksum(outputBuffer,3); //this is the checksum
 473:motor.c       ****             return 4;
 474:motor.c       ****         }
 475:motor.c       ****     }
 476:motor.c       **** }
 477:motor.c       **** 
 478:motor.c       **** static int handleMotorCommand(uint8_t *commandPacket, uint8_t *outputBuffer)
 479:motor.c       **** {
 480:motor.c       ****     uint8_t motorDirection;
 481:motor.c       ****     uint8_t controlScheme;
 482:motor.c       **** 
 483:motor.c       ****     DIRECTION_MODE_t newDirection;
 484:motor.c       ****     PID_SCHEME_t newScheme;
 485:motor.c       **** 
 486:motor.c       ****     uint16_t setpoint;
 487:motor.c       ****     int applySetpoint = THERMAL_DISCARD;
 488:motor.c       ****     int rejectSetpoint;
 489:motor.c       **** 
 490:motor.c       ****     motorDirection = commandPacket[COMMAND_OFFSET] & MOTOR_COMMAND_DIRECTION_BITMASK;
 491:motor.c       ****     controlScheme = commandPacket[COMMAND_OFFSET] & MOTOR_COMMAND_SCHEME_BITMASK;
 492:motor.c       **** 
 493:motor.c       ****     switch(controlScheme)
 494:motor.c       ****     {
 495:motor.c       ****         case MOTOR_COMMAND_VELOCITY:
 496:motor.c       ****             newScheme = CONTROL_SCHEME_VELOCITY;
 497:motor.c       ****             break;
 498:motor.c       ****         case MOTOR_COMMAND_CURRENT:
 499:motor.c       ****             newScheme = CONTROL_SCHEME_CURRENT;
 500:motor.c       ****             break;
 501:motor.c       ****         case MOTOR_COMMAND_VOLTAGE:
 502:motor.c       ****             newScheme = CONTROL_SCHEME_VOLTAGE;
 503:motor.c       ****             break;
 504:motor.c       ****         case MOTOR_COMMAND_POSITION:
 505:motor.c       ****             newScheme = CONTROL_SCHEME_POSITION;
 506:motor.c       ****             break;
 507:motor.c       ****         default:
 508:motor.c       ****             newScheme = CONTROL_SCHEME_VOLTAGE;
 509:motor.c       ****             break;
 510:motor.c       ****     }
 511:motor.c       **** 
 512:motor.c       **** 
 513:motor.c       ****     switch(motorDirection)
 514:motor.c       ****     {
 515:motor.c       ****         case MOTOR_COMMAND_FORWARD:
 516:motor.c       ****             newDirection = DIRECTION_FORWARD;
 517:motor.c       ****             break;
 518:motor.c       ****         case MOTOR_COMMAND_REVERSE:
 519:motor.c       ****             newDirection = DIRECTION_REVERSE;
 520:motor.c       ****             break;
 521:motor.c       ****         case MOTOR_COMMAND_STOP:
 522:motor.c       ****             newDirection = DIRECTION_STOP;
 523:motor.c       ****             newScheme = CONTROL_SCHEME_VOLTAGE;
 524:motor.c       ****             break;
 525:motor.c       ****         default:
 526:motor.c       ****             newDirection = DIRECTION_STOP;
 527:motor.c       ****             newScheme = CONTROL_SCHEME_VOLTAGE;
 528:motor.c       ****             break;
 529:motor.c       ****     }
 530:motor.c       **** 
 531:motor.c       ****     //Always apply direction commands independent of anything else if it is a stop command.
 532:motor.c       ****     if(newDirection == DIRECTION_STOP)
 533:motor.c       ****     {
 534:motor.c       ****         updateMotorDirection(newDirection);
 535:motor.c       ****         //resetVelocityCounter(); //moved inside updateMotorDirection()
 536:motor.c       ****         //updateMotorVoltage(0x00);// inside updateMotorDirection()
 537:motor.c       ****     }
 538:motor.c       ****     else if (getMotorDirection() == DIRECTION_STOP)
 539:motor.c       ****     {
 540:motor.c       ****         //Start from a clean motor voltage if just starting up
 541:motor.c       ****         //Later logic also resets if a control scheme has changed.
 542:motor.c       ****         resetPIDController();
 543:motor.c       ****         updateMotorVoltage(0x00);
 544:motor.c       ****     }
 545:motor.c       ****     
 546:motor.c       ****     //Cast the 16 bit setpoint to a uint16.  Incoming data should be little endian to match
 547:motor.c       ****     //this processor's compiler convention
 548:motor.c       ****     //This will allow conversion to fixed point more easily if necessary
 549:motor.c       ****     setpoint = *(uint16_t *)&commandPacket[PAYLOAD_OFFSET];
 550:motor.c       ****     rejectSetpoint = 0;
 551:motor.c       **** 
 552:motor.c       ****     switch(newScheme)
 553:motor.c       ****     {
 554:motor.c       ****         case CONTROL_SCHEME_VOLTAGE:
 555:motor.c       ****             cli();
 556:motor.c       ****             if((setpoint > MAXIMUM_VOLTAGE_COMMAND) || (setpoint < MINIMUM_VOLTAGE_COMMAND))
 557:motor.c       ****             {
 558:motor.c       ****                 rejectSetpoint = 1;
 559:motor.c       ****                 break;
 560:motor.c       ****             }
 561:motor.c       ****             applySetpoint = thermalCheckSetpoint(CONTROL_SCHEME_VOLTAGE, setpoint);
 562:motor.c       ****             if((applySetpoint == THERMAL_DELAY) || (applySetpoint == THERMAL_OK))
 563:motor.c       ****             {
 564:motor.c       ****                 PID_state.controlScheme = CONTROL_SCHEME_VOLTAGE;
 565:motor.c       ****                 PID_state.setpoint = setpoint;
 566:motor.c       ****                 updateMotorDirection(newDirection);
 567:motor.c       ****                 // if(newDirection != getMotorDirection())//moved inside updateMotorDirection(
 568:motor.c       ****                 // {
 569:motor.c       ****                 //     updateMotorDirection(newDirection);
 570:motor.c       ****                 //     //resetVelocityCounter(); //moved inside updateMotorDirection()
 571:motor.c       ****                 // }
 572:motor.c       ****             }
 573:motor.c       ****             if(applySetpoint == THERMAL_OK)
 574:motor.c       ****             {
 575:motor.c       ****                 //Setpoint must be scaled down because the actual control signal is only 8 bits, no
 576:motor.c       ****                 updateMotorVoltage(setpoint / 256);
 577:motor.c       ****             }
 578:motor.c       **** 
 579:motor.c       ****             break;
 580:motor.c       **** 
 581:motor.c       ****         case CONTROL_SCHEME_VELOCITY:
 582:motor.c       ****             cli();
 583:motor.c       ****             if((setpoint > Parameter[PARAMETER_MAXIMUM_RPM]) || (setpoint < MINIMUM_VELOCITY_COMMAN
 584:motor.c       ****             {
 585:motor.c       ****                 rejectSetpoint = 1;
 586:motor.c       ****                 break;
 587:motor.c       ****             }
 588:motor.c       ****             applySetpoint = thermalCheckSetpoint(CONTROL_SCHEME_VELOCITY, setpoint);
 589:motor.c       **** 
 590:motor.c       ****             if((applySetpoint == THERMAL_DELAY) || (applySetpoint == THERMAL_OK))
 591:motor.c       ****             {
 592:motor.c       ****                 //Configure the setpoint before presetting so that it will know how to preset.
 593:motor.c       ****                 //Configure the control scheme afterwards so the following if check knows if the co
 594:motor.c       ****                 //scheme has changed.
 595:motor.c       ****                 PID_state.setpoint = setpoint;
 596:motor.c       ****                 if((applySetpoint == THERMAL_OK) && (PID_state.controlScheme != CONTROL_SCHEME_VELO
 597:motor.c       ****                 {
 598:motor.c       ****                     //Only preset the motor if the motor control mode is being switched mid-rotatio
 599:motor.c       ****                     PIDPreset(CONTROL_SCHEME_VELOCITY);
 600:motor.c       ****                 }
 601:motor.c       ****                 PID_state.controlScheme = CONTROL_SCHEME_VELOCITY;
 602:motor.c       ****                 updateMotorDirection(newDirection);
 603:motor.c       ****                 // if(newDirection != getMotorDirection())//moved inside updateMotorDirection()
 604:motor.c       ****                 // {
 605:motor.c       ****                 //     updateMotorDirection(newDirection);
 606:motor.c       ****                 //     resetVelocityCounter();//moved inside updateMotorDirection()
 607:motor.c       ****                 // }
 608:motor.c       ****             }
 609:motor.c       ****             break;
 610:motor.c       **** 
 611:motor.c       ****         case CONTROL_SCHEME_CURRENT:
 612:motor.c       ****             cli();
 613:motor.c       ****             if((setpoint > MAXIMUM_CURRENT_COMMAND) || (setpoint < MINIMUM_CURRENT_COMMAND))
 614:motor.c       ****             {
 615:motor.c       ****                 rejectSetpoint = 1;
 616:motor.c       ****                 break;
 617:motor.c       ****             }
 618:motor.c       ****             applySetpoint = thermalCheckSetpoint(CONTROL_SCHEME_CURRENT, setpoint);
 619:motor.c       ****             if((applySetpoint == THERMAL_DELAY) || (applySetpoint == THERMAL_OK))
 620:motor.c       ****             {
 621:motor.c       ****                 //Configure the setpoint before presetting so that it will know how to preset.
 622:motor.c       ****                 //Configure the control scheme afterwards so the following if check knows if the co
 623:motor.c       ****                 //scheme has changed.
 624:motor.c       ****                 PID_state.setpoint = setpoint;
 625:motor.c       ****                 if((applySetpoint == THERMAL_OK) && (PID_state.controlScheme != CONTROL_SCHEME_CURR
 626:motor.c       ****                 {
 627:motor.c       ****                     //Only preset the motor if the motor control mode is being switched mid-rotatio
 628:motor.c       ****                     PIDPreset(CONTROL_SCHEME_CURRENT);
 629:motor.c       ****                 }
 630:motor.c       ****                 PID_state.controlScheme = CONTROL_SCHEME_CURRENT;
 631:motor.c       ****                 updateMotorDirection(newDirection);
 632:motor.c       ****                 // if(newDirection != getMotorDirection())//moved inside updateMotorDirection()
 633:motor.c       ****                 // {
 634:motor.c       ****                 //     updateMotorDirection(newDirection);
 635:motor.c       ****                 //     resetVelocityCounter();//moved inside updateMotorDirection()
 636:motor.c       ****                 // }
 637:motor.c       ****             }
 638:motor.c       ****             break;
 639:motor.c       **** 
 640:motor.c       ****         case CONTROL_SCHEME_POSITION:
 641:motor.c       ****             cli();
 642:motor.c       ****             positionSetPoint = (int16_t)setpoint;
 643:motor.c       ****             if((positionSetPoint > MAXIMUM_POSITION_COMMAND) || (positionSetPoint < MINIMUM_POSITIO
 644:motor.c       ****             {
 645:motor.c       ****                 rejectSetpoint = 1;
 646:motor.c       ****                 break;
 647:motor.c       ****             }
 648:motor.c       **** 
 649:motor.c       ****             setpoint = positionControl(positionSetPoint);
 650:motor.c       ****             
 651:motor.c       ****             applySetpoint = thermalCheckSetpoint(CONTROL_SCHEME_VELOCITY, setpoint);
 652:motor.c       **** 
 653:motor.c       ****             if((applySetpoint == THERMAL_DELAY) || (applySetpoint == THERMAL_OK))
 654:motor.c       ****             {
 655:motor.c       ****                 //Configure the setpoint before presetting so that it will know how to preset.
 656:motor.c       ****                 //Configure the control scheme afterwards so the following if check knows if the co
 657:motor.c       ****                 //scheme has changed.
 658:motor.c       ****                 PID_state.setpoint = setpoint;
 659:motor.c       ****                 //if((applySetpoint == THERMAL_OK) && (PID_state.controlScheme != CONTROL_SCHEME_PO
 660:motor.c       ****                 //{
 661:motor.c       ****                 //    //Only preset the motor if the motor control mode is being switched mid-rotat
 662:motor.c       ****                 //    PIDPreset(CONTROL_SCHEME_POSITION);
 663:motor.c       ****                 //}
 664:motor.c       ****                 PID_state.controlScheme = CONTROL_SCHEME_POSITION;
 665:motor.c       ****                 //updateMotorDirection(newDirection);
 666:motor.c       ****                 // if(newDirection != getMotorDirection())//moved inside updateMotorDirection()
 667:motor.c       ****                 // {
 668:motor.c       ****                 //     updateMotorDirection(newDirection);
 669:motor.c       ****                 //     resetVelocityCounter();//moved inside updateMotorDirection()
 670:motor.c       ****                 // }
 671:motor.c       ****             }
 672:motor.c       **** 
 673:motor.c       ****             break;
 674:motor.c       **** 
 675:motor.c       ****         default:
 676:motor.c       ****             break;
 677:motor.c       ****     }
 678:motor.c       ****     sei();
 679:motor.c       ****     
 680:motor.c       ****     updateMotor(); //forceMotorUpdate();
 681:motor.c       ****     
 682:motor.c       ****     if(newDirection == DIRECTION_STOP)
 683:motor.c       ****     {
 684:motor.c       ****         outputBuffer[RESPONSE_STATUSCODE_OFFSET] = STATUS_OK;
 685:motor.c       ****     } 
 686:motor.c       ****     else if(rejectSetpoint) 
 687:motor.c       ****     {
 688:motor.c       ****         outputBuffer[RESPONSE_STATUSCODE_OFFSET] = OUT_OF_RANGE;
 689:motor.c       ****     } 
 690:motor.c       ****     else
 691:motor.c       ****     {
 692:motor.c       ****         switch(applySetpoint)
 693:motor.c       ****         {
 694:motor.c       ****             case THERMAL_OK:
 695:motor.c       ****                 outputBuffer[RESPONSE_STATUSCODE_OFFSET] = STATUS_OK;
 696:motor.c       ****                 break;
 697:motor.c       ****             case THERMAL_DELAY:
 698:motor.c       ****                 outputBuffer[RESPONSE_STATUSCODE_OFFSET] = DELAYED_ERROR;
 699:motor.c       ****                 break;
 700:motor.c       ****             case THERMAL_DISCARD:
 701:motor.c       ****                 outputBuffer[RESPONSE_STATUSCODE_OFFSET] = MANDATORY_COOLDOWN;
 702:motor.c       ****                 break;
 703:motor.c       ****             default:
 704:motor.c       ****                 outputBuffer[RESPONSE_STATUSCODE_OFFSET] = MANDATORY_COOLDOWN;
 705:motor.c       ****                 break;
 706:motor.c       ****         }
 707:motor.c       ****     }
 708:motor.c       **** 
 709:motor.c       ****     outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3;
 710:motor.c       ****     outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = MOTOR_COMMAND_OPCODE;
 711:motor.c       ****     //Status code filled in above
 712:motor.c       ****     outputBuffer[3] = computeChecksum(outputBuffer,3); //this is the checksum
 713:motor.c       ****     return 4;
 714:motor.c       **** }
 715:motor.c       **** 
 716:motor.c       **** 
 717:motor.c       **** static int handleCalibrationCommand(uint8_t *commandPacket, uint8_t *outputBuffer)
 718:motor.c       **** {
 719:motor.c       ****     uint16_t collectionBitfield;
 720:motor.c       **** 
 721:motor.c       ****     memcpy(&collectionBitfield,&commandPacket[PAYLOAD_OFFSET],2);
 722:motor.c       **** 
 723:motor.c       ****     if (collectionBitfield & DATA_COLLECTION_DEBUG_BITMASK)
 724:motor.c       ****     {
 725:motor.c       ****         RxCheckSumErrCnt[0] = 0;
 726:motor.c       ****         RxCheckSumErrCnt[1] = 0;
 727:motor.c       ****     }
 728:motor.c       **** 
 729:motor.c       ****     if (collectionBitfield & DATA_COLLECTION_MOTORHALL_BITMASK)
 730:motor.c       ****     {
 731:motor.c       ****         cli();
 732:motor.c       ****         encoder = 0;
 733:motor.c       ****         sei();
 734:motor.c       ****     }
 735:motor.c       ****     
 736:motor.c       ****     outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3;
 737:motor.c       ****     outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = CALIBRATION_OPCODE;
 738:motor.c       ****     outputBuffer[RESPONSE_STATUSCODE_OFFSET] = STATUS_OK;
 739:motor.c       ****     outputBuffer[3] = computeChecksum(outputBuffer,3); //this is the checksum
 740:motor.c       ****     return 4;
 741:motor.c       **** }
 742:motor.c       **** 
 743:motor.c       **** void BootRelay(uint8_t *commandPacket)
 744:motor.c       **** {
 753               		.loc 1 744 0
 754               		.cfi_startproc
 755               	.LVL28:
 756 0436 CF93      		push r28
 757               	.LCFI36:
 758               		.cfi_def_cfa_offset 3
 759               		.cfi_offset 28, -2
 760 0438 DF93      		push r29
 761               	.LCFI37:
 762               		.cfi_def_cfa_offset 4
 763               		.cfi_offset 29, -3
 764 043a CDB7      		in r28,__SP_L__
 765 043c DEB7      		in r29,__SP_H__
 766 043e A097      		sbiw r28,32
 767               	.LCFI38:
 768               		.cfi_def_cfa 28, 36
 769 0440 CDBF      		out __SP_L__,r28
 770 0442 DEBF      		out __SP_H__,r29
 771               	/* prologue: function */
 772               	/* frame size = 32 */
 773               	/* stack size = 34 */
 774               	.L__stack_usage = 34
 745:motor.c       ****     // overview: 1)send a bootload command to the target
 746:motor.c       ****     // overview: 2)configure for 115200 baud passthrough
 747:motor.c       ****     // overview: 3)start a 20 second timer
 748:motor.c       ****     // overview: 4)do the serial passthrough, blink LED
 749:motor.c       ****     // overview: 5)wait for timer to finish, then reset/reboot
 750:motor.c       **** 
 751:motor.c       ****     cli(); // disable all interrupts, nothing else going on
 775               		.loc 1 751 0
 776               	/* #APP */
 777               	 ;  751 "motor.c" 1
 778 0444 F894      		cli
 779               	 ;  0 "" 2
 752:motor.c       ****     DMA.CTRL = 0; // disable the DMA controller
 780               		.loc 1 752 0
 781               	/* #NOAPP */
 782 0446 1092 0001 		sts 256,__zero_reg__
 753:motor.c       ****   
 754:motor.c       ****     // repeat the command to the target
 755:motor.c       ****     DOWNSTREAM_USART.CTRLA = 0x00; // disable interrupts
 783               		.loc 1 755 0
 784 044a E0EB      		ldi r30,lo8(2480)
 785 044c F9E0      		ldi r31,hi8(2480)
 786 044e 1382      		std Z+3,__zero_reg__
 756:motor.c       ****     DOWNSTREAM_USART.CTRLB = USART_RXEN_bm | USART_TXEN_bm; //enable RX and TX
 787               		.loc 1 756 0
 788 0450 28E1      		ldi r18,lo8(24)
 789 0452 2483      		std Z+4,r18
 790               	.LVL29:
 791 0454 FC01      		movw r30,r24
 757:motor.c       ****     for(int i=0;i<COMMAND_PACKET_SIZE;i++)
 792               		.loc 1 757 0
 793 0456 80E0      		ldi r24,lo8(0)
 794 0458 90E0      		ldi r25,hi8(0)
 795               	.LVL30:
 796               	.L36:
 797               	.LBB46:
 758:motor.c       ****     {
 759:motor.c       ****         while(!(DOWNSTREAM_USART.STATUS & USART_DREIF_bm));
 798               		.loc 1 759 0 discriminator 1
 799 045a 2091 B109 		lds r18,2481
 800 045e 25FF      		sbrs r18,5
 801 0460 00C0      		rjmp .L36
 760:motor.c       ****         DOWNSTREAM_USART.DATA = commandPacket[i];
 802               		.loc 1 760 0
 803 0462 2191      		ld r18,Z+
 804 0464 2093 B009 		sts 2480,r18
 757:motor.c       ****     for(int i=0;i<COMMAND_PACKET_SIZE;i++)
 805               		.loc 1 757 0
 806 0468 0196      		adiw r24,1
 807               	.LVL31:
 808 046a 8730      		cpi r24,7
 809 046c 9105      		cpc r25,__zero_reg__
 810 046e 01F4      		brne .L36
 811               	.LVL32:
 812               	.L31:
 813               	.LBE46:
 761:motor.c       ****     }
 762:motor.c       ****     // dont bother waiting for a response verification
 763:motor.c       ****     while(!(DOWNSTREAM_USART.STATUS & USART_DREIF_bm)); // wait for the data to be read
 814               		.loc 1 763 0 discriminator 1
 815 0470 8091 B109 		lds r24,2481
 816 0474 85FF      		sbrs r24,5
 817 0476 00C0      		rjmp .L31
 764:motor.c       ****     DOWNSTREAM_USART.STATUS = USART_TXCIF_bm; // clear the TX done flag
 818               		.loc 1 764 0
 819 0478 80E4      		ldi r24,lo8(64)
 820 047a E0EB      		ldi r30,lo8(2480)
 821 047c F9E0      		ldi r31,hi8(2480)
 822 047e 8183      		std Z+1,r24
 823               	.L21:
 765:motor.c       ****     while(!(DOWNSTREAM_USART.STATUS & USART_TXCIF_bm)); // wait for the TX to be done
 824               		.loc 1 765 0 discriminator 1
 825 0480 E0EB      		ldi r30,lo8(2480)
 826 0482 F9E0      		ldi r31,hi8(2480)
 827 0484 8091 B109 		lds r24,2481
 828 0488 86FF      		sbrs r24,6
 829 048a 00C0      		rjmp .L21
 830               	.LVL33:
 831               	.LBB47:
 832               	.LBB48:
 833               		.file 2 "/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../av
   1:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   6:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   9:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  12:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      distribution.
  16:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  17:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  21:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  33:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  35:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  38:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  41:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  42:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <math.h>
  45:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  46:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \file */
  47:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \code
  49:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \endcode
  53:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  54:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     used.
  58:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  59:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  68:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  77:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  81:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** */
  82:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  83:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  87:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  88:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  93:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  94:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  97:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  98:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #  include <math.h>
 102:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
 103:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 104:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /**
 105:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 107:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 109:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 112:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 114:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 120:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 125:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 129:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 132:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 140:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  */
 141:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** void
 142:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** {
 144:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 153:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 156:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 159:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#else
 160:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//round up by default
 161:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#endif
 163:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 164:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 834               		.loc 2 164 0
 835 048c 8FE3      		 ldi r24,lo8(7999)
 836 048e 9FE1      	    ldi r25,hi8(7999)
 837 0490 0197      	    1:sbiw r24,1
 838 0492 01F4      	    brne 1b
 839 0494 00C0      		rjmp .
 840 0496 0000      		nop
 841               	.LVL34:
 842               	.LBE48:
 843               	.LBE47:
 766:motor.c       ****     _delay_ms(1);
 767:motor.c       ****   
 768:motor.c       ****     // Reconfigure the serial ports
 769:motor.c       ****     //int bsel = 1047;       // 115200 @ 32Mhz as calculated from ProtoTalk.net
 770:motor.c       ****     //uint8_t bscale = 10;      // 115200 @ 32Mhz as calculated from ProtoTalk.net
 771:motor.c       ****     int bsel = 3269;       // 38,400 @ 32Mhz as calculated from ProtoTalk.net
 772:motor.c       ****     uint8_t bscale = -6;      // 38,400 @ 32Mhz as calculated from ProtoTalk.net
 773:motor.c       ****     UPSTREAM_USART.CTRLA = 0x00; // disable interrupts
 844               		.loc 1 773 0
 845 0498 A0EA      		ldi r26,lo8(2464)
 846 049a B9E0      		ldi r27,hi8(2464)
 847 049c 1396      		adiw r26,3
 848 049e 1C92      		st X,__zero_reg__
 849 04a0 1397      		sbiw r26,3
 774:motor.c       ****     UPSTREAM_USART.BAUDCTRLA = (uint8_t) bsel;
 850               		.loc 1 774 0
 851 04a2 25EC      		ldi r18,lo8(-59)
 852 04a4 1696      		adiw r26,6
 853 04a6 2C93      		st X,r18
 854 04a8 1697      		sbiw r26,6
 775:motor.c       ****     UPSTREAM_USART.BAUDCTRLB = (bscale << 4) | (bsel >> 8);
 855               		.loc 1 775 0
 856 04aa 9CEA      		ldi r25,lo8(-84)
 857 04ac 1796      		adiw r26,7
 858 04ae 9C93      		st X,r25
 859 04b0 1797      		sbiw r26,7
 776:motor.c       ****     UPSTREAM_USART.CTRLB = USART_RXEN_bm | USART_TXEN_bm;    //enable RX and TX
 860               		.loc 1 776 0
 861 04b2 88E1      		ldi r24,lo8(24)
 862 04b4 1496      		adiw r26,4
 863 04b6 8C93      		st X,r24
 777:motor.c       ****     DOWNSTREAM_USART.CTRLA = 0x00; // disable interrupts
 864               		.loc 1 777 0
 865 04b8 1382      		std Z+3,__zero_reg__
 778:motor.c       ****     DOWNSTREAM_USART.BAUDCTRLA = (uint8_t) bsel;
 866               		.loc 1 778 0
 867 04ba 2683      		std Z+6,r18
 779:motor.c       ****     DOWNSTREAM_USART.BAUDCTRLB = (bscale << 4) | (bsel >> 8);
 868               		.loc 1 779 0
 869 04bc 9783      		std Z+7,r25
 780:motor.c       ****     DOWNSTREAM_USART.CTRLB = USART_RXEN_bm | USART_TXEN_bm;    //enable RX and TX
 870               		.loc 1 780 0
 871 04be 8483      		std Z+4,r24
 872               	.LVL35:
 781:motor.c       ****   
 782:motor.c       ****     int sec_cnt=0;
 783:motor.c       ****     uint32_t loop_cnt=0;
 784:motor.c       ****     uint8_t up_fifo[16];
 785:motor.c       ****     uint8_t up_head = 0;
 786:motor.c       ****     uint8_t up_tail = 0;
 787:motor.c       ****     uint8_t down_fifo[16];
 788:motor.c       ****     uint8_t down_head = 0;
 789:motor.c       ****     uint8_t down_tail = 0;
 873               		.loc 1 789 0
 874 04c0 30E0      		ldi r19,lo8(0)
 788:motor.c       ****     uint8_t down_head = 0;
 875               		.loc 1 788 0
 876 04c2 20E0      		ldi r18,lo8(0)
 786:motor.c       ****     uint8_t up_tail = 0;
 877               		.loc 1 786 0
 878 04c4 40E0      		ldi r20,lo8(0)
 785:motor.c       ****     uint8_t up_head = 0;
 879               		.loc 1 785 0
 880 04c6 50E0      		ldi r21,lo8(0)
 783:motor.c       ****     uint32_t loop_cnt=0;
 881               		.loc 1 783 0
 882 04c8 80E0      		ldi r24,lo8(0)
 883 04ca 90E0      		ldi r25,hi8(0)
 884 04cc DC01      		movw r26,r24
 782:motor.c       ****     int sec_cnt=0;
 885               		.loc 1 782 0
 886 04ce 60E0      		ldi r22,lo8(0)
 887 04d0 70E0      		ldi r23,hi8(0)
 888               	.LBB49:
 889               	.LBB50:
 790:motor.c       **** 
 791:motor.c       ****     // relay chars while waiting for timeout
 792:motor.c       ****     while(sec_cnt < 200) {
 793:motor.c       ****         loop_cnt++;
 794:motor.c       ****         if(loop_cnt > 90000L) { // approximately 0.1sec experimentally
 795:motor.c       ****             loop_cnt=0;
 796:motor.c       ****             sec_cnt++;
 797:motor.c       ****             if((sec_cnt&0x03)==0x03)
 798:motor.c       ****                 LEDon();
 799:motor.c       ****             else
 800:motor.c       ****                 LEDoff();
 801:motor.c       ****         }
 802:motor.c       ****         if (DOWNSTREAM_USART.STATUS & USART_RXCIF_bm) {
 803:motor.c       ****             up_fifo[up_head++] = DOWNSTREAM_USART.DATA;
 804:motor.c       ****             up_head %= sizeof(up_fifo);
 805:motor.c       ****         }
 806:motor.c       ****         if (UPSTREAM_USART.STATUS & USART_RXCIF_bm) {
 807:motor.c       ****             down_fifo[down_head++] = UPSTREAM_USART.DATA;
 808:motor.c       ****             down_head %= sizeof(down_fifo);
 809:motor.c       ****         }
 810:motor.c       ****         if (up_head != up_tail && (UPSTREAM_USART.STATUS & USART_DREIF_bm)) {
 811:motor.c       ****             UPSTREAM_USART.DATA = up_fifo[up_tail++];
 812:motor.c       ****             up_tail %= sizeof(up_fifo);
 813:motor.c       ****         }
 814:motor.c       ****         if (down_head != down_tail && (DOWNSTREAM_USART.STATUS & USART_DREIF_bm)) {
 815:motor.c       ****             DOWNSTREAM_USART.DATA = down_fifo[down_tail++];
 816:motor.c       ****             down_tail %= sizeof(down_fifo);
 817:motor.c       ****         }
 818:motor.c       ****     }
 819:motor.c       **** 
 820:motor.c       ****     // 30sec timer finished, reset/reboot
 821:motor.c       ****     wdt_enable(WDT_PER_8CLK_gc);
 822:motor.c       ****     while(1);  // use watchdog timer to trigger a reset
 823:motor.c       **** }
 824:motor.c       **** 
 825:motor.c       **** static int handleBootloaderCommand(uint8_t *commandPacket)
 826:motor.c       **** {
 827:motor.c       ****     if(0x0f & commandPacket[PAYLOAD_OFFSET]){
 828:motor.c       ****         commandPacket[PAYLOAD_OFFSET] = (0xf0 & commandPacket[PAYLOAD_OFFSET]); // mask off chain i
 829:motor.c       ****         commandPacket[CHECKSUM_OFFSET]=computeChecksum((uint8_t *)commandPacket,COMMAND_PACKET_SIZE
 830:motor.c       ****         BootRelay(commandPacket);
 831:motor.c       ****     }
 832:motor.c       ****     else {
 833:motor.c       ****         // self bootload
 834:motor.c       ****         wdt_enable(WDT_PER_8CLK_gc);
 835:motor.c       ****         while(1);  // use watchdog timer to trigger a reset
 836:motor.c       ****     }
 837:motor.c       ****     return 5; // never get here, but keep compiler happy
 838:motor.c       **** }
 839:motor.c       **** 
 840:motor.c       **** 
 841:motor.c       **** /************************************************************************
 842:motor.c       ****  * void parseCommand(uint8_t *packetBuffer, uint8_t bytesReceived)
 843:motor.c       ****  *
 844:motor.c       ****  * Parse the command delivered in *packetBuffer with length bytesReceived
 845:motor.c       ****  * This routine performs the appropriate action and generates a response
 846:motor.c       ****  * packet if necessary.
 847:motor.c       ****  * Parity checking at the byte level has already been done in the RX
 848:motor.c       ****  * interrupt.  It has not been done in the case of DMA-driven reception
 849:motor.c       ****  * due to hardware limitations.
 850:motor.c       ****  ************************************************************************/
 851:motor.c       **** int processCommand(uint8_t *commandPacket,uint8_t *outputBuffer)
 852:motor.c       **** {
 853:motor.c       **** 
 854:motor.c       ****     uint8_t opcode;
 855:motor.c       **** 
 856:motor.c       ****     opcode = commandPacket[COMMAND_OFFSET] & OPCODE_BITMASK;
 857:motor.c       **** 
 858:motor.c       ****     switch(opcode)
 859:motor.c       ****     {
 860:motor.c       ****         case MOTOR_PARAMETER_RE_L_OPCODE: //Fallthrough intentional
 861:motor.c       ****         case MOTOR_PARAMETER_RE_H_OPCODE: //Fallthrough intentional
 862:motor.c       ****         case MOTOR_PARAMETER_WR_L_OPCODE: //Fallthrough intentional
 863:motor.c       ****         case MOTOR_PARAMETER_WR_H_OPCODE:
 864:motor.c       ****             return handleParameterCommand(commandPacket,outputBuffer);
 865:motor.c       **** 
 866:motor.c       ****         case DATA_COLLECTION_OPCODE:
 867:motor.c       ****             return handleCollectionCommand(commandPacket,outputBuffer);
 868:motor.c       **** 
 869:motor.c       ****         case MOTOR_COMMAND_OPCODE:
 870:motor.c       ****             return handleMotorCommand(commandPacket,outputBuffer);
 871:motor.c       **** 
 872:motor.c       ****         case CALIBRATION_OPCODE:
 873:motor.c       ****             return handleCalibrationCommand(commandPacket, outputBuffer);
 874:motor.c       **** 
 875:motor.c       ****         case BOOTLOADER_OPCODE:
 876:motor.c       ****             return handleBootloaderCommand(commandPacket);
 877:motor.c       **** 
 878:motor.c       ****         default:
 879:motor.c       ****             outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3;
 880:motor.c       ****             outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = opcode;
 881:motor.c       ****             outputBuffer[RESPONSE_STATUSCODE_OFFSET] = UNKNOWN_COMMAND;
 882:motor.c       ****             outputBuffer[3] = computeChecksum(outputBuffer,3); //this is the checksum
 883:motor.c       ****             return 4;
 884:motor.c       ****     }
 885:motor.c       **** }
 886:motor.c       **** 
 887:motor.c       **** void LEDon()
 888:motor.c       **** {
 889:motor.c       ****     PORTC.OUTSET = 0x80;
 890:motor.c       **** }
 891:motor.c       **** void LEDoff()
 892:motor.c       **** {
 893:motor.c       ****     PORTC.OUTCLR = 0x80;
 890               		.loc 1 893 0
 891 04d2 10E4      		ldi r17,lo8(1600)
 892 04d4 E12E      		mov r14,r17
 893 04d6 16E0      		ldi r17,hi8(1600)
 894 04d8 F12E      		mov r15,r17
 895 04da 10E8      		ldi r17,lo8(-128)
 896               	.LVL36:
 897               	.L28:
 898               	.LBE50:
 899               	.LBE49:
 793:motor.c       ****         loop_cnt++;
 900               		.loc 1 793 0
 901 04dc 0196      		adiw r24,1
 902 04de A11D      		adc r26,__zero_reg__
 903 04e0 B11D      		adc r27,__zero_reg__
 904               	.LVL37:
 794:motor.c       ****         if(loop_cnt > 90000L) { // approximately 0.1sec experimentally
 905               		.loc 1 794 0
 906 04e2 8139      		cpi r24,lo8(90001)
 907 04e4 EFE5      		ldi r30,hi8(90001)
 908 04e6 9E07      		cpc r25,r30
 909 04e8 E1E0      		ldi r30,hlo8(90001)
 910 04ea AE07      		cpc r26,r30
 911 04ec E0E0      		ldi r30,hhi8(90001)
 912 04ee BE07      		cpc r27,r30
 913 04f0 00F0      		brlo .L22
 914               	.LVL38:
 796:motor.c       ****             sec_cnt++;
 915               		.loc 1 796 0
 916 04f2 6F5F      		subi r22,lo8(-(1))
 917 04f4 7F4F      		sbci r23,hi8(-(1))
 918               	.LVL39:
 797:motor.c       ****             if((sec_cnt&0x03)==0x03)
 919               		.loc 1 797 0
 920 04f6 CB01      		movw r24,r22
 921 04f8 8370      		andi r24,lo8(3)
 922 04fa 9070      		andi r25,hi8(3)
 923               	.LBB52:
 924               	.LBB53:
 889:motor.c       ****     PORTC.OUTSET = 0x80;
 925               		.loc 1 889 0
 926 04fc F701      		movw r30,r14
 927               	.LBE53:
 928               	.LBE52:
 797:motor.c       ****             if((sec_cnt&0x03)==0x03)
 929               		.loc 1 797 0
 930 04fe 8330      		cpi r24,3
 931 0500 9105      		cpc r25,__zero_reg__
 932 0502 01F4      		brne .L23
 933               	.LBB55:
 934               	.LBB54:
 889:motor.c       ****     PORTC.OUTSET = 0x80;
 935               		.loc 1 889 0
 936 0504 1583      		std Z+5,r17
 937 0506 00C0      		rjmp .L37
 938               	.L23:
 939               	.LBE54:
 940               	.LBE55:
 941               	.LBB56:
 942               	.LBB51:
 943               		.loc 1 893 0
 944 0508 1683      		std Z+6,r17
 945               	.L37:
 795:motor.c       ****             loop_cnt=0;
 946               		.loc 1 795 0
 947 050a 80E0      		ldi r24,lo8(0)
 948 050c 90E0      		ldi r25,hi8(0)
 949 050e DC01      		movw r26,r24
 950               	.LVL40:
 951               	.L22:
 952               	.LBE51:
 953               	.LBE56:
 802:motor.c       ****         if (DOWNSTREAM_USART.STATUS & USART_RXCIF_bm) {
 954               		.loc 1 802 0
 955 0510 E091 B109 		lds r30,2481
 956 0514 E7FF      		sbrs r30,7
 957 0516 00C0      		rjmp .L24
 803:motor.c       ****             up_fifo[up_head++] = DOWNSTREAM_USART.DATA;
 958               		.loc 1 803 0
 959 0518 0091 B009 		lds r16,2480
 960 051c E1E1      		ldi r30,lo8(17)
 961 051e F0E0      		ldi r31,hi8(17)
 962 0520 EC0F      		add r30,r28
 963 0522 FD1F      		adc r31,r29
 964 0524 E50F      		add r30,r21
 965 0526 F11D      		adc r31,__zero_reg__
 966 0528 0083      		st Z,r16
 967 052a 5F5F      		subi r21,lo8(-(1))
 968               	.LVL41:
 804:motor.c       ****             up_head %= sizeof(up_fifo);
 969               		.loc 1 804 0
 970 052c 5F70      		andi r21,lo8(15)
 971               	.LVL42:
 972               	.L24:
 806:motor.c       ****         if (UPSTREAM_USART.STATUS & USART_RXCIF_bm) {
 973               		.loc 1 806 0
 974 052e E091 A109 		lds r30,2465
 975 0532 E7FF      		sbrs r30,7
 976 0534 00C0      		rjmp .L25
 807:motor.c       ****             down_fifo[down_head++] = UPSTREAM_USART.DATA;
 977               		.loc 1 807 0
 978 0536 0091 A009 		lds r16,2464
 979 053a E1E0      		ldi r30,lo8(1)
 980 053c F0E0      		ldi r31,hi8(1)
 981 053e EC0F      		add r30,r28
 982 0540 FD1F      		adc r31,r29
 983 0542 E20F      		add r30,r18
 984 0544 F11D      		adc r31,__zero_reg__
 985 0546 0083      		st Z,r16
 986 0548 2F5F      		subi r18,lo8(-(1))
 987               	.LVL43:
 808:motor.c       ****             down_head %= sizeof(down_fifo);
 988               		.loc 1 808 0
 989 054a 2F70      		andi r18,lo8(15)
 990               	.LVL44:
 991               	.L25:
 810:motor.c       ****         if (up_head != up_tail && (UPSTREAM_USART.STATUS & USART_DREIF_bm)) {
 992               		.loc 1 810 0
 993 054c 5417      		cp r21,r20
 994 054e 01F0      		breq .L26
 810:motor.c       ****         if (up_head != up_tail && (UPSTREAM_USART.STATUS & USART_DREIF_bm)) {
 995               		.loc 1 810 0 is_stmt 0 discriminator 1
 996 0550 E091 A109 		lds r30,2465
 997 0554 E5FF      		sbrs r30,5
 998 0556 00C0      		rjmp .L26
 811:motor.c       ****             UPSTREAM_USART.DATA = up_fifo[up_tail++];
 999               		.loc 1 811 0 is_stmt 1
 1000 0558 E1E1      		ldi r30,lo8(17)
 1001 055a F0E0      		ldi r31,hi8(17)
 1002 055c EC0F      		add r30,r28
 1003 055e FD1F      		adc r31,r29
 1004 0560 E40F      		add r30,r20
 1005 0562 F11D      		adc r31,__zero_reg__
 1006 0564 E081      		ld r30,Z
 1007 0566 E093 A009 		sts 2464,r30
 1008 056a 4F5F      		subi r20,lo8(-(1))
 1009               	.LVL45:
 812:motor.c       ****             up_tail %= sizeof(up_fifo);
 1010               		.loc 1 812 0
 1011 056c 4F70      		andi r20,lo8(15)
 1012               	.LVL46:
 1013               	.L26:
 814:motor.c       ****         if (down_head != down_tail && (DOWNSTREAM_USART.STATUS & USART_DREIF_bm)) {
 1014               		.loc 1 814 0
 1015 056e 2317      		cp r18,r19
 1016 0570 01F0      		breq .L27
 814:motor.c       ****         if (down_head != down_tail && (DOWNSTREAM_USART.STATUS & USART_DREIF_bm)) {
 1017               		.loc 1 814 0 is_stmt 0 discriminator 1
 1018 0572 E091 B109 		lds r30,2481
 1019 0576 E5FF      		sbrs r30,5
 1020 0578 00C0      		rjmp .L27
 815:motor.c       ****             DOWNSTREAM_USART.DATA = down_fifo[down_tail++];
 1021               		.loc 1 815 0 is_stmt 1
 1022 057a E1E0      		ldi r30,lo8(1)
 1023 057c F0E0      		ldi r31,hi8(1)
 1024 057e EC0F      		add r30,r28
 1025 0580 FD1F      		adc r31,r29
 1026 0582 E30F      		add r30,r19
 1027 0584 F11D      		adc r31,__zero_reg__
 1028 0586 E081      		ld r30,Z
 1029 0588 E093 B009 		sts 2480,r30
 1030 058c 3F5F      		subi r19,lo8(-(1))
 1031               	.LVL47:
 816:motor.c       ****             down_tail %= sizeof(down_fifo);
 1032               		.loc 1 816 0
 1033 058e 3F70      		andi r19,lo8(15)
 1034               	.LVL48:
 1035               	.L27:
 792:motor.c       ****     while(sec_cnt < 200) {
 1036               		.loc 1 792 0 discriminator 1
 1037 0590 683C      		cpi r22,200
 1038 0592 7105      		cpc r23,__zero_reg__
 1039 0594 04F4      		brge .+2
 1040 0596 00C0      		rjmp .L28
 821:motor.c       ****     wdt_enable(WDT_PER_8CLK_gc);
 1041               		.loc 1 821 0
 1042 0598 93E0      		ldi r25,lo8(3)
 1043 059a 88ED      		ldi r24,lo8(-40)
 1044               	.LVL49:
 1045               	/* #APP */
 1046               	 ;  821 "motor.c" 1
 1047 059c 08B6      		in __tmp_reg__, 56
 1048 059e 84BF      		out 52, r24
 1049 05a0 9093 8000 		sts 128, r25
 1050 05a4 A895      		wdr
 1051 05a6 08BE      		out 56, __tmp_reg__
 1052               		
 1053               	 ;  0 "" 2
 1054               	/* #NOAPP */
 1055               	.L29:
 1056 05a8 00C0      		rjmp .L29
 1057               		.cfi_endproc
 1058               	.LFE21:
 1060               	.global	processCommand
 1062               	processCommand:
 1063               	.LFB23:
 852:motor.c       **** {
 1064               		.loc 1 852 0
 1065               		.cfi_startproc
 1066               	.LVL50:
 1067 05aa CF92      		push r12
 1068               	.LCFI39:
 1069               		.cfi_def_cfa_offset 3
 1070               		.cfi_offset 12, -2
 1071 05ac DF92      		push r13
 1072               	.LCFI40:
 1073               		.cfi_def_cfa_offset 4
 1074               		.cfi_offset 13, -3
 1075 05ae EF92      		push r14
 1076               	.LCFI41:
 1077               		.cfi_def_cfa_offset 5
 1078               		.cfi_offset 14, -4
 1079 05b0 FF92      		push r15
 1080               	.LCFI42:
 1081               		.cfi_def_cfa_offset 6
 1082               		.cfi_offset 15, -5
 1083 05b2 0F93      		push r16
 1084               	.LCFI43:
 1085               		.cfi_def_cfa_offset 7
 1086               		.cfi_offset 16, -6
 1087 05b4 1F93      		push r17
 1088               	.LCFI44:
 1089               		.cfi_def_cfa_offset 8
 1090               		.cfi_offset 17, -7
 1091 05b6 CF93      		push r28
 1092               	.LCFI45:
 1093               		.cfi_def_cfa_offset 9
 1094               		.cfi_offset 28, -8
 1095 05b8 DF93      		push r29
 1096               	.LCFI46:
 1097               		.cfi_def_cfa_offset 10
 1098               		.cfi_offset 29, -9
 1099               	/* prologue: function */
 1100               	/* frame size = 0 */
 1101               	/* stack size = 8 */
 1102               	.L__stack_usage = 8
 1103 05ba EC01      		movw r28,r24
 1104 05bc 7B01      		movw r14,r22
 856:motor.c       ****     opcode = commandPacket[COMMAND_OFFSET] & OPCODE_BITMASK;
 1105               		.loc 1 856 0
 1106 05be 1981      		ldd r17,Y+1
 1107 05c0 012F      		mov r16,r17
 1108 05c2 007F      		andi r16,lo8(-16)
 1109               	.LVL51:
 858:motor.c       ****     switch(opcode)
 1110               		.loc 1 858 0
 1111 05c4 0038      		cpi r16,lo8(-128)
 1112 05c6 01F0      		breq .L41
 1113               	.LVL52:
 1114 05c8 0138      		cpi r16,lo8(-127)
 1115 05ca 00F4      		brsh .L45
 1116 05cc 0036      		cpi r16,lo8(96)
 1117 05ce 01F0      		breq .L41
 1118 05d0 0037      		cpi r16,lo8(112)
 1119 05d2 01F0      		breq .L41
 1120 05d4 0023      		tst r16
 1121 05d6 01F4      		brne .+2
 1122 05d8 00C0      		rjmp .L40
 1123 05da 00C0      		rjmp .L39
 1124               	.L45:
 1125 05dc 003A      		cpi r16,lo8(-96)
 1126 05de 01F4      		brne .+2
 1127 05e0 00C0      		rjmp .L42
 1128 05e2 013A      		cpi r16,lo8(-95)
 1129 05e4 00F4      		brsh .L46
 1130 05e6 0039      		cpi r16,lo8(-112)
 1131 05e8 01F0      		breq .+2
 1132 05ea 00C0      		rjmp .L39
 1133 05ec 00C0      		rjmp .L41
 1134               	.L46:
 1135 05ee 003B      		cpi r16,lo8(-80)
 1136 05f0 01F4      		brne .+2
 1137 05f2 00C0      		rjmp .L43
 1138 05f4 003C      		cpi r16,lo8(-64)
 1139 05f6 01F0      		breq .+2
 1140 05f8 00C0      		rjmp .L39
 1141 05fa 00C0      		rjmp .L107
 1142               	.L41:
 1143               	.LVL53:
 1144               	.LBB77:
 1145               	.LBB78:
 413:motor.c       ****     uint8_t selectedParameter = commandPacket[COMMAND_OFFSET] & PARAMETER_ADDRESS_BITMASK;
 1146               		.loc 1 413 0
 1147 05fc 1F71      		andi r17,lo8(31)
 1148               	.LVL54:
 415:motor.c       ****     if(selectedParameter < INT_PARAMETER_START) // float parameter
 1149               		.loc 1 415 0
 1150 05fe 1931      		cpi r17,lo8(25)
 1151 0600 00F4      		brsh .L47
 1152               	.LBB79:
 417:motor.c       ****         float* parameterPointer = &Parameter[selectedParameter];
 1153               		.loc 1 417 0
 1154 0602 E12F      		mov r30,r17
 1155 0604 F0E0      		ldi r31,lo8(0)
 1156               	.LVL55:
 1157 0606 EE0F      		lsl r30
 1158 0608 FF1F      		rol r31
 1159 060a EE0F      		lsl r30
 1160 060c FF1F      		rol r31
 1161               	.LVL56:
 420:motor.c       ****         if((opcode == MOTOR_PARAMETER_RE_H_OPCODE) || (opcode == MOTOR_PARAMETER_RE_L_OPCODE)) //re
 1162               		.loc 1 420 0
 1163 060e 0037      		cpi r16,lo8(112)
 1164 0610 01F0      		breq .L48
 1165 0612 0036      		cpi r16,lo8(96)
 1166 0614 01F4      		brne .L49
 1167               	.L48:
 422:motor.c       ****             convertFloatToArray(*parameterPointer, &outputBuffer[RESPONSE_PAYLOAD_OFFSET]);
 1168               		.loc 1 422 0
 1169 0616 E050      		subi r30,lo8(-(Parameter))
 1170 0618 F040      		sbci r31,hi8(-(Parameter))
 1171 061a 8081      		ld r24,Z
 1172 061c 9181      		ldd r25,Z+1
 1173 061e A281      		ldd r26,Z+2
 1174 0620 B381      		ldd r27,Z+3
 1175               	.LVL57:
 1176               	.LBB80:
 1177               	.LBB81:
 213:motor.c       ****     memcpy(outputArray,&inputFloat,4);
 1178               		.loc 1 213 0
 1179 0622 F701      		movw r30,r14
 1180               	.LVL58:
 1181 0624 8383      		std Z+3,r24
 1182 0626 9483      		std Z+4,r25
 1183 0628 A583      		std Z+5,r26
 1184 062a B683      		std Z+6,r27
 1185               	.LBE81:
 1186               	.LBE80:
 423:motor.c       ****             outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 7;
 1187               		.loc 1 423 0
 1188 062c 87E0      		ldi r24,lo8(7)
 1189               	.LVL59:
 1190 062e 00C0      		rjmp .L104
 1191               	.LVL60:
 1192               	.L49:
 1193               	.LBB82:
 1194               	.LBB83:
 1195               	.LBB84:
 201:motor.c       ****     return *(float *)packedInteger;
 1196               		.loc 1 201 0
 1197 0630 4A81      		ldd r20,Y+2
 1198 0632 5B81      		ldd r21,Y+3
 1199 0634 6C81      		ldd r22,Y+4
 1200 0636 7D81      		ldd r23,Y+5
 1201               	.LBE84:
 1202               	.LBE83:
 432:motor.c       ****             *parameterPointer = convertedData;
 1203               		.loc 1 432 0
 1204 0638 E050      		subi r30,lo8(-(Parameter))
 1205 063a F040      		sbci r31,hi8(-(Parameter))
 1206 063c 4083      		st Z,r20
 1207 063e 5183      		std Z+1,r21
 1208 0640 6283      		std Z+2,r22
 1209 0642 7383      		std Z+3,r23
 433:motor.c       ****             WriteFloatToEEPROM(selectedParameter, convertedData);
 1210               		.loc 1 433 0
 1211 0644 812F      		mov r24,r17
 1212 0646 0E94 0000 		call WriteFloatToEEPROM
 1213 064a 00C0      		rjmp .L53
 1214               	.LVL61:
 1215               	.L47:
 1216               	.LBE82:
 1217               	.LBE79:
 445:motor.c       ****         if((opcode == MOTOR_PARAMETER_RE_H_OPCODE) || (opcode == MOTOR_PARAMETER_RE_L_OPCODE)) //re
 1218               		.loc 1 445 0
 1219 064c 0037      		cpi r16,lo8(112)
 1220 064e 01F0      		breq .L51
 1221 0650 0036      		cpi r16,lo8(96)
 1222 0652 01F4      		brne .L52
 1223               	.L51:
 447:motor.c       ****             ReadIntFromEEPROM(selectedParameter, &outputBuffer[RESPONSE_PAYLOAD_OFFSET]);
 1224               		.loc 1 447 0
 1225 0654 B701      		movw r22,r14
 1226 0656 6D5F      		subi r22,lo8(-(3))
 1227 0658 7F4F      		sbci r23,hi8(-(3))
 1228 065a 812F      		mov r24,r17
 1229 065c 0E94 0000 		call ReadIntFromEEPROM
 448:motor.c       ****             outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 7;
 1230               		.loc 1 448 0
 1231 0660 87E0      		ldi r24,lo8(7)
 1232 0662 F701      		movw r30,r14
 1233               	.L104:
 1234 0664 8083      		st Z,r24
 449:motor.c       ****             outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = opcode;
 1235               		.loc 1 449 0
 1236 0666 0183      		std Z+1,r16
 450:motor.c       ****             outputBuffer[RESPONSE_STATUSCODE_OFFSET] = STATUS_OK;
 1237               		.loc 1 450 0
 1238 0668 1282      		std Z+2,__zero_reg__
 451:motor.c       ****             outputBuffer[7] = computeChecksum(outputBuffer, 7); //this is the checksum
 1239               		.loc 1 451 0
 1240 066a C701      		movw r24,r14
 1241 066c 67E0      		ldi r22,lo8(7)
 1242 066e 70E0      		ldi r23,hi8(7)
 1243 0670 0E94 0000 		call computeChecksum
 1244 0674 F701      		movw r30,r14
 1245 0676 8783      		std Z+7,r24
 452:motor.c       ****             return 8;
 1246               		.loc 1 452 0
 1247 0678 88E0      		ldi r24,lo8(8)
 1248 067a 90E0      		ldi r25,hi8(8)
 1249 067c 00C0      		rjmp .L55
 1250               	.L52:
 456:motor.c       ****             WriteIntToEEPROM(selectedParameter, &commandPacket[PAYLOAD_OFFSET]);
 1251               		.loc 1 456 0
 1252 067e BE01      		movw r22,r28
 1253 0680 6E5F      		subi r22,lo8(-(2))
 1254 0682 7F4F      		sbci r23,hi8(-(2))
 1255 0684 812F      		mov r24,r17
 1256 0686 0E94 0000 		call WriteIntToEEPROM
 458:motor.c       ****             if(selectedParameter == EEPROM_ADDRESS_LED) 
 1257               		.loc 1 458 0
 1258 068a 1F31      		cpi r17,lo8(31)
 1259 068c 01F4      		brne .L53
 460:motor.c       ****                 if(commandPacket[PAYLOAD_OFFSET+0] |
 1260               		.loc 1 460 0
 1261 068e 8B81      		ldd r24,Y+3
 1262 0690 9A81      		ldd r25,Y+2
 1263 0692 892B      		or r24,r25
 1264 0694 9C81      		ldd r25,Y+4
 1265 0696 892B      		or r24,r25
 1266 0698 9D81      		ldd r25,Y+5
 1267 069a 892B      		or r24,r25
 1268 069c 01F0      		breq .L54
 1269               	.LBB85:
 1270               	.LBB86:
 889:motor.c       ****     PORTC.OUTSET = 0x80;
 1271               		.loc 1 889 0
 1272 069e 80E8      		ldi r24,lo8(-128)
 1273 06a0 E0E4      		ldi r30,lo8(1600)
 1274 06a2 F6E0      		ldi r31,hi8(1600)
 1275 06a4 8583      		std Z+5,r24
 1276 06a6 00C0      		rjmp .L53
 1277               	.L54:
 1278               	.LBE86:
 1279               	.LBE85:
 1280               	.LBB87:
 1281               	.LBB88:
 1282               		.loc 1 893 0
 1283 06a8 80E8      		ldi r24,lo8(-128)
 1284 06aa E0E4      		ldi r30,lo8(1600)
 1285 06ac F6E0      		ldi r31,hi8(1600)
 1286 06ae 8683      		std Z+6,r24
 1287               	.L53:
 1288               	.LBE88:
 1289               	.LBE87:
 469:motor.c       ****             outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3;
 1290               		.loc 1 469 0
 1291 06b0 83E0      		ldi r24,lo8(3)
 1292 06b2 F701      		movw r30,r14
 1293 06b4 8083      		st Z,r24
 470:motor.c       ****             outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = opcode;
 1294               		.loc 1 470 0
 1295 06b6 0183      		std Z+1,r16
 1296 06b8 00C0      		rjmp .L106
 1297               	.LVL62:
 1298               	.L40:
 1299               	.LBE78:
 1300               	.LBE77:
 1301               	.LBB89:
 1302               	.LBB90:
 344:motor.c       ****     memcpy(&collectionBitfield,&commandPacket[PAYLOAD_OFFSET],2);
 1303               		.loc 1 344 0
 1304 06ba 0A81      		ldd r16,Y+2
 1305 06bc 1B81      		ldd r17,Y+3
 1306               	.LVL63:
 346:motor.c       ****     if(collectionBitfield & DATA_COLLECTION_TENSION_BITMASK)
 1307               		.loc 1 346 0
 1308 06be 15FF      		sbrs r17,5
 1309 06c0 00C0      		rjmp .L85
 348:motor.c       ****         memcpy(&outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize],&tension,4);
 1310               		.loc 1 348 0
 1311 06c2 8091 0000 		lds r24,tension
 1312 06c6 9091 0000 		lds r25,tension+1
 1313 06ca A091 0000 		lds r26,tension+2
 1314 06ce B091 0000 		lds r27,tension+3
 1315 06d2 FB01      		movw r30,r22
 1316 06d4 8383      		std Z+3,r24
 1317 06d6 9483      		std Z+4,r25
 1318 06d8 A583      		std Z+5,r26
 1319 06da B683      		std Z+6,r27
 1320               	.LVL64:
 349:motor.c       ****         responseSize += 4;
 1321               		.loc 1 349 0
 1322 06dc C4E0      		ldi r28,lo8(4)
 1323               	.LVL65:
 1324 06de 00C0      		rjmp .L56
 1325               	.LVL66:
 1326               	.L85:
 339:motor.c       ****     uint8_t responseSize = 0;
 1327               		.loc 1 339 0
 1328 06e0 C0E0      		ldi r28,lo8(0)
 1329               	.LVL67:
 1330               	.L56:
 352:motor.c       ****     if(collectionBitfield & DATA_COLLECTION_MOTORCURRENT_BITMASK)
 1331               		.loc 1 352 0
 1332 06e2 10FF      		sbrs r17,0
 1333 06e4 00C0      		rjmp .L57
 354:motor.c       ****         controlSignal = round(motorCurrent * 1000.0); //convert to mA
 1334               		.loc 1 354 0
 1335 06e6 6091 0000 		lds r22,motorCurrent
 1336 06ea 7091 0000 		lds r23,motorCurrent+1
 1337 06ee 8091 0000 		lds r24,motorCurrent+2
 1338 06f2 9091 0000 		lds r25,motorCurrent+3
 1339 06f6 20E0      		ldi r18,lo8(0x447a0000)
 1340 06f8 30E0      		ldi r19,hi8(0x447a0000)
 1341 06fa 4AE7      		ldi r20,hlo8(0x447a0000)
 1342 06fc 54E4      		ldi r21,hhi8(0x447a0000)
 1343 06fe 0E94 0000 		call __mulsf3
 1344 0702 0E94 0000 		call round
 1345 0706 0E94 0000 		call __fixunssfsi
 355:motor.c       ****         outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize] = controlSignal & 0x00FF;
 1346               		.loc 1 355 0
 1347 070a F701      		movw r30,r14
 1348 070c EC0F      		add r30,r28
 1349 070e F11D      		adc r31,__zero_reg__
 1350 0710 6383      		std Z+3,r22
 356:motor.c       ****         outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize+1] = (controlSignal & 0xFF00) >> 8;
 1351               		.loc 1 356 0
 1352 0712 7483      		std Z+4,r23
 357:motor.c       ****         responseSize += 2;
 1353               		.loc 1 357 0
 1354 0714 CE5F      		subi r28,lo8(-(2))
 1355               	.LVL68:
 1356               	.L57:
 360:motor.c       ****     if(collectionBitfield & DATA_COLLECTION_MOTORSTATORTEMP_BITMASK)
 1357               		.loc 1 360 0
 1358 0716 07FF      		sbrs r16,7
 1359 0718 00C0      		rjmp .L58
 362:motor.c       ****         controlSignal = round(statorTemperature * 100.0); //convert to hundredths of a degree
 1360               		.loc 1 362 0
 1361 071a 6091 0000 		lds r22,statorTemperature
 1362 071e 7091 0000 		lds r23,statorTemperature+1
 1363 0722 8091 0000 		lds r24,statorTemperature+2
 1364 0726 9091 0000 		lds r25,statorTemperature+3
 1365 072a 20E0      		ldi r18,lo8(0x42c80000)
 1366 072c 30E0      		ldi r19,hi8(0x42c80000)
 1367 072e 48EC      		ldi r20,hlo8(0x42c80000)
 1368 0730 52E4      		ldi r21,hhi8(0x42c80000)
 1369 0732 0E94 0000 		call __mulsf3
 1370 0736 0E94 0000 		call round
 1371 073a 0E94 0000 		call __fixunssfsi
 363:motor.c       ****         outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize] = controlSignal & 0x00FF;
 1372               		.loc 1 363 0
 1373 073e F701      		movw r30,r14
 1374 0740 EC0F      		add r30,r28
 1375 0742 F11D      		adc r31,__zero_reg__
 1376 0744 6383      		std Z+3,r22
 364:motor.c       ****         outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize+1] = (controlSignal & 0xFF00) >> 8;
 1377               		.loc 1 364 0
 1378 0746 7483      		std Z+4,r23
 365:motor.c       ****         responseSize += 2;
 1379               		.loc 1 365 0
 1380 0748 CE5F      		subi r28,lo8(-(2))
 1381               	.LVL69:
 1382               	.L58:
 368:motor.c       ****     if(collectionBitfield & DATA_COLLECTION_MOTORVELOCITY_BITMASK)
 1383               		.loc 1 368 0
 1384 074a 06FF      		sbrs r16,6
 1385 074c 00C0      		rjmp .L59
 370:motor.c       ****         controlSignal = averageRPM;
 1386               		.loc 1 370 0
 1387 074e 9091 0000 		lds r25,averageRPM
 1388 0752 8091 0000 		lds r24,averageRPM+1
 1389               	.LVL70:
 371:motor.c       ****         outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize] = controlSignal & 0x00FF;
 1390               		.loc 1 371 0
 1391 0756 F701      		movw r30,r14
 1392 0758 EC0F      		add r30,r28
 1393 075a F11D      		adc r31,__zero_reg__
 1394 075c 9383      		std Z+3,r25
 372:motor.c       ****         outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize+1] = (controlSignal & 0xFF00) >> 8;
 1395               		.loc 1 372 0
 1396 075e 8483      		std Z+4,r24
 373:motor.c       ****         responseSize += 2;
 1397               		.loc 1 373 0
 1398 0760 CE5F      		subi r28,lo8(-(2))
 1399               	.LVL71:
 1400               	.L59:
 376:motor.c       ****     if(collectionBitfield & DATA_COLLECTION_MOTORWINDINGTEMP_BITMASK)
 1401               		.loc 1 376 0
 1402 0762 03FF      		sbrs r16,3
 1403 0764 00C0      		rjmp .L60
 378:motor.c       ****         controlSignal = round((oldDeltaT + statorTemperature) * 100.0); //convert to hundredths of 
 1404               		.loc 1 378 0
 1405 0766 6091 0000 		lds r22,oldDeltaT
 1406 076a 7091 0000 		lds r23,oldDeltaT+1
 1407 076e 8091 0000 		lds r24,oldDeltaT+2
 1408 0772 9091 0000 		lds r25,oldDeltaT+3
 1409 0776 2091 0000 		lds r18,statorTemperature
 1410 077a 3091 0000 		lds r19,statorTemperature+1
 1411 077e 4091 0000 		lds r20,statorTemperature+2
 1412 0782 5091 0000 		lds r21,statorTemperature+3
 1413 0786 0E94 0000 		call __addsf3
 1414 078a 20E0      		ldi r18,lo8(0x42c80000)
 1415 078c 30E0      		ldi r19,hi8(0x42c80000)
 1416 078e 48EC      		ldi r20,hlo8(0x42c80000)
 1417 0790 52E4      		ldi r21,hhi8(0x42c80000)
 1418 0792 0E94 0000 		call __mulsf3
 1419 0796 0E94 0000 		call round
 1420 079a 0E94 0000 		call __fixunssfsi
 379:motor.c       ****         outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize] = controlSignal & 0x00FF;
 1421               		.loc 1 379 0
 1422 079e F701      		movw r30,r14
 1423 07a0 EC0F      		add r30,r28
 1424 07a2 F11D      		adc r31,__zero_reg__
 1425 07a4 6383      		std Z+3,r22
 380:motor.c       ****         outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize+1] = (controlSignal & 0xFF00) >> 8;
 1426               		.loc 1 380 0
 1427 07a6 7483      		std Z+4,r23
 381:motor.c       ****         responseSize += 2;
 1428               		.loc 1 381 0
 1429 07a8 CE5F      		subi r28,lo8(-(2))
 1430               	.LVL72:
 1431               	.L60:
 384:motor.c       ****     if(collectionBitfield & DATA_COLLECTION_MOTORHALL_BITMASK)
 1432               		.loc 1 384 0
 1433 07aa 02FF      		sbrs r16,2
 1434 07ac 00C0      		rjmp .L61
 386:motor.c       ****         outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize] = encoder & 0x00FF;
 1435               		.loc 1 386 0
 1436 07ae 8091 0000 		lds r24,encoder
 1437 07b2 9091 0000 		lds r25,encoder+1
 1438 07b6 F701      		movw r30,r14
 1439 07b8 EC0F      		add r30,r28
 1440 07ba F11D      		adc r31,__zero_reg__
 1441 07bc 8383      		std Z+3,r24
 387:motor.c       ****         outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize+1] = (encoder & 0xFF00) >> 8;
 1442               		.loc 1 387 0
 1443 07be 8091 0000 		lds r24,encoder
 1444 07c2 9091 0000 		lds r25,encoder+1
 1445 07c6 9483      		std Z+4,r25
 388:motor.c       ****         responseSize += 2;
 1446               		.loc 1 388 0
 1447 07c8 CE5F      		subi r28,lo8(-(2))
 1448               	.LVL73:
 1449               	.L61:
 391:motor.c       ****     if(collectionBitfield & DATA_COLLECTION_DEBUG_BITMASK)
 1450               		.loc 1 391 0
 1451 07ca 01FF      		sbrs r16,1
 1452 07cc 00C0      		rjmp .L62
 393:motor.c       ****         memcpy(&outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize],&RxCheckSumErrCnt,4);
 1453               		.loc 1 393 0
 1454 07ce F701      		movw r30,r14
 1455 07d0 EC0F      		add r30,r28
 1456 07d2 F11D      		adc r31,__zero_reg__
 1457 07d4 8091 0000 		lds r24,RxCheckSumErrCnt
 1458 07d8 9091 0000 		lds r25,RxCheckSumErrCnt+1
 1459 07dc A091 0000 		lds r26,RxCheckSumErrCnt+2
 1460 07e0 B091 0000 		lds r27,RxCheckSumErrCnt+3
 1461 07e4 8383      		std Z+3,r24
 1462 07e6 9483      		std Z+4,r25
 1463 07e8 A583      		std Z+5,r26
 1464 07ea B683      		std Z+6,r27
 394:motor.c       ****         responseSize += 4;
 1465               		.loc 1 394 0
 1466 07ec CC5F      		subi r28,lo8(-(4))
 1467               	.LVL74:
 1468               	.L62:
 397:motor.c       ****     outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3+responseSize;
 1469               		.loc 1 397 0
 1470 07ee 8C2F      		mov r24,r28
 1471 07f0 8D5F      		subi r24,lo8(-(3))
 1472 07f2 F701      		movw r30,r14
 1473 07f4 8083      		st Z,r24
 398:motor.c       ****     outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = DATA_COLLECTION_OPCODE;
 1474               		.loc 1 398 0
 1475 07f6 1182      		std Z+1,__zero_reg__
 399:motor.c       ****     outputBuffer[RESPONSE_STATUSCODE_OFFSET] = STATUS_OK;
 1476               		.loc 1 399 0
 1477 07f8 1282      		std Z+2,__zero_reg__
 400:motor.c       ****     outputBuffer[3+responseSize] = computeChecksum(outputBuffer,3+responseSize); //this is the chec
 1478               		.loc 1 400 0
 1479 07fa D0E0      		ldi r29,lo8(0)
 1480 07fc BE01      		movw r22,r28
 1481 07fe 6D5F      		subi r22,lo8(-(3))
 1482 0800 7F4F      		sbci r23,hi8(-(3))
 1483 0802 8701      		movw r16,r14
 1484               	.LVL75:
 1485 0804 060F      		add r16,r22
 1486 0806 171F      		adc r17,r23
 1487 0808 C701      		movw r24,r14
 1488 080a 0E94 0000 		call computeChecksum
 1489 080e F801      		movw r30,r16
 1490 0810 8083      		st Z,r24
 401:motor.c       ****     return 4+responseSize;
 1491               		.loc 1 401 0
 1492 0812 CE01      		movw r24,r28
 1493 0814 0496      		adiw r24,4
 1494               	.LBE90:
 1495               	.LBE89:
 867:motor.c       ****             return handleCollectionCommand(commandPacket,outputBuffer);
 1496               		.loc 1 867 0
 1497 0816 00C0      		rjmp .L55
 1498               	.LVL76:
 1499               	.L42:
 1500               	.LBB91:
 1501               	.LBB92:
 491:motor.c       ****     controlScheme = commandPacket[COMMAND_OFFSET] & MOTOR_COMMAND_SCHEME_BITMASK;
 1502               		.loc 1 491 0
 1503 0818 E12F      		mov r30,r17
 1504 081a E370      		andi r30,lo8(3)
 1505               	.LBE92:
 1506               	.LBE91:
 867:motor.c       ****             return handleCollectionCommand(commandPacket,outputBuffer);
 1507               		.loc 1 867 0
 1508 081c F0E0      		ldi r31,lo8(0)
 1509 081e E050      		subi r30,lo8(-(CSWTCH.28))
 1510 0820 F040      		sbci r31,hi8(-(CSWTCH.28))
 1511 0822 D080      		ld r13,Z
 1512               	.LVL77:
 1513               	.LBB95:
 1514               	.LBB93:
 490:motor.c       ****     motorDirection = commandPacket[COMMAND_OFFSET] & MOTOR_COMMAND_DIRECTION_BITMASK;
 1515               		.loc 1 490 0
 1516 0824 1C70      		andi r17,lo8(12)
 1517               	.LVL78:
 513:motor.c       ****     switch(motorDirection)
 1518               		.loc 1 513 0
 1519 0826 1430      		cpi r17,lo8(4)
 1520 0828 01F0      		breq .L86
 1521 082a 1830      		cpi r17,lo8(8)
 1522 082c 01F0      		breq .+2
 1523 082e 00C0      		rjmp .L98
 516:motor.c       ****             newDirection = DIRECTION_FORWARD;
 1524               		.loc 1 516 0
 1525 0830 CC24      		clr r12
 1526 0832 C394      		inc r12
 1527 0834 00C0      		rjmp .L64
 1528               	.L86:
 519:motor.c       ****             newDirection = DIRECTION_REVERSE;
 1529               		.loc 1 519 0
 1530 0836 02E0      		ldi r16,lo8(2)
 1531 0838 C02E      		mov r12,r16
 1532               	.LVL79:
 1533               	.L64:
 538:motor.c       ****     else if (getMotorDirection() == DIRECTION_STOP)
 1534               		.loc 1 538 0
 1535 083a 0E94 0000 		call getMotorDirection
 1536               	.LVL80:
 1537 083e 8823      		tst r24
 1538 0840 01F4      		brne .L66
 542:motor.c       ****         resetPIDController();
 1539               		.loc 1 542 0
 1540 0842 0E94 0000 		call resetPIDController
 543:motor.c       ****         updateMotorVoltage(0x00);
 1541               		.loc 1 543 0
 1542 0846 80E0      		ldi r24,lo8(0)
 1543 0848 0E94 0000 		call updateMotorVoltage
 1544               	.LVL81:
 1545               	.L66:
 549:motor.c       ****     setpoint = *(uint16_t *)&commandPacket[PAYLOAD_OFFSET];
 1546               		.loc 1 549 0
 1547 084c 0A80      		ldd __tmp_reg__,Y+2
 1548 084e DB81      		ldd r29,Y+3
 1549 0850 C02D      		mov r28,__tmp_reg__
 1550               	.LVL82:
 552:motor.c       ****     switch(newScheme)
 1551               		.loc 1 552 0
 1552 0852 F1E0      		ldi r31,lo8(1)
 1553 0854 DF16      		cp r13,r31
 1554 0856 01F0      		breq .L69
 1555 0858 DF16      		cp r13,r31
 1556 085a 00F0      		brlo .L68
 1557 085c 22E0      		ldi r18,lo8(2)
 1558 085e D216      		cp r13,r18
 1559 0860 01F4      		brne .+2
 1560 0862 00C0      		rjmp .L70
 1561 0864 84E0      		ldi r24,lo8(4)
 1562 0866 D816      		cp r13,r24
 1563 0868 01F0      		breq .+2
 1564 086a 00C0      		rjmp .L99
 1565 086c 00C0      		rjmp .L108
 1566               	.L68:
 555:motor.c       ****             cli();
 1567               		.loc 1 555 0
 1568               	/* #APP */
 1569               	 ;  555 "motor.c" 1
 1570 086e F894      		cli
 1571               	 ;  0 "" 2
 556:motor.c       ****             if((setpoint > MAXIMUM_VOLTAGE_COMMAND) || (setpoint < MINIMUM_VOLTAGE_COMMAND))
 1572               		.loc 1 556 0
 1573               	/* #NOAPP */
 1574 0870 EDEF      		ldi r30,hi8(-767)
 1575 0872 C130      		cpi r28,lo8(-767)
 1576 0874 DE07      		cpc r29,r30
 1577 0876 00F0      		brlo .+2
 1578 0878 00C0      		rjmp .L96
 561:motor.c       ****             applySetpoint = thermalCheckSetpoint(CONTROL_SCHEME_VOLTAGE, setpoint);
 1579               		.loc 1 561 0
 1580 087a 80E0      		ldi r24,lo8(0)
 1581 087c BE01      		movw r22,r28
 1582 087e 0E94 0000 		call thermalCheckSetpoint
 1583 0882 8C01      		movw r16,r24
 1584               	.LVL83:
 562:motor.c       ****             if((applySetpoint == THERMAL_DELAY) || (applySetpoint == THERMAL_OK))
 1585               		.loc 1 562 0
 1586 0884 0197      		sbiw r24,1
 1587               	.LVL84:
 1588 0886 8230      		cpi r24,2
 1589 0888 9105      		cpc r25,__zero_reg__
 1590 088a 00F0      		brlo .+2
 1591 088c 00C0      		rjmp .L97
 564:motor.c       ****                 PID_state.controlScheme = CONTROL_SCHEME_VOLTAGE;
 1592               		.loc 1 564 0
 1593 088e 1092 0000 		sts PID_state+8,__zero_reg__
 565:motor.c       ****                 PID_state.setpoint = setpoint;
 1594               		.loc 1 565 0
 1595 0892 C093 0000 		sts PID_state+9,r28
 1596 0896 D093 0000 		sts PID_state+9+1,r29
 566:motor.c       ****                 updateMotorDirection(newDirection);
 1597               		.loc 1 566 0
 1598 089a 8C2D      		mov r24,r12
 1599 089c 0E94 0000 		call updateMotorDirection
 573:motor.c       ****             if(applySetpoint == THERMAL_OK)
 1600               		.loc 1 573 0
 1601 08a0 0230      		cpi r16,2
 1602 08a2 1105      		cpc r17,__zero_reg__
 1603 08a4 01F0      		breq .+2
 1604 08a6 00C0      		rjmp .L90
 576:motor.c       ****                 updateMotorVoltage(setpoint / 256);
 1605               		.loc 1 576 0
 1606 08a8 8D2F      		mov r24,r29
 1607 08aa 0E94 0000 		call updateMotorVoltage
 1608 08ae 00C0      		rjmp .L97
 1609               	.LVL85:
 1610               	.L69:
 582:motor.c       ****             cli();
 1611               		.loc 1 582 0
 1612               	/* #APP */
 1613               	 ;  582 "motor.c" 1
 1614 08b0 F894      		cli
 1615               	 ;  0 "" 2
 583:motor.c       ****             if((setpoint > Parameter[PARAMETER_MAXIMUM_RPM]) || (setpoint < MINIMUM_VELOCITY_COMMAN
 1616               		.loc 1 583 0
 1617               	/* #NOAPP */
 1618 08b2 BE01      		movw r22,r28
 1619 08b4 80E0      		ldi r24,lo8(0)
 1620 08b6 90E0      		ldi r25,hi8(0)
 1621 08b8 0E94 0000 		call __floatunsisf
 1622 08bc 2091 0000 		lds r18,Parameter+72
 1623 08c0 3091 0000 		lds r19,Parameter+72+1
 1624 08c4 4091 0000 		lds r20,Parameter+72+2
 1625 08c8 5091 0000 		lds r21,Parameter+72+3
 1626 08cc 0E94 0000 		call __gtsf2
 1627 08d0 1816      		cp __zero_reg__,r24
 1628 08d2 04F4      		brge .+2
 1629 08d4 00C0      		rjmp .L96
 1630 08d6 C83C      		cpi r28,200
 1631 08d8 D105      		cpc r29,__zero_reg__
 1632 08da 00F4      		brsh .+2
 1633 08dc 00C0      		rjmp .L96
 588:motor.c       ****             applySetpoint = thermalCheckSetpoint(CONTROL_SCHEME_VELOCITY, setpoint);
 1634               		.loc 1 588 0
 1635 08de 81E0      		ldi r24,lo8(1)
 1636 08e0 BE01      		movw r22,r28
 1637 08e2 0E94 0000 		call thermalCheckSetpoint
 1638 08e6 8C01      		movw r16,r24
 1639               	.LVL86:
 590:motor.c       ****             if((applySetpoint == THERMAL_DELAY) || (applySetpoint == THERMAL_OK))
 1640               		.loc 1 590 0
 1641 08e8 0197      		sbiw r24,1
 1642               	.LVL87:
 1643 08ea 8230      		cpi r24,2
 1644 08ec 9105      		cpc r25,__zero_reg__
 1645 08ee 00F0      		brlo .+2
 1646 08f0 00C0      		rjmp .L97
 595:motor.c       ****                 PID_state.setpoint = setpoint;
 1647               		.loc 1 595 0
 1648 08f2 C093 0000 		sts PID_state+9,r28
 1649 08f6 D093 0000 		sts PID_state+9+1,r29
 596:motor.c       ****                 if((applySetpoint == THERMAL_OK) && (PID_state.controlScheme != CONTROL_SCHEME_VELO
 1650               		.loc 1 596 0
 1651 08fa 0230      		cpi r16,2
 1652 08fc 1105      		cpc r17,__zero_reg__
 1653 08fe 01F4      		brne .L72
 1654 0900 8091 0000 		lds r24,PID_state+8
 1655 0904 8130      		cpi r24,lo8(1)
 1656 0906 01F0      		breq .L72
 1657 0908 0E94 0000 		call getMotorDirection
 1658 090c 8823      		tst r24
 1659 090e 01F0      		breq .L72
 599:motor.c       ****                     PIDPreset(CONTROL_SCHEME_VELOCITY);
 1660               		.loc 1 599 0
 1661 0910 81E0      		ldi r24,lo8(1)
 1662 0912 0E94 0000 		call PIDPreset
 1663               	.L72:
 601:motor.c       ****                 PID_state.controlScheme = CONTROL_SCHEME_VELOCITY;
 1664               		.loc 1 601 0
 1665 0916 81E0      		ldi r24,lo8(1)
 1666 0918 00C0      		rjmp .L105
 1667               	.LVL88:
 1668               	.L70:
 612:motor.c       ****             cli();
 1669               		.loc 1 612 0
 1670               	/* #APP */
 1671               	 ;  612 "motor.c" 1
 1672 091a F894      		cli
 1673               	 ;  0 "" 2
 613:motor.c       ****             if((setpoint > MAXIMUM_CURRENT_COMMAND) || (setpoint < MINIMUM_CURRENT_COMMAND))
 1674               		.loc 1 613 0
 1675               	/* #NOAPP */
 1676 091c CE01      		movw r24,r28
 1677 091e 0197      		sbiw r24,1
 1678 0920 F5E0      		ldi r31,hi8(1500)
 1679 0922 8C3D      		cpi r24,lo8(1500)
 1680 0924 9F07      		cpc r25,r31
 1681 0926 00F0      		brlo .+2
 1682 0928 00C0      		rjmp .L96
 618:motor.c       ****             applySetpoint = thermalCheckSetpoint(CONTROL_SCHEME_CURRENT, setpoint);
 1683               		.loc 1 618 0
 1684 092a 82E0      		ldi r24,lo8(2)
 1685 092c BE01      		movw r22,r28
 1686 092e 0E94 0000 		call thermalCheckSetpoint
 1687 0932 8C01      		movw r16,r24
 1688               	.LVL89:
 619:motor.c       ****             if((applySetpoint == THERMAL_DELAY) || (applySetpoint == THERMAL_OK))
 1689               		.loc 1 619 0
 1690 0934 0197      		sbiw r24,1
 1691               	.LVL90:
 1692 0936 8230      		cpi r24,2
 1693 0938 9105      		cpc r25,__zero_reg__
 1694 093a 00F0      		brlo .+2
 1695 093c 00C0      		rjmp .L97
 624:motor.c       ****                 PID_state.setpoint = setpoint;
 1696               		.loc 1 624 0
 1697 093e C093 0000 		sts PID_state+9,r28
 1698 0942 D093 0000 		sts PID_state+9+1,r29
 625:motor.c       ****                 if((applySetpoint == THERMAL_OK) && (PID_state.controlScheme != CONTROL_SCHEME_CURR
 1699               		.loc 1 625 0
 1700 0946 0230      		cpi r16,2
 1701 0948 1105      		cpc r17,__zero_reg__
 1702 094a 01F4      		brne .L73
 1703 094c 8091 0000 		lds r24,PID_state+8
 1704 0950 8230      		cpi r24,lo8(2)
 1705 0952 01F0      		breq .L73
 1706 0954 0E94 0000 		call getMotorDirection
 1707 0958 8823      		tst r24
 1708 095a 01F0      		breq .L73
 628:motor.c       ****                     PIDPreset(CONTROL_SCHEME_CURRENT);
 1709               		.loc 1 628 0
 1710 095c 82E0      		ldi r24,lo8(2)
 1711 095e 0E94 0000 		call PIDPreset
 1712               	.L73:
 630:motor.c       ****                 PID_state.controlScheme = CONTROL_SCHEME_CURRENT;
 1713               		.loc 1 630 0
 1714 0962 82E0      		ldi r24,lo8(2)
 1715               	.L105:
 1716 0964 8093 0000 		sts PID_state+8,r24
 631:motor.c       ****                 updateMotorDirection(newDirection);
 1717               		.loc 1 631 0
 1718 0968 8C2D      		mov r24,r12
 1719 096a 0E94 0000 		call updateMotorDirection
 1720 096e 00C0      		rjmp .L97
 1721               	.LVL91:
 1722               	.L108:
 641:motor.c       ****             cli();
 1723               		.loc 1 641 0
 1724               	/* #APP */
 1725               	 ;  641 "motor.c" 1
 1726 0970 F894      		cli
 1727               	 ;  0 "" 2
 642:motor.c       ****             positionSetPoint = (int16_t)setpoint;
 1728               		.loc 1 642 0
 1729               	/* #NOAPP */
 1730 0972 C093 0000 		sts positionSetPoint,r28
 1731 0976 D093 0000 		sts positionSetPoint+1,r29
 643:motor.c       ****             if((positionSetPoint > MAXIMUM_POSITION_COMMAND) || (positionSetPoint < MINIMUM_POSITIO
 1732               		.loc 1 643 0
 1733 097a CE01      		movw r24,r28
 1734 097c 805E      		subi r24,lo8(-(7200))
 1735 097e 934E      		sbci r25,hi8(-(7200))
 1736 0980 E8E3      		ldi r30,hi8(14401)
 1737 0982 8134      		cpi r24,lo8(14401)
 1738 0984 9E07      		cpc r25,r30
 1739 0986 00F4      		brsh .L96
 649:motor.c       ****             setpoint = positionControl(positionSetPoint);
 1740               		.loc 1 649 0
 1741 0988 CE01      		movw r24,r28
 1742 098a 0E94 0000 		call positionControl
 1743 098e EC01      		movw r28,r24
 1744               	.LVL92:
 651:motor.c       ****             applySetpoint = thermalCheckSetpoint(CONTROL_SCHEME_VELOCITY, setpoint);
 1745               		.loc 1 651 0
 1746 0990 81E0      		ldi r24,lo8(1)
 1747               	.LVL93:
 1748 0992 BE01      		movw r22,r28
 1749 0994 0E94 0000 		call thermalCheckSetpoint
 1750 0998 8C01      		movw r16,r24
 1751               	.LVL94:
 653:motor.c       ****             if((applySetpoint == THERMAL_DELAY) || (applySetpoint == THERMAL_OK))
 1752               		.loc 1 653 0
 1753 099a 0197      		sbiw r24,1
 1754               	.LVL95:
 1755 099c 8230      		cpi r24,2
 1756 099e 9105      		cpc r25,__zero_reg__
 1757 09a0 00F4      		brsh .L97
 658:motor.c       ****                 PID_state.setpoint = setpoint;
 1758               		.loc 1 658 0
 1759 09a2 C093 0000 		sts PID_state+9,r28
 1760 09a6 D093 0000 		sts PID_state+9+1,r29
 664:motor.c       ****                 PID_state.controlScheme = CONTROL_SCHEME_POSITION;
 1761               		.loc 1 664 0
 1762 09aa D092 0000 		sts PID_state+8,r13
 1763 09ae 00C0      		rjmp .L97
 1764               	.LVL96:
 1765               	.L99:
 550:motor.c       ****     rejectSetpoint = 0;
 1766               		.loc 1 550 0
 1767 09b0 C0E0      		ldi r28,lo8(0)
 1768 09b2 D0E0      		ldi r29,hi8(0)
 1769               	.LVL97:
 1770 09b4 00C0      		rjmp .L101
 1771               	.LVL98:
 1772               	.L90:
 1773 09b6 C0E0      		ldi r28,lo8(0)
 1774 09b8 D0E0      		ldi r29,hi8(0)
 1775               	.LVL99:
 573:motor.c       ****             if(applySetpoint == THERMAL_OK)
 1776               		.loc 1 573 0
 1777 09ba 01E0      		ldi r16,lo8(1)
 1778 09bc 10E0      		ldi r17,hi8(1)
 1779               	.LVL100:
 1780 09be 00C0      		rjmp .L67
 1781               	.LVL101:
 1782               	.L96:
 645:motor.c       ****                 rejectSetpoint = 1;
 1783               		.loc 1 645 0
 1784 09c0 C1E0      		ldi r28,lo8(1)
 1785 09c2 D0E0      		ldi r29,hi8(1)
 1786               	.LVL102:
 1787               	.L101:
 487:motor.c       ****     int applySetpoint = THERMAL_DISCARD;
 1788               		.loc 1 487 0
 1789 09c4 00E0      		ldi r16,lo8(0)
 1790 09c6 10E0      		ldi r17,hi8(0)
 1791 09c8 00C0      		rjmp .L67
 1792               	.LVL103:
 1793               	.L97:
 550:motor.c       ****     rejectSetpoint = 0;
 1794               		.loc 1 550 0
 1795 09ca C0E0      		ldi r28,lo8(0)
 1796 09cc D0E0      		ldi r29,hi8(0)
 1797               	.LVL104:
 1798               	.L67:
 678:motor.c       ****     sei();
 1799               		.loc 1 678 0
 1800               	/* #APP */
 1801               	 ;  678 "motor.c" 1
 1802 09ce 7894      		sei
 1803               	 ;  0 "" 2
 680:motor.c       ****     updateMotor(); //forceMotorUpdate();
 1804               		.loc 1 680 0
 1805               	/* #NOAPP */
 1806 09d0 0E94 0000 		call updateMotor
 682:motor.c       ****     if(newDirection == DIRECTION_STOP)
 1807               		.loc 1 682 0
 1808 09d4 CC20      		tst r12
 1809 09d6 01F0      		breq .L80
 1810               	.L74:
 686:motor.c       ****     else if(rejectSetpoint) 
 1811               		.loc 1 686 0
 1812 09d8 2097      		sbiw r28,0
 1813 09da 01F0      		breq .L76
 688:motor.c       ****         outputBuffer[RESPONSE_STATUSCODE_OFFSET] = OUT_OF_RANGE;
 1814               		.loc 1 688 0
 1815 09dc 82E8      		ldi r24,lo8(-126)
 1816 09de 00C0      		rjmp .L102
 1817               	.L76:
 692:motor.c       ****         switch(applySetpoint)
 1818               		.loc 1 692 0
 1819 09e0 0130      		cpi r16,1
 1820 09e2 1105      		cpc r17,__zero_reg__
 1821 09e4 01F0      		breq .L79
 1822 09e6 0230      		cpi r16,2
 1823 09e8 1105      		cpc r17,__zero_reg__
 1824 09ea 01F4      		brne .L109
 1825               	.L80:
 695:motor.c       ****                 outputBuffer[RESPONSE_STATUSCODE_OFFSET] = STATUS_OK;
 1826               		.loc 1 695 0
 1827 09ec F701      		movw r30,r14
 1828 09ee 1282      		std Z+2,__zero_reg__
 1829 09f0 00C0      		rjmp .L75
 1830               	.L79:
 698:motor.c       ****                 outputBuffer[RESPONSE_STATUSCODE_OFFSET] = DELAYED_ERROR;
 1831               		.loc 1 698 0
 1832 09f2 80E8      		ldi r24,lo8(-128)
 1833 09f4 00C0      		rjmp .L102
 1834               	.L109:
 704:motor.c       ****                 outputBuffer[RESPONSE_STATUSCODE_OFFSET] = MANDATORY_COOLDOWN;
 1835               		.loc 1 704 0
 1836 09f6 81E8      		ldi r24,lo8(-127)
 1837               	.L102:
 1838 09f8 F701      		movw r30,r14
 1839 09fa 8283      		std Z+2,r24
 1840               	.L75:
 709:motor.c       ****     outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3;
 1841               		.loc 1 709 0
 1842 09fc 83E0      		ldi r24,lo8(3)
 1843 09fe F701      		movw r30,r14
 1844 0a00 8083      		st Z,r24
 710:motor.c       ****     outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = MOTOR_COMMAND_OPCODE;
 1845               		.loc 1 710 0
 1846 0a02 80EA      		ldi r24,lo8(-96)
 1847 0a04 8183      		std Z+1,r24
 1848 0a06 00C0      		rjmp .L103
 1849               	.LVL105:
 1850               	.L107:
 1851               	.LBE93:
 1852               	.LBE95:
 1853               	.LBB96:
 1854               	.LBB97:
 721:motor.c       ****     memcpy(&collectionBitfield,&commandPacket[PAYLOAD_OFFSET],2);
 1855               		.loc 1 721 0
 1856 0a08 8A81      		ldd r24,Y+2
 1857               	.LVL106:
 723:motor.c       ****     if (collectionBitfield & DATA_COLLECTION_DEBUG_BITMASK)
 1858               		.loc 1 723 0
 1859 0a0a 81FF      		sbrs r24,1
 1860 0a0c 00C0      		rjmp .L81
 725:motor.c       ****         RxCheckSumErrCnt[0] = 0;
 1861               		.loc 1 725 0
 1862 0a0e 1092 0000 		sts RxCheckSumErrCnt,__zero_reg__
 1863 0a12 1092 0000 		sts RxCheckSumErrCnt+1,__zero_reg__
 726:motor.c       ****         RxCheckSumErrCnt[1] = 0;
 1864               		.loc 1 726 0
 1865 0a16 1092 0000 		sts RxCheckSumErrCnt+2,__zero_reg__
 1866 0a1a 1092 0000 		sts RxCheckSumErrCnt+2+1,__zero_reg__
 1867               	.L81:
 729:motor.c       ****     if (collectionBitfield & DATA_COLLECTION_MOTORHALL_BITMASK)
 1868               		.loc 1 729 0
 1869 0a1e 82FF      		sbrs r24,2
 1870 0a20 00C0      		rjmp .L82
 731:motor.c       ****         cli();
 1871               		.loc 1 731 0
 1872               	/* #APP */
 1873               	 ;  731 "motor.c" 1
 1874 0a22 F894      		cli
 1875               	 ;  0 "" 2
 732:motor.c       ****         encoder = 0;
 1876               		.loc 1 732 0
 1877               	/* #NOAPP */
 1878 0a24 1092 0000 		sts encoder,__zero_reg__
 1879 0a28 1092 0000 		sts encoder+1,__zero_reg__
 733:motor.c       ****         sei();
 1880               		.loc 1 733 0
 1881               	/* #APP */
 1882               	 ;  733 "motor.c" 1
 1883 0a2c 7894      		sei
 1884               	 ;  0 "" 2
 1885               	/* #NOAPP */
 1886               	.L82:
 736:motor.c       ****     outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3;
 1887               		.loc 1 736 0
 1888 0a2e 83E0      		ldi r24,lo8(3)
 1889 0a30 F701      		movw r30,r14
 1890 0a32 8083      		st Z,r24
 737:motor.c       ****     outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = CALIBRATION_OPCODE;
 1891               		.loc 1 737 0
 1892 0a34 80EC      		ldi r24,lo8(-64)
 1893 0a36 8183      		std Z+1,r24
 1894               	.LVL107:
 1895               	.L106:
 738:motor.c       ****     outputBuffer[RESPONSE_STATUSCODE_OFFSET] = STATUS_OK;
 1896               		.loc 1 738 0
 1897 0a38 1282      		std Z+2,__zero_reg__
 1898 0a3a 00C0      		rjmp .L103
 1899               	.L43:
 1900               	.LVL108:
 1901               	.LBE97:
 1902               	.LBE96:
 1903               	.LBB98:
 1904               	.LBB99:
 827:motor.c       ****     if(0x0f & commandPacket[PAYLOAD_OFFSET]){
 1905               		.loc 1 827 0
 1906 0a3c 8A81      		ldd r24,Y+2
 1907 0a3e 982F      		mov r25,r24
 1908 0a40 9F70      		andi r25,lo8(15)
 1909 0a42 01F0      		breq .L83
 828:motor.c       ****         commandPacket[PAYLOAD_OFFSET] = (0xf0 & commandPacket[PAYLOAD_OFFSET]); // mask off chain i
 1910               		.loc 1 828 0
 1911 0a44 807F      		andi r24,lo8(-16)
 1912 0a46 8A83      		std Y+2,r24
 829:motor.c       ****         commandPacket[CHECKSUM_OFFSET]=computeChecksum((uint8_t *)commandPacket,COMMAND_PACKET_SIZE
 1913               		.loc 1 829 0
 1914 0a48 CE01      		movw r24,r28
 1915 0a4a 66E0      		ldi r22,lo8(6)
 1916 0a4c 70E0      		ldi r23,hi8(6)
 1917 0a4e 0E94 0000 		call computeChecksum
 1918 0a52 8E83      		std Y+6,r24
 830:motor.c       ****         BootRelay(commandPacket);
 1919               		.loc 1 830 0
 1920 0a54 CE01      		movw r24,r28
 1921 0a56 0E94 0000 		call BootRelay
 1922               	.L83:
 834:motor.c       ****         wdt_enable(WDT_PER_8CLK_gc);
 1923               		.loc 1 834 0
 1924 0a5a 93E0      		ldi r25,lo8(3)
 1925 0a5c 88ED      		ldi r24,lo8(-40)
 1926               	/* #APP */
 1927               	 ;  834 "motor.c" 1
 1928 0a5e 08B6      		in __tmp_reg__, 56
 1929 0a60 84BF      		out 52, r24
 1930 0a62 9093 8000 		sts 128, r25
 1931 0a66 A895      		wdr
 1932 0a68 08BE      		out 56, __tmp_reg__
 1933               		
 1934               	 ;  0 "" 2
 1935               	/* #NOAPP */
 1936               	.L84:
 1937 0a6a 00C0      		rjmp .L84
 1938               	.LVL109:
 1939               	.L39:
 1940               	.LBE99:
 1941               	.LBE98:
 879:motor.c       ****             outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3;
 1942               		.loc 1 879 0
 1943 0a6c 83E0      		ldi r24,lo8(3)
 1944 0a6e F701      		movw r30,r14
 1945 0a70 8083      		st Z,r24
 880:motor.c       ****             outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = opcode;
 1946               		.loc 1 880 0
 1947 0a72 0183      		std Z+1,r16
 881:motor.c       ****             outputBuffer[RESPONSE_STATUSCODE_OFFSET] = UNKNOWN_COMMAND;
 1948               		.loc 1 881 0
 1949 0a74 82E0      		ldi r24,lo8(2)
 1950 0a76 8283      		std Z+2,r24
 1951               	.LVL110:
 1952               	.L103:
 882:motor.c       ****             outputBuffer[3] = computeChecksum(outputBuffer,3); //this is the checksum
 1953               		.loc 1 882 0
 1954 0a78 C701      		movw r24,r14
 1955 0a7a 63E0      		ldi r22,lo8(3)
 1956 0a7c 70E0      		ldi r23,hi8(3)
 1957 0a7e 0E94 0000 		call computeChecksum
 1958 0a82 F701      		movw r30,r14
 1959 0a84 8383      		std Z+3,r24
 883:motor.c       ****             return 4;
 1960               		.loc 1 883 0
 1961 0a86 84E0      		ldi r24,lo8(4)
 1962 0a88 90E0      		ldi r25,hi8(4)
 1963               	.L55:
 1964               	/* epilogue start */
 885:motor.c       **** }
 1965               		.loc 1 885 0
 1966 0a8a DF91      		pop r29
 1967 0a8c CF91      		pop r28
 1968 0a8e 1F91      		pop r17
 1969 0a90 0F91      		pop r16
 1970 0a92 FF90      		pop r15
 1971 0a94 EF90      		pop r14
 1972               	.LVL111:
 1973 0a96 DF90      		pop r13
 1974 0a98 CF90      		pop r12
 1975 0a9a 0895      		ret
 1976               	.LVL112:
 1977               	.L98:
 1978               	.LBB100:
 1979               	.LBB94:
 534:motor.c       ****         updateMotorDirection(newDirection);
 1980               		.loc 1 534 0
 1981 0a9c 80E0      		ldi r24,lo8(0)
 1982               	.LVL113:
 1983 0a9e 0E94 0000 		call updateMotorDirection
 1984               	.LVL114:
 523:motor.c       ****             newScheme = CONTROL_SCHEME_VOLTAGE;
 1985               		.loc 1 523 0
 1986 0aa2 DD24      		clr r13
 522:motor.c       ****             newDirection = DIRECTION_STOP;
 1987               		.loc 1 522 0
 1988 0aa4 CC24      		clr r12
 1989 0aa6 00C0      		rjmp .L66
 1990               	.LBE94:
 1991               	.LBE100:
 1992               		.cfi_endproc
 1993               	.LFE23:
 1995               	.global	LEDon
 1997               	LEDon:
 1998               	.LFB24:
 888:motor.c       **** {
 1999               		.loc 1 888 0
 2000               		.cfi_startproc
 2001               	/* prologue: function */
 2002               	/* frame size = 0 */
 2003               	/* stack size = 0 */
 2004               	.L__stack_usage = 0
 889:motor.c       ****     PORTC.OUTSET = 0x80;
 2005               		.loc 1 889 0
 2006 0aa8 80E8      		ldi r24,lo8(-128)
 2007 0aaa E0E4      		ldi r30,lo8(1600)
 2008 0aac F6E0      		ldi r31,hi8(1600)
 2009 0aae 8583      		std Z+5,r24
 2010               	/* epilogue start */
 890:motor.c       **** }
 2011               		.loc 1 890 0
 2012 0ab0 0895      		ret
 2013               		.cfi_endproc
 2014               	.LFE24:
 2016               	.global	LEDoff
 2018               	LEDoff:
 2019               	.LFB25:
 892:motor.c       **** {
 2020               		.loc 1 892 0
 2021               		.cfi_startproc
 2022               	/* prologue: function */
 2023               	/* frame size = 0 */
 2024               	/* stack size = 0 */
 2025               	.L__stack_usage = 0
 2026               		.loc 1 893 0
 2027 0ab2 80E8      		ldi r24,lo8(-128)
 2028 0ab4 E0E4      		ldi r30,lo8(1600)
 2029 0ab6 F6E0      		ldi r31,hi8(1600)
 2030 0ab8 8683      		std Z+6,r24
 2031               	/* epilogue start */
 894:motor.c       **** }
 2032               		.loc 1 894 0
 2033 0aba 0895      		ret
 2034               		.cfi_endproc
 2035               	.LFE25:
 2037               	.global	LEDtoggle
 2039               	LEDtoggle:
 2040               	.LFB26:
 895:motor.c       **** void LEDtoggle()
 896:motor.c       **** {
 2041               		.loc 1 896 0
 2042               		.cfi_startproc
 2043               	/* prologue: function */
 2044               	/* frame size = 0 */
 2045               	/* stack size = 0 */
 2046               	.L__stack_usage = 0
 897:motor.c       ****     PORTC.OUTTGL = 0x80;
 2047               		.loc 1 897 0
 2048 0abc 80E8      		ldi r24,lo8(-128)
 2049 0abe E0E4      		ldi r30,lo8(1600)
 2050 0ac0 F6E0      		ldi r31,hi8(1600)
 2051 0ac2 8783      		std Z+7,r24
 2052               	/* epilogue start */
 898:motor.c       **** }
 2053               		.loc 1 898 0
 2054 0ac4 0895      		ret
 2055               		.cfi_endproc
 2056               	.LFE26:
 2058               		.section	.text.startup,"ax",@progbits
 2059               	.global	main
 2061               	main:
 2062               	.LFB27:
 899:motor.c       **** 
 900:motor.c       **** /************************************************************************
 901:motor.c       ****  * MAIN function.
 902:motor.c       ****  *
 903:motor.c       ****  * This intitializes the other port modules and polls a few volatile status
 904:motor.c       ****  * bits set in ISRs.
 905:motor.c       ****  ************************************************************************/
 906:motor.c       **** int main(void)
 907:motor.c       **** {
 2063               		.loc 1 907 0
 2064               		.cfi_startproc
 2065 0000 CF93      		push r28
 2066               	.LCFI47:
 2067               		.cfi_def_cfa_offset 3
 2068               		.cfi_offset 28, -2
 2069 0002 DF93      		push r29
 2070               	.LCFI48:
 2071               		.cfi_def_cfa_offset 4
 2072               		.cfi_offset 29, -3
 2073 0004 00D0      		rcall .
 2074 0006 00D0      		rcall .
 2075               	.LCFI49:
 2076               		.cfi_def_cfa_offset 8
 2077 0008 CDB7      		in r28,__SP_L__
 2078 000a DEB7      		in r29,__SP_H__
 2079               	.LCFI50:
 2080               		.cfi_def_cfa_register 28
 2081               	/* prologue: function */
 2082               	/* frame size = 4 */
 2083               	/* stack size = 6 */
 2084               	.L__stack_usage = 6
 908:motor.c       ****     uint8_t controlSignal;
 909:motor.c       ****     cli();                                    //disable all interrupts for clock reset
 2085               		.loc 1 909 0
 2086               	/* #APP */
 2087               	 ;  909 "motor.c" 1
 2088 000c F894      		cli
 2089               	 ;  0 "" 2
 2090               	.LVL115:
 2091               	/* #NOAPP */
 2092               	.LBB101:
 2093               	.LBB102:
 2094               		.loc 2 164 0
 2095 000e 8FE3      		 ldi r24,lo8(7999)
 2096 0010 9FE1      	    ldi r25,hi8(7999)
 2097 0012 0197      	    1:sbiw r24,1
 2098 0014 01F4      	    brne 1b
 2099 0016 00C0      		rjmp .
 2100 0018 0000      		nop
 2101               	.LBE102:
 2102               	.LBE101:
 2103               	.LBB103:
 2104               	.LBB104:
 166:motor.c       ****     OSC.CTRL = OSC_RC32MEN_bm | OSC_RC32KEN_bm;            //enable the 32MHz ring oscillator and t
 2105               		.loc 1 166 0
 2106 001a 86E0      		ldi r24,lo8(6)
 2107 001c 8093 5000 		sts 80,r24
 2108               	.L114:
 167:motor.c       ****     while(!(OSC.STATUS & OSC_RC32MRDY_bm));                //wait for 32MHz to stabilize
 2109               		.loc 1 167 0
 2110 0020 8091 5100 		lds r24,81
 2111 0024 81FF      		sbrs r24,1
 2112 0026 00C0      		rjmp .L114
 2113               	.L123:
 168:motor.c       ****     while(!(OSC.STATUS & OSC_RC32KRDY_bm));                //wait for 32kHz to stabilize
 2114               		.loc 1 168 0
 2115 0028 8091 5100 		lds r24,81
 2116 002c 82FF      		sbrs r24,2
 2117 002e 00C0      		rjmp .L123
 170:motor.c       ****     DFLLRC32M.CTRL = DFLL_ENABLE_bm;
 2118               		.loc 1 170 0
 2119 0030 81E0      		ldi r24,lo8(1)
 2120 0032 8093 6000 		sts 96,r24
 171:motor.c       ****     DFLLRC2M.CTRL = DFLL_ENABLE_bm;
 2121               		.loc 1 171 0
 2122 0036 8093 6800 		sts 104,r24
 173:motor.c       ****     CCP = CCP_IOREG_gc;                                    //clock is protected by Configuration Ch
 2123               		.loc 1 173 0
 2124 003a 98ED      		ldi r25,lo8(-40)
 2125 003c 94BF      		out 52-0,r25
 174:motor.c       ****     CLK.CTRL = CLK_SCLKSEL_RC32M_gc;                    //switch to 32MHz oscillator
 2126               		.loc 1 174 0
 2127 003e 8093 4000 		sts 64,r24
 175:motor.c       ****     CLK.RTCCTRL = CLK_RTCSRC_RCOSC_gc | CLK_RTCEN_bm;    //Select 1.024 kHz from internal oscillato
 2128               		.loc 1 175 0
 2129 0042 85E0      		ldi r24,lo8(5)
 2130 0044 E0E4      		ldi r30,lo8(64)
 2131 0046 F0E0      		ldi r31,hi8(64)
 2132 0048 8383      		std Z+3,r24
 2133               	.LVL116:
 2134               	.LBE104:
 2135               	.LBE103:
 2136               	.LBB105:
 2137               	.LBB106:
 2138               		.loc 2 164 0
 2139 004a EFE3      		 ldi r30,lo8(7999)
 2140 004c FFE1      	    ldi r31,hi8(7999)
 2141 004e 3197      	    1:sbiw r30,1
 2142 0050 01F4      	    brne 1b
 2143 0052 00C0      		rjmp .
 2144 0054 0000      		nop
 2145               	.LBE106:
 2146               	.LBE105:
 910:motor.c       ****     //detectFingerThumb();
 911:motor.c       ****     _delay_ms(1); // for stability of supplies
 912:motor.c       ****     configureClocks();
 913:motor.c       ****     _delay_ms(1); // for stability of clocks
 914:motor.c       ****     configurePortIO();
 2147               		.loc 1 914 0
 2148 0056 0E94 0000 		call configurePortIO
 915:motor.c       ****     initializeParameters();
 2149               		.loc 1 915 0
 2150 005a 0E94 0000 		call initializeParameters
 2151               	.LBB107:
 2152               	.LBB108:
 219:motor.c       ****     uint32_t zero_check = 0;
 2153               		.loc 1 219 0
 2154 005e 1982      		std Y+1,__zero_reg__
 2155 0060 1A82      		std Y+2,__zero_reg__
 2156 0062 1B82      		std Y+3,__zero_reg__
 2157 0064 1C82      		std Y+4,__zero_reg__
 2158               	.LVL117:
 220:motor.c       ****     ReadIntFromEEPROM(EEPROM_ADDRESS_LED, (uint8_t*)&zero_check);
 2159               		.loc 1 220 0
 2160 0066 8FE1      		ldi r24,lo8(31)
 2161 0068 BE01      		movw r22,r28
 2162 006a 6F5F      		subi r22,lo8(-(1))
 2163 006c 7F4F      		sbci r23,hi8(-(1))
 2164 006e 0E94 0000 		call ReadIntFromEEPROM
 222:motor.c       ****     if(zero_check)
 2165               		.loc 1 222 0
 2166 0072 8981      		ldd r24,Y+1
 2167 0074 9A81      		ldd r25,Y+2
 2168 0076 AB81      		ldd r26,Y+3
 2169 0078 BC81      		ldd r27,Y+4
 2170 007a 0097      		sbiw r24,0
 2171 007c A105      		cpc r26,__zero_reg__
 2172 007e B105      		cpc r27,__zero_reg__
 2173 0080 01F0      		breq .L116
 2174               	.LBB109:
 2175               	.LBB110:
 889:motor.c       ****     PORTC.OUTSET = 0x80;
 2176               		.loc 1 889 0
 2177 0082 80E8      		ldi r24,lo8(-128)
 2178 0084 E0E4      		ldi r30,lo8(1600)
 2179 0086 F6E0      		ldi r31,hi8(1600)
 2180 0088 8583      		std Z+5,r24
 2181 008a 00C0      		rjmp .L117
 2182               	.L116:
 2183               	.LBE110:
 2184               	.LBE109:
 2185               	.LBB111:
 2186               	.LBB112:
 893:motor.c       ****     PORTC.OUTCLR = 0x80;
 2187               		.loc 1 893 0
 2188 008c 80E8      		ldi r24,lo8(-128)
 2189 008e E0E4      		ldi r30,lo8(1600)
 2190 0090 F6E0      		ldi r31,hi8(1600)
 2191 0092 8683      		std Z+6,r24
 2192               	.L117:
 2193               	.LBE112:
 2194               	.LBE111:
 2195               	.LBE108:
 2196               	.LBE107:
 2197               	.LBB113:
 2198               	.LBB114:
 258:motor.c       ****     uint32_t readversion = 0;
 2199               		.loc 1 258 0
 2200 0094 1982      		std Y+1,__zero_reg__
 2201 0096 1A82      		std Y+2,__zero_reg__
 2202 0098 1B82      		std Y+3,__zero_reg__
 2203 009a 1C82      		std Y+4,__zero_reg__
 2204               	.LVL118:
 259:motor.c       ****     ReadIntFromEEPROM(EEPROM_ADDRESS_FIRMWARE_VERSION, (uint8_t*)&readversion);
 2205               		.loc 1 259 0
 2206 009c 8DE1      		ldi r24,lo8(29)
 2207 009e BE01      		movw r22,r28
 2208 00a0 6F5F      		subi r22,lo8(-(1))
 2209 00a2 7F4F      		sbci r23,hi8(-(1))
 2210 00a4 0E94 0000 		call ReadIntFromEEPROM
 260:motor.c       ****     if (readversion != FIRMWARE_VERSION)
 2211               		.loc 1 260 0
 2212 00a8 8981      		ldd r24,Y+1
 2213 00aa 9A81      		ldd r25,Y+2
 2214 00ac AB81      		ldd r26,Y+3
 2215 00ae BC81      		ldd r27,Y+4
 2216 00b0 8C32      		cpi r24,lo8(300)
 2217 00b2 F1E0      		ldi r31,hi8(300)
 2218 00b4 9F07      		cpc r25,r31
 2219 00b6 F0E0      		ldi r31,hlo8(300)
 2220 00b8 AF07      		cpc r26,r31
 2221 00ba F0E0      		ldi r31,hhi8(300)
 2222 00bc BF07      		cpc r27,r31
 2223 00be 01F0      		breq .L118
 262:motor.c       ****         readversion = FIRMWARE_VERSION;
 2224               		.loc 1 262 0
 2225 00c0 8CE2      		ldi r24,lo8(300)
 2226 00c2 91E0      		ldi r25,hi8(300)
 2227 00c4 A0E0      		ldi r26,hlo8(300)
 2228 00c6 B0E0      		ldi r27,hhi8(300)
 2229 00c8 8983      		std Y+1,r24
 2230 00ca 9A83      		std Y+2,r25
 2231 00cc AB83      		std Y+3,r26
 2232 00ce BC83      		std Y+4,r27
 263:motor.c       ****         WriteIntToEEPROM(EEPROM_ADDRESS_FIRMWARE_VERSION, (uint8_t*)&readversion);
 2233               		.loc 1 263 0
 2234 00d0 8DE1      		ldi r24,lo8(29)
 2235 00d2 BE01      		movw r22,r28
 2236 00d4 6F5F      		subi r22,lo8(-(1))
 2237 00d6 7F4F      		sbci r23,hi8(-(1))
 2238 00d8 0E94 0000 		call WriteIntToEEPROM
 2239               	.L118:
 2240               	.LBE114:
 2241               	.LBE113:
 916:motor.c       **** 
 917:motor.c       ****     // No need to delay due to bootloader
 918:motor.c       ****     // Need to delay remaining configuration until the board (and reference) have powered up fully
 919:motor.c       ****     //_delay_ms(4500);
 920:motor.c       ****     //LEDon();
 921:motor.c       ****     //_delay_ms(500);
 922:motor.c       ****     initStateFromEEPROM();
 923:motor.c       ****     verifyVersion();
 924:motor.c       **** 
 925:motor.c       ****     configureMotorPWMs();
 2242               		.loc 1 925 0
 2243 00dc 0E94 0000 		call configureMotorPWMs
 926:motor.c       ****     configureMotorCounters();
 2244               		.loc 1 926 0
 2245 00e0 0E94 0000 		call configureMotorCounters
 927:motor.c       ****     configureDaisyUSART();
 2246               		.loc 1 927 0
 2247 00e4 0E94 0000 		call configureDaisyUSART
 928:motor.c       **** 
 929:motor.c       ****     configureADC();
 2248               		.loc 1 929 0
 2249 00e8 0E94 0000 		call configureADC
 930:motor.c       ****     configurePinInterrupts();
 2250               		.loc 1 930 0
 2251 00ec 0E94 0000 		call configurePinInterrupts
 931:motor.c       ****     configurePIDController();
 2252               		.loc 1 931 0
 2253 00f0 0E94 0000 		call configurePIDController
 932:motor.c       **** 
 933:motor.c       ****     PMIC.CTRL |= PMIC_LOLVLEN_bm;            //tell event system to pay attention to low-priority i
 2254               		.loc 1 933 0
 2255 00f4 8091 A200 		lds r24,162
 2256 00f8 8160      		ori r24,lo8(1)
 2257 00fa E0EA      		ldi r30,lo8(160)
 2258 00fc F0E0      		ldi r31,hi8(160)
 2259 00fe 8283      		std Z+2,r24
 934:motor.c       ****     sei();
 2260               		.loc 1 934 0
 2261               	/* #APP */
 2262               	 ;  934 "motor.c" 1
 2263 0100 7894      		sei
 2264               	 ;  0 "" 2
 935:motor.c       **** 
 936:motor.c       ****     updateMotor(); //forceMotorUpdate();
 2265               		.loc 1 936 0
 2266               	/* #NOAPP */
 2267 0102 0E94 0000 		call updateMotor
 937:motor.c       **** 
 938:motor.c       ****     while(1)
 939:motor.c       ****     {
 940:motor.c       ****         if(notifyDaisy)
 941:motor.c       ****         {
 942:motor.c       ****             doDaisyTask();
 943:motor.c       ****         }
 944:motor.c       ****         handleTC();
 945:motor.c       **** 
 946:motor.c       ****         if(PID_runPID == 1)
 947:motor.c       ****         {
 948:motor.c       ****             //Run the PID control loop
 949:motor.c       ****             //Interrupts are disabled while the velocity signals are read
 950:motor.c       ****             //This is to prevent the interrupt handler from changing them underneath while they are
 951:motor.c       ****             //averaged
 952:motor.c       ****             ASSERT_DEBUG_LINE();
 2268               		.loc 1 952 0
 2269 0106 90E2      		ldi r25,lo8(1568)
 2270 0108 E92E      		mov r14,r25
 2271 010a 96E0      		ldi r25,hi8(1568)
 2272 010c F92E      		mov r15,r25
 2273 010e 14E0      		ldi r17,lo8(4)
 2274               	.L127:
 940:motor.c       ****         if(notifyDaisy)
 2275               		.loc 1 940 0
 2276 0110 8091 0000 		lds r24,notifyDaisy
 2277 0114 8823      		tst r24
 2278 0116 01F0      		breq .L119
 942:motor.c       ****             doDaisyTask();
 2279               		.loc 1 942 0
 2280 0118 0E94 0000 		call doDaisyTask
 2281               	.L119:
 944:motor.c       ****         handleTC();
 2282               		.loc 1 944 0
 2283 011c 0E94 0000 		call handleTC
 946:motor.c       ****         if(PID_runPID == 1)
 2284               		.loc 1 946 0
 2285 0120 8091 0000 		lds r24,PID_runPID
 2286 0124 8130      		cpi r24,lo8(1)
 2287 0126 01F4      		brne .L127
 2288               		.loc 1 952 0
 2289 0128 F701      		movw r30,r14
 2290 012a 1583      		std Z+5,r17
 953:motor.c       ****             cli();
 2291               		.loc 1 953 0
 2292               	/* #APP */
 2293               	 ;  953 "motor.c" 1
 2294 012c F894      		cli
 2295               	 ;  0 "" 2
 954:motor.c       ****             PID_runPID = 0;
 2296               		.loc 1 954 0
 2297               	/* #NOAPP */
 2298 012e 1092 0000 		sts PID_runPID,__zero_reg__
 955:motor.c       ****             readVelocitySignal();
 2299               		.loc 1 955 0
 2300 0132 0E94 0000 		call readVelocitySignal
 956:motor.c       ****             sei();
 2301               		.loc 1 956 0
 2302               	/* #APP */
 2303               	 ;  956 "motor.c" 1
 2304 0136 7894      		sei
 2305               	 ;  0 "" 2
 957:motor.c       **** 
 958:motor.c       ****             //Current signals do not need reading in an interrupt-free context because the ADC is f
 959:motor.c       ****             //Store the most recent acquisition on all channels
 960:motor.c       ****             readCurrentSignals();
 2306               		.loc 1 960 0
 2307               	/* #NOAPP */
 2308 0138 0E94 0000 		call readCurrentSignals
 961:motor.c       ****             //LEDtoggle();
 962:motor.c       ****             updateThermalModel(statorTemperature, motorCurrent);
 2309               		.loc 1 962 0
 2310 013c 6091 0000 		lds r22,statorTemperature
 2311 0140 7091 0000 		lds r23,statorTemperature+1
 2312 0144 8091 0000 		lds r24,statorTemperature+2
 2313 0148 9091 0000 		lds r25,statorTemperature+3
 2314 014c 2091 0000 		lds r18,motorCurrent
 2315 0150 3091 0000 		lds r19,motorCurrent+1
 2316 0154 4091 0000 		lds r20,motorCurrent+2
 2317 0158 5091 0000 		lds r21,motorCurrent+3
 2318 015c 0E94 0000 		call updateThermalModel
 963:motor.c       ****             controlSignal = runPIDController();
 2319               		.loc 1 963 0
 2320 0160 0E94 0000 		call runPIDController
 2321               	.LVL119:
 964:motor.c       **** // #ifdef USE_OVERSPEED_BACKOFF
 965:motor.c       **** //             if(isOverspeed())
 966:motor.c       **** //             {
 967:motor.c       **** //                 updateMotorVoltage(controlSignal/4);
 968:motor.c       **** //             } else {
 969:motor.c       **** //                 updateMotorVoltage(controlSignal);
 970:motor.c       **** //             }
 971:motor.c       **** // #else
 972:motor.c       ****             updateMotorVoltage(controlSignal);
 2322               		.loc 1 972 0
 2323 0164 0E94 0000 		call updateMotorVoltage
 2324               	.LVL120:
 973:motor.c       **** // #endif
 974:motor.c       ****             updateMotor(); //forceMotorUpdate();
 2325               		.loc 1 974 0
 2326 0168 0E94 0000 		call updateMotor
 975:motor.c       ****             DEASSERT_DEBUG_LINE();
 2327               		.loc 1 975 0
 2328 016c F701      		movw r30,r14
 2329 016e 1683      		std Z+6,r17
 2330 0170 00C0      		rjmp .L127
 2331               		.cfi_endproc
 2332               	.LFE27:
 2334               		.comm Parameter,100,1
 2335               		.data
 2338               	CSWTCH.28:
 2339 0000 04        		.byte	4
 2340 0001 02        		.byte	2
 2341 0002 00        		.byte	0
 2342 0003 01        		.byte	1
 2343               		.text
 2344               	.Letext0:
 2345               		.file 3 "/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../av
 2346               		.file 4 "hallctrl.h"
 2347               		.file 5 "PIDcontroller.h"
 2348               		.file 6 "/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../av
 2349               		.file 7 "motor.h"
 2350               		.file 8 "velcounter.h"
 2351               		.file 9 "currentADC.h"
 2352               		.file 10 "thermalModel.h"
 2353               		.file 11 "../common/daisycomm.h"
DEFINED SYMBOLS
                            *ABS*:00000000 motor.c
     /tmp/cceqgTfj.s:2      *ABS*:0000003f __SREG__
     /tmp/cceqgTfj.s:3      *ABS*:0000003e __SP_H__
     /tmp/cceqgTfj.s:4      *ABS*:0000003d __SP_L__
     /tmp/cceqgTfj.s:5      *ABS*:00000034 __CCP__
     /tmp/cceqgTfj.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/cceqgTfj.s:7      *ABS*:00000001 __zero_reg__
     /tmp/cceqgTfj.s:14     .text:00000000 ReadIntFromEEPROM
     /tmp/cceqgTfj.s:101    .text:0000004e WriteIntToEEPROM
     /tmp/cceqgTfj.s:187    .text:0000009c __vector_10
     /tmp/cceqgTfj.s:232    .text:000000bc WriteFloatToEEPROM
     /tmp/cceqgTfj.s:325    .text:00000122 initializeEEPROM
                            *COM*:00000064 Parameter
     /tmp/cceqgTfj.s:578    .text:00000364 initializeParameters
     /tmp/cceqgTfj.s:751    .text:00000436 BootRelay
     /tmp/cceqgTfj.s:1062   .text:000005aa processCommand
     /tmp/cceqgTfj.s:2338   .data:00000000 CSWTCH.28
     /tmp/cceqgTfj.s:1997   .text:00000aa8 LEDon
     /tmp/cceqgTfj.s:2018   .text:00000ab2 LEDoff
     /tmp/cceqgTfj.s:2039   .text:00000abc LEDtoggle
     /tmp/cceqgTfj.s:2061   .text.startup:00000000 main

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__eerd_byte_x32a4u
__eewr_byte_x32a4u
PID_runPID
computeChecksum
tension
motorCurrent
__mulsf3
round
__fixunssfsi
statorTemperature
averageRPM
oldDeltaT
__addsf3
encoder
RxCheckSumErrCnt
getMotorDirection
resetPIDController
updateMotorVoltage
thermalCheckSetpoint
PID_state
updateMotorDirection
__floatunsisf
__gtsf2
PIDPreset
positionSetPoint
positionControl
updateMotor
configurePortIO
configureMotorPWMs
configureMotorCounters
configureDaisyUSART
configureADC
configurePinInterrupts
configurePIDController
notifyDaisy
doDaisyTask
handleTC
readVelocitySignal
readCurrentSignals
updateThermalModel
runPIDController
