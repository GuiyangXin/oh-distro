   1               		.file	"adc.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  13               	.global	Thermistor_RtoT
  15               	Thermistor_RtoT:
  16               	.LFB4:
  17               		.file 1 "adc.c"
   1:adc.c         **** /****************************************************
   2:adc.c         **** 
   3:adc.c         ****  // Author:            Zachary Clifford
   4:adc.c         ****  // File Name:        C1482-SRC-PLMMCU-0_adc.c
   5:adc.c         ****  // Creation Date:    24 February, 2012
   6:adc.c         ****  // Revision:        00
   7:adc.c         ****  // Hardware:        ATxmega32A4U
   8:adc.c         ****  // Description:    ADC driver
   9:adc.c         **** 
  10:adc.c         **** ****************************************************/
  11:adc.c         **** 
  12:adc.c         **** /******************************************************************************
  13:adc.c         ****     File Revision History:
  14:adc.c         **** -------------------------------------------------------------------------------
  15:adc.c         **** Revision    Date        Engineer    Description
  16:adc.c         **** --------    --------    --------    -------------------------------------------
  17:adc.c         **** 00            03/06/12    ZAC            Initial Release
  18:adc.c         **** -------------------------------------------------------------------------------
  19:adc.c         **** 
  20:adc.c         **** ******************************************************************************/
  21:adc.c         **** 
  22:adc.c         **** #include <avr/io.h>
  23:adc.c         **** #include <avr/interrupt.h>
  24:adc.c         **** #include <stddef.h>
  25:adc.c         **** #include <avr/pgmspace.h>
  26:adc.c         **** #include <math.h>
  27:adc.c         **** #include <string.h>
  28:adc.c         **** 
  29:adc.c         **** #include "adc.h"
  30:adc.c         **** 
  31:adc.c         **** static uint8_t ReadCalibrationByte(uint8_t index);
  32:adc.c         **** 
  33:adc.c         **** //static int16_t IMON_ADCOffsetCal;
  34:adc.c         **** 
  35:adc.c         **** /************************************************************************
  36:adc.c         **** * ReadCalibrationByte
  37:adc.c         **** *
  38:adc.c         **** * Library code from Atmel for reading the ADC calibration byte from the
  39:adc.c         **** * production signature row.  This is required for the ADC to achieve
  40:adc.c         **** * its full specification.
  41:adc.c         **** ************************************************************************/
  42:adc.c         **** static uint8_t ReadCalibrationByte(uint8_t index)
  43:adc.c         **** {
  44:adc.c         ****     uint8_t result;
  45:adc.c         **** 
  46:adc.c         ****     // Load the NVM Command register to read the calibration row.
  47:adc.c         ****     NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
  48:adc.c         ****     result = pgm_read_byte(index);
  49:adc.c         **** 
  50:adc.c         ****     //Clean up NVM Command register.
  51:adc.c         ****     NVM_CMD = NVM_CMD_NO_OPERATION_gc;
  52:adc.c         **** 
  53:adc.c         ****     return result;
  54:adc.c         **** }
  55:adc.c         **** 
  56:adc.c         **** float Thermistor_RtoT(float MeasR)
  57:adc.c         **** {
  18               		.loc 1 57 0
  19               		.cfi_startproc
  20               	.LVL0:
  21 0000 0F93      		push r16
  22               	.LCFI0:
  23               		.cfi_def_cfa_offset 4
  24               		.cfi_offset 16, -3
  25 0002 1F93      		push r17
  26               	.LCFI1:
  27               		.cfi_def_cfa_offset 5
  28               		.cfi_offset 17, -4
  29               	/* prologue: function */
  30               	/* frame size = 0 */
  31               	/* stack size = 2 */
  32               	.L__stack_usage = 2
  58:adc.c         ****     float T;
  59:adc.c         **** 
  60:adc.c         ****     T = log(MeasR / THERMISTOR_NOMINAL_R);
  33               		.loc 1 60 0
  34 0004 20E0      		ldi r18,lo8(0x461c4000)
  35 0006 30E4      		ldi r19,hi8(0x461c4000)
  36 0008 4CE1      		ldi r20,hlo8(0x461c4000)
  37 000a 56E4      		ldi r21,hhi8(0x461c4000)
  38 000c 0E94 0000 		call __divsf3
  39               	.LVL1:
  40 0010 0E94 0000 		call log
  41               	.LVL2:
  61:adc.c         ****     T *= (1/THERMISTOR_B);
  42               		.loc 1 61 0
  43 0014 26EF      		ldi r18,lo8(0x3983edf6)
  44 0016 3DEE      		ldi r19,hi8(0x3983edf6)
  45 0018 43E8      		ldi r20,hlo8(0x3983edf6)
  46 001a 59E3      		ldi r21,hhi8(0x3983edf6)
  47 001c 0E94 0000 		call __mulsf3
  48               	.LVL3:
  62:adc.c         ****     T += (1/THERMISTOR_NOMINAL_T);
  49               		.loc 1 62 0
  50 0020 462F      		mov r20,r22
  51 0022 572F      		mov r21,r23
  52 0024 682F      		mov r22,r24
  53               	.LVL4:
  54 0026 792F      		mov r23,r25
  55               	.LVL5:
  56 0028 CB01      		movw r24,r22
  57 002a BA01      		movw r22,r20
  58 002c 2FE0      		ldi r18,lo8(0x3b5bcf0f)
  59 002e 3FEC      		ldi r19,hi8(0x3b5bcf0f)
  60 0030 4BE5      		ldi r20,hlo8(0x3b5bcf0f)
  61 0032 5BE3      		ldi r21,hhi8(0x3b5bcf0f)
  62 0034 0E94 0000 		call __addsf3
  63               	.LVL6:
  64 0038 B62F      		mov r27,r22
  65 003a A72F      		mov r26,r23
  66 003c 382F      		mov r19,r24
  67 003e 292F      		mov r18,r25
  68               	.LVL7:
  63:adc.c         ****     T = (1/T);
  69               		.loc 1 63 0
  70 0040 60E0      		ldi r22,lo8(0x3f800000)
  71 0042 70E0      		ldi r23,hi8(0x3f800000)
  72 0044 80E8      		ldi r24,hlo8(0x3f800000)
  73 0046 9FE3      		ldi r25,hhi8(0x3f800000)
  74               	.LVL8:
  75 0048 FD01      		movw r30,r26
  76 004a A901      		movw r20,r18
  77 004c 0F2F      		mov r16,r31
  78 004e 1E2F      		mov r17,r30
  79 0050 252F      		mov r18,r21
  80 0052 342F      		mov r19,r20
  81 0054 A901      		movw r20,r18
  82 0056 9801      		movw r18,r16
  83 0058 0E94 0000 		call __divsf3
  84               	.LVL9:
  64:adc.c         ****     T -= 273.15;         //Convert from K to C
  85               		.loc 1 64 0
  86 005c 462F      		mov r20,r22
  87 005e 572F      		mov r21,r23
  88 0060 682F      		mov r22,r24
  89               	.LVL10:
  90 0062 792F      		mov r23,r25
  91               	.LVL11:
  92 0064 CB01      		movw r24,r22
  93 0066 BA01      		movw r22,r20
  94 0068 23E3      		ldi r18,lo8(0x43889333)
  95 006a 33E9      		ldi r19,hi8(0x43889333)
  96 006c 48E8      		ldi r20,hlo8(0x43889333)
  97 006e 53E4      		ldi r21,hhi8(0x43889333)
  98 0070 0E94 0000 		call __subsf3
  99               	.LVL12:
  65:adc.c         **** 
  66:adc.c         ****     return T;
  67:adc.c         **** 
  68:adc.c         **** }
 100               		.loc 1 68 0
 101 0074 462F      		mov r20,r22
 102 0076 572F      		mov r21,r23
 103 0078 682F      		mov r22,r24
 104 007a 792F      		mov r23,r25
 105 007c CB01      		movw r24,r22
 106 007e BA01      		movw r22,r20
 107               	/* epilogue start */
 108 0080 1F91      		pop r17
 109 0082 0F91      		pop r16
 110 0084 0895      		ret
 111               		.cfi_endproc
 112               	.LFE4:
 114               	.global	Thermistor_VtoR
 116               	Thermistor_VtoR:
 117               	.LFB5:
  69:adc.c         **** 
  70:adc.c         **** float Thermistor_VtoR(float ThermistorVoltage)
  71:adc.c         **** {
 118               		.loc 1 71 0
 119               		.cfi_startproc
 120               	.LVL13:
 121 0086 CF92      		push r12
 122               	.LCFI2:
 123               		.cfi_def_cfa_offset 4
 124               		.cfi_offset 12, -3
 125 0088 DF92      		push r13
 126               	.LCFI3:
 127               		.cfi_def_cfa_offset 5
 128               		.cfi_offset 13, -4
 129 008a EF92      		push r14
 130               	.LCFI4:
 131               		.cfi_def_cfa_offset 6
 132               		.cfi_offset 14, -5
 133 008c FF92      		push r15
 134               	.LCFI5:
 135               		.cfi_def_cfa_offset 7
 136               		.cfi_offset 15, -6
 137 008e 0F93      		push r16
 138               	.LCFI6:
 139               		.cfi_def_cfa_offset 8
 140               		.cfi_offset 16, -7
 141 0090 1F93      		push r17
 142               	.LCFI7:
 143               		.cfi_def_cfa_offset 9
 144               		.cfi_offset 17, -8
 145 0092 CF93      		push r28
 146               	.LCFI8:
 147               		.cfi_def_cfa_offset 10
 148               		.cfi_offset 28, -9
 149 0094 DF93      		push r29
 150               	.LCFI9:
 151               		.cfi_def_cfa_offset 11
 152               		.cfi_offset 29, -10
 153               	/* prologue: function */
 154               	/* frame size = 0 */
 155               	/* stack size = 8 */
 156               	.L__stack_usage = 8
 157 0096 6B01      		movw r12,r22
 158 0098 7C01      		movw r14,r24
  72:adc.c         ****     float ThermistorR;
  73:adc.c         **** 
  74:adc.c         ****     ThermistorR = ThermistorVoltage * THERMISTOR_FIXED_R;
 159               		.loc 1 74 0
 160 009a 20E0      		ldi r18,lo8(0x461c4000)
 161 009c 30E4      		ldi r19,hi8(0x461c4000)
 162 009e 4CE1      		ldi r20,hlo8(0x461c4000)
 163 00a0 56E4      		ldi r21,hhi8(0x461c4000)
 164 00a2 0E94 0000 		call __mulsf3
 165               	.LVL14:
 166 00a6 D62F      		mov r29,r22
 167 00a8 C72F      		mov r28,r23
 168 00aa 182F      		mov r17,r24
 169 00ac 092F      		mov r16,r25
 170               	.LVL15:
  75:adc.c         ****     ThermistorR /= (THERMISTOR_PULLUP_VOLTAGE - ThermistorVoltage);
 171               		.loc 1 75 0
 172 00ae 60E0      		ldi r22,lo8(0x40200000)
 173 00b0 70E0      		ldi r23,hi8(0x40200000)
 174 00b2 80E2      		ldi r24,hlo8(0x40200000)
 175 00b4 90E4      		ldi r25,hhi8(0x40200000)
 176               	.LVL16:
 177 00b6 A701      		movw r20,r14
 178 00b8 9601      		movw r18,r12
 179 00ba 0E94 0000 		call __subsf3
 180               	.LVL17:
 181 00be 9B01      		movw r18,r22
 182 00c0 AC01      		movw r20,r24
 183 00c2 FE01      		movw r30,r28
 184 00c4 B801      		movw r22,r16
 185 00c6 8F2F      		mov r24,r31
 186 00c8 9E2F      		mov r25,r30
 187 00ca A72F      		mov r26,r23
 188 00cc B62F      		mov r27,r22
 189 00ce BC01      		movw r22,r24
 190 00d0 CD01      		movw r24,r26
 191 00d2 0E94 0000 		call __divsf3
  76:adc.c         **** 
  77:adc.c         ****     return ThermistorR;
  78:adc.c         **** 
  79:adc.c         **** }
 192               		.loc 1 79 0
 193 00d6 462F      		mov r20,r22
 194 00d8 572F      		mov r21,r23
 195 00da 682F      		mov r22,r24
 196 00dc 792F      		mov r23,r25
 197 00de CB01      		movw r24,r22
 198 00e0 BA01      		movw r22,r20
 199               	/* epilogue start */
 200 00e2 DF91      		pop r29
 201               	.LVL18:
 202 00e4 CF91      		pop r28
 203 00e6 1F91      		pop r17
 204 00e8 0F91      		pop r16
 205 00ea FF90      		pop r15
 206 00ec EF90      		pop r14
 207 00ee DF90      		pop r13
 208 00f0 CF90      		pop r12
 209               	.LVL19:
 210 00f2 0895      		ret
 211               		.cfi_endproc
 212               	.LFE5:
 214               	.global	captureSweep
 216               	captureSweep:
 217               	.LFB6:
  80:adc.c         **** 
  81:adc.c         **** // /************************************************************************
  82:adc.c         **** // * calibrateIMON_ADCOffset()
  83:adc.c         **** // *
  84:adc.c         **** // * Captures a few samples of the motor current monitor to remove steady
  85:adc.c         **** // * state offsets
  86:adc.c         **** // *
  87:adc.c         **** // * The monitor should sit at midrange positive, or 1024
  88:adc.c         **** // ************************************************************************/
  89:adc.c         **** // void calibrateIMON_ADCOffset(void)
  90:adc.c         **** // {
  91:adc.c         **** //     int i=0;
  92:adc.c         **** //     int32_t calibrationAccumulator=0;
  93:adc.c         **** //     int16_t error;
  94:adc.c         **** //     int16_t reading;
  95:adc.c         **** 
  96:adc.c         **** //     ADCA_CH3_MUXCTRL = ADC_CH_MUXPOS_PIN6_gc;
  97:adc.c         **** 
  98:adc.c         **** //     for(i=0;i<16;i++)
  99:adc.c         **** //     {
 100:adc.c         **** //         ADCA.CTRLA = (ADC_CH3START_bm | ADC_ENABLE_bm);
 101:adc.c         **** 
 102:adc.c         **** //         while(!(ADCA.INTFLAGS & ADC_CH3IF_bm));
 103:adc.c         **** 
 104:adc.c         **** //         ADCA.INTFLAGS = ADC_CH3IF_bm;
 105:adc.c         **** //         reading = ADCA.CH3RES;
 106:adc.c         **** //         error = reading - 1024;
 107:adc.c         **** //         calibrationAccumulator += error;
 108:adc.c         **** //     }
 109:adc.c         **** //     IMON_ADCOffsetCal = round((float) calibrationAccumulator / 16.0);
 110:adc.c         **** //     return;
 111:adc.c         **** // }
 112:adc.c         **** 
 113:adc.c         **** /************************************************************************
 114:adc.c         **** * captureSweep(int16_t *outputData)
 115:adc.c         **** *
 116:adc.c         **** * captures an ADC sweep of all connected sensors and places the output
 117:adc.c         **** * data in outputData.
 118:adc.c         **** ************************************************************************/
 119:adc.c         **** void captureSweep(int16_t *outputData)
 120:adc.c         **** {
 218               		.loc 1 120 0
 219               		.cfi_startproc
 220               	.LVL20:
 221               	/* prologue: function */
 222               	/* frame size = 0 */
 223               	/* stack size = 0 */
 224               	.L__stack_usage = 0
 225 00f4 FC01      		movw r30,r24
 121:adc.c         ****     //Begin sampling on the first wave
 122:adc.c         ****     ADCA_CH0_MUXCTRL = ADC_CH_MUXPOS_PIN1_gc;
 226               		.loc 1 122 0
 227 00f6 88E0      		ldi r24,lo8(8)
 228               	.LVL21:
 229 00f8 8093 2102 		sts 545,r24
 123:adc.c         ****     ADCA_CH1_MUXCTRL = ADC_CH_MUXPOS_PIN3_gc;
 230               		.loc 1 123 0
 231 00fc 88E1      		ldi r24,lo8(24)
 232 00fe 8093 2902 		sts 553,r24
 124:adc.c         ****     ADCA_CH2_MUXCTRL = ADC_CH_MUXPOS_PIN7_gc;
 233               		.loc 1 124 0
 234 0102 88E3      		ldi r24,lo8(56)
 235 0104 8093 3102 		sts 561,r24
 125:adc.c         ****     //ADCA_CH3_MUXCTRL = ADC_CH_MUXPOS_PIN6_gc;
 126:adc.c         ****     ADCA_CH3_MUXCTRL = ADC_CH_MUXPOS_PIN4_gc;
 236               		.loc 1 126 0
 237 0108 80E2      		ldi r24,lo8(32)
 238 010a 8093 3902 		sts 569,r24
 127:adc.c         ****     
 128:adc.c         ****     ADCA.CTRLA = (ADC_CH3START_bm | ADC_CH2START_bm | ADC_CH1START_bm | ADC_CH0START_bm | ADC_ENABL
 239               		.loc 1 128 0
 240 010e 8DE3      		ldi r24,lo8(61)
 241 0110 8093 0002 		sts 512,r24
 242               	.L4:
 129:adc.c         **** 
 130:adc.c         ****     //Now wait for the conclusion of the sampling
 131:adc.c         ****     while(!(ADCA.INTFLAGS & ADC_CH3IF_bm));
 243               		.loc 1 131 0 discriminator 1
 244 0114 8091 0602 		lds r24,518
 245 0118 83FF      		sbrs r24,3
 246 011a 00C0      		rjmp .L4
 247               	.L10:
 132:adc.c         ****     while(!(ADCA.INTFLAGS & ADC_CH2IF_bm));
 248               		.loc 1 132 0 discriminator 1
 249 011c 8091 0602 		lds r24,518
 250 0120 82FF      		sbrs r24,2
 251 0122 00C0      		rjmp .L10
 252               	.L9:
 133:adc.c         ****     while(!(ADCA.INTFLAGS & ADC_CH1IF_bm));
 253               		.loc 1 133 0 discriminator 1
 254 0124 8091 0602 		lds r24,518
 255 0128 81FF      		sbrs r24,1
 256 012a 00C0      		rjmp .L9
 257               	.L8:
 134:adc.c         ****     while(!(ADCA.INTFLAGS & ADC_CH0IF_bm));
 258               		.loc 1 134 0 discriminator 1
 259 012c 8091 0602 		lds r24,518
 260 0130 80FF      		sbrs r24,0
 261 0132 00C0      		rjmp .L8
 135:adc.c         **** 
 136:adc.c         ****     //Sampling complete
 137:adc.c         ****     outputData[0] = ADCA.CH0RES;
 262               		.loc 1 137 0
 263 0134 8091 1002 		lds r24,528
 264 0138 9091 1102 		lds r25,528+1
 265 013c 8083      		st Z,r24
 266 013e 9183      		std Z+1,r25
 138:adc.c         ****     outputData[1] = ADCA.CH1RES;
 267               		.loc 1 138 0
 268 0140 8091 1202 		lds r24,530
 269 0144 9091 1302 		lds r25,530+1
 270 0148 8283      		std Z+2,r24
 271 014a 9383      		std Z+3,r25
 139:adc.c         ****     outputData[2] = ADCA.CH2RES;
 272               		.loc 1 139 0
 273 014c 8091 1402 		lds r24,532
 274 0150 9091 1502 		lds r25,532+1
 275 0154 8483      		std Z+4,r24
 276 0156 9583      		std Z+5,r25
 140:adc.c         ****     outputData[3] = 0;
 277               		.loc 1 140 0
 278 0158 1682      		std Z+6,__zero_reg__
 279 015a 1782      		std Z+7,__zero_reg__
 141:adc.c         ****     outputData[4] = ADCA.CH3RES;
 280               		.loc 1 141 0
 281 015c 8091 1602 		lds r24,534
 282 0160 9091 1702 		lds r25,534+1
 283 0164 8087      		std Z+8,r24
 284 0166 9187      		std Z+9,r25
 142:adc.c         ****     outputData[5] = 0;
 285               		.loc 1 142 0
 286 0168 1286      		std Z+10,__zero_reg__
 287 016a 1386      		std Z+11,__zero_reg__
 143:adc.c         **** 
 144:adc.c         ****     //This channel should be calibrated
 145:adc.c         ****     //outputData[3] = ADCA.CH3RES - IMON_ADCOffsetCal;
 146:adc.c         **** 
 147:adc.c         ****     ADCA.INTFLAGS = ADC_CH3IF_bm | ADC_CH2IF_bm | ADC_CH1IF_bm | ADC_CH0IF_bm;
 288               		.loc 1 147 0
 289 016c 8FE0      		ldi r24,lo8(15)
 290 016e E0E0      		ldi r30,lo8(512)
 291 0170 F2E0      		ldi r31,hi8(512)
 292               	.LVL22:
 293 0172 8683      		std Z+6,r24
 294               	/* epilogue start */
 148:adc.c         **** 
 149:adc.c         ****     // //Begin sampling on the remaining
 150:adc.c         ****     // //ADCA_CH0_MUXCTRL = ADC_CH_MUXPOS_PIN4_gc;
 151:adc.c         ****     // //ADCA_CH1_MUXCTRL = ADC_CH_MUXPOS_PIN2_gc;
 152:adc.c         **** 
 153:adc.c         ****     // ADCA.CTRLA = (ADC_CH1START_bm | ADC_CH0START_bm | ADC_ENABLE_bm);
 154:adc.c         **** 
 155:adc.c         ****     // //Now wait for the conclusion of the sampling
 156:adc.c         ****     // while(!(ADCA.INTFLAGS & ADC_CH1IF_bm));
 157:adc.c         ****     // while(!(ADCA.INTFLAGS & ADC_CH0IF_bm));
 158:adc.c         **** 
 159:adc.c         ****     // //Sampling complete
 160:adc.c         ****     // outputData[4] = ADCA.CH0RES;
 161:adc.c         ****     // outputData[5] = ADCA.CH1RES;
 162:adc.c         **** 
 163:adc.c         ****     // ADCA.INTFLAGS = ADC_CH1IF_bm | ADC_CH0IF_bm;
 164:adc.c         **** 
 165:adc.c         ****     return;
 166:adc.c         **** }
 295               		.loc 1 166 0
 296 0174 0895      		ret
 297               		.cfi_endproc
 298               	.LFE6:
 300               	.global	configureADC
 302               	configureADC:
 303               	.LFB7:
 167:adc.c         **** 
 168:adc.c         **** /************************************************************************
 169:adc.c         **** * configureADC
 170:adc.c         **** *
 171:adc.c         **** * Configure the ADC to capture the analog inputs using the captureSweep routine
 172:adc.c         **** ************************************************************************/
 173:adc.c         **** void configureADC(void)
 174:adc.c         **** {
 304               		.loc 1 174 0
 305               		.cfi_startproc
 306 0176 CF93      		push r28
 307               	.LCFI10:
 308               		.cfi_def_cfa_offset 4
 309               		.cfi_offset 28, -3
 310 0178 DF93      		push r29
 311               	.LCFI11:
 312               		.cfi_def_cfa_offset 5
 313               		.cfi_offset 29, -4
 314               	/* prologue: function */
 315               	/* frame size = 0 */
 316               	/* stack size = 2 */
 317               	.L__stack_usage = 2
 318               	.LVL23:
 319               	.LBB8:
 320               	.LBB9:
  47:adc.c         ****     NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
 321               		.loc 1 47 0
 322 017a AAEC      		ldi r26,lo8(458)
 323 017c B1E0      		ldi r27,hi8(458)
 324 017e 82E0      		ldi r24,lo8(2)
 325 0180 8C93      		st X,r24
 326               	.LVL24:
 327               	.LBB10:
  48:adc.c         ****     result = pgm_read_byte(index);
 328               		.loc 1 48 0
 329 0182 E0E2      		ldi r30,lo8(32)
 330 0184 F0E0      		ldi r31,hi8(32)
 331               	/* #APP */
 332               	 ;  48 "adc.c" 1
 333 0186 E491      		lpm r30, Z
 334               		
 335               	 ;  0 "" 2
 336               	.LVL25:
 337               	/* #NOAPP */
 338               	.LBE10:
  51:adc.c         ****     NVM_CMD = NVM_CMD_NO_OPERATION_gc;
 339               		.loc 1 51 0
 340 0188 1C92      		st X,__zero_reg__
 341               	.LBE9:
 342               	.LBE8:
 175:adc.c         ****     ADCA.CALL = ReadCalibrationByte( offsetof(NVM_PROD_SIGNATURES_t, ADCACAL0) );
 343               		.loc 1 175 0
 344 018a C0E0      		ldi r28,lo8(512)
 345 018c D2E0      		ldi r29,hi8(512)
 346 018e EC87      		std Y+12,r30
 347               	.LVL26:
 348               	.LBB11:
 349               	.LBB12:
  47:adc.c         ****     NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
 350               		.loc 1 47 0
 351 0190 8C93      		st X,r24
 352               	.LVL27:
 353               	.LBB13:
  48:adc.c         ****     result = pgm_read_byte(index);
 354               		.loc 1 48 0
 355 0192 E1E2      		ldi r30,lo8(33)
 356 0194 F0E0      		ldi r31,hi8(33)
 357               	.LVL28:
 358               	/* #APP */
 359               	 ;  48 "adc.c" 1
 360 0196 E491      		lpm r30, Z
 361               		
 362               	 ;  0 "" 2
 363               	.LVL29:
 364               	/* #NOAPP */
 365               	.LBE13:
  51:adc.c         ****     NVM_CMD = NVM_CMD_NO_OPERATION_gc;
 366               		.loc 1 51 0
 367 0198 1C92      		st X,__zero_reg__
 368               	.LBE12:
 369               	.LBE11:
 176:adc.c         ****     ADCA.CALH = ReadCalibrationByte( offsetof(NVM_PROD_SIGNATURES_t, ADCACAL1) );
 370               		.loc 1 176 0
 371 019a ED87      		std Y+13,r30
 177:adc.c         **** 
 178:adc.c         **** 
 179:adc.c         ****     //Maximum ADC clock is 2 MHz.  This requires a prescaler of 16 on a CPU clock of 32 MHz
 180:adc.c         ****     ADCA.PRESCALER = ADC_PRESCALER_DIV16_gc;
 372               		.loc 1 180 0
 373 019c 8C83      		std Y+4,r24
 181:adc.c         **** 
 182:adc.c         ****     ADCA.REFCTRL = ADC_REFSEL_AREFA_gc;
 374               		.loc 1 182 0
 375 019e 80E2      		ldi r24,lo8(32)
 376 01a0 8A83      		std Y+2,r24
 183:adc.c         **** 
 184:adc.c         **** #warning The ADC.CH structure is wrong in AU parts.  Just use the ADC_CH0_MUXCTRL, etc. defines ins
 185:adc.c         **** 
 186:adc.c         ****     //CH0 is 3.3VMON and EXTTMP_MON
 187:adc.c         ****     ADCA_CH0_CTRL = ADC_CH_GAIN_1X_gc | ADC_CH_INPUTMODE_SINGLEENDED_gc;
 377               		.loc 1 187 0
 378 01a2 81E0      		ldi r24,lo8(1)
 379 01a4 8093 2002 		sts 544,r24
 188:adc.c         ****     ADCA_CH0_MUXCTRL = ADC_CH_MUXPOS_PIN1_gc;
 380               		.loc 1 188 0
 381 01a8 98E0      		ldi r25,lo8(8)
 382 01aa 9093 2102 		sts 545,r25
 189:adc.c         ****     ADCA_CH0_INTCTRL = ADC_CH_INTMODE_COMPLETE_gc | ADC_CH_INTLVL_OFF_gc;
 383               		.loc 1 189 0
 384 01ae 1092 2202 		sts 546,__zero_reg__
 190:adc.c         **** 
 191:adc.c         ****     //CH1 is 12VMON and TempB5
 192:adc.c         ****     ADCA_CH1_CTRL = ADC_CH_GAIN_1X_gc | ADC_CH_INPUTMODE_SINGLEENDED_gc;
 385               		.loc 1 192 0
 386 01b2 8093 2802 		sts 552,r24
 193:adc.c         ****     ADCA_CH1_MUXCTRL = ADC_CH_MUXPOS_PIN3_gc;
 387               		.loc 1 193 0
 388 01b6 98E1      		ldi r25,lo8(24)
 389 01b8 9093 2902 		sts 553,r25
 194:adc.c         ****     ADCA_CH1_INTCTRL = ADC_CH_INTMODE_COMPLETE_gc | ADC_CH_INTLVL_OFF_gc;
 390               		.loc 1 194 0
 391 01bc 1092 2A02 		sts 554,__zero_reg__
 195:adc.c         **** 
 196:adc.c         ****     //CH2 is 48VMON
 197:adc.c         ****     ADCA_CH2_CTRL = ADC_CH_GAIN_1X_gc | ADC_CH_INPUTMODE_SINGLEENDED_gc;
 392               		.loc 1 197 0
 393 01c0 8093 3002 		sts 560,r24
 198:adc.c         ****     ADCA_CH2_MUXCTRL = ADC_CH_MUXPOS_PIN7_gc;
 394               		.loc 1 198 0
 395 01c4 98E3      		ldi r25,lo8(56)
 396 01c6 9093 3102 		sts 561,r25
 199:adc.c         ****     ADCA_CH2_INTCTRL = ADC_CH_INTMODE_COMPLETE_gc | ADC_CH_INTLVL_OFF_gc;
 397               		.loc 1 199 0
 398 01ca 1092 3202 		sts 562,__zero_reg__
 200:adc.c         **** 
 201:adc.c         ****     //CH3 is IMONB5
 202:adc.c         ****     ADCA_CH3_CTRL = ADC_CH_GAIN_1X_gc | ADC_CH_INPUTMODE_SINGLEENDED_gc;
 399               		.loc 1 202 0
 400 01ce 8093 3802 		sts 568,r24
 203:adc.c         ****     ADCA_CH3_MUXCTRL = ADC_CH_MUXPOS_PIN6_gc;
 401               		.loc 1 203 0
 402 01d2 90E3      		ldi r25,lo8(48)
 403 01d4 9093 3902 		sts 569,r25
 204:adc.c         ****     ADCA_CH3_INTCTRL = ADC_CH_INTMODE_COMPLETE_gc | ADC_CH_INTLVL_OFF_gc;
 404               		.loc 1 204 0
 405 01d8 1092 3A02 		sts 570,__zero_reg__
 205:adc.c         **** 
 206:adc.c         ****     //Configure for Unsigned operation
 207:adc.c         ****     ADCA.CTRLB = ADC_RESOLUTION_12BIT_gc | ADC_CONMODE_bm;
 406               		.loc 1 207 0
 407 01dc 90E1      		ldi r25,lo8(16)
 408 01de 9983      		std Y+1,r25
 208:adc.c         ****     ADCA.CTRLA = ADC_ENABLE_bm;
 409               		.loc 1 208 0
 410 01e0 8883      		st Y,r24
 411               	/* epilogue start */
 209:adc.c         **** 
 210:adc.c         **** }
 412               		.loc 1 210 0
 413 01e2 DF91      		pop r29
 414 01e4 CF91      		pop r28
 415               	.LVL30:
 416 01e6 0895      		ret
 417               		.cfi_endproc
 418               	.LFE7:
 420               	.Letext0:
 421               		.file 2 "/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../av
 422               		.file 3 "/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../av
DEFINED SYMBOLS
                            *ABS*:00000000 adc.c
     /tmp/cc15Doxe.s:2      *ABS*:0000003f __SREG__
     /tmp/cc15Doxe.s:3      *ABS*:0000003e __SP_H__
     /tmp/cc15Doxe.s:4      *ABS*:0000003d __SP_L__
     /tmp/cc15Doxe.s:5      *ABS*:00000034 __CCP__
     /tmp/cc15Doxe.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/cc15Doxe.s:7      *ABS*:00000001 __zero_reg__
     /tmp/cc15Doxe.s:15     .text:00000000 Thermistor_RtoT
     /tmp/cc15Doxe.s:116    .text:00000086 Thermistor_VtoR
     /tmp/cc15Doxe.s:216    .text:000000f4 captureSweep
     /tmp/cc15Doxe.s:302    .text:00000176 configureADC

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__divsf3
log
__mulsf3
__addsf3
__subsf3
