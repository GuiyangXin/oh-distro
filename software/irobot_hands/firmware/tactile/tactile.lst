   1               		.file	"tactile.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  14               	ReadIntFromEEPROM:
  15               	.LFB9:
  16               		.file 1 "tactile.c"
   1:tactile.c     **** /****************************************************
   2:tactile.c     **** 
   3:tactile.c     ****  // Author:            Zachary Clifford
   4:tactile.c     ****  // File Name:        C1482-SRC-TACMCU-0.c
   5:tactile.c     ****  // Creation Date:    24 February, 2012
   6:tactile.c     ****  // Revision:        00
   7:tactile.c     ****  // Hardware:        ATxmega32A4U
   8:tactile.c     ****  // Description:    Palm Board Top Level Implementation
   9:tactile.c     **** 
  10:tactile.c     **** ****************************************************/
  11:tactile.c     **** 
  12:tactile.c     **** /******************************************************************************
  13:tactile.c     ****     Project Build Summary:
  14:tactile.c     **** -------------------------------------------------------------------------------
  15:tactile.c     **** Source File                                Cur. Rev. Level        Prev. Rev. Level
  16:tactile.c     **** --------------------------------        ----------------    ----------------
  17:tactile.c     **** C1482-SRC-TACMCU-0.c                    00                    00
  18:tactile.c     **** 
  19:tactile.c     **** 
  20:tactile.c     **** -------------------------------------------------------------------------------
  21:tactile.c     **** 
  22:tactile.c     ****     Project Revision History:
  23:tactile.c     **** -------------------------------------------------------------------------------
  24:tactile.c     **** Revision    Date        Engineer    Description
  25:tactile.c     **** --------    --------    --------    -------------------------------------------
  26:tactile.c     **** 00            MM/DD/YY    ZAC            Initial Release
  27:tactile.c     **** -------------------------------------------------------------------------------
  28:tactile.c     **** 
  29:tactile.c     ****     File Revision History:
  30:tactile.c     **** -------------------------------------------------------------------------------
  31:tactile.c     **** Revision    Date        Engineer    Description
  32:tactile.c     **** --------    --------    --------    -------------------------------------------
  33:tactile.c     **** 00            MM/DD/YY    ZAC            Initial Release
  34:tactile.c     **** -------------------------------------------------------------------------------
  35:tactile.c     **** 
  36:tactile.c     **** ******************************************************************************/
  37:tactile.c     **** 
  38:tactile.c     **** #include "tactile.h"
  39:tactile.c     **** #include "portio.h"
  40:tactile.c     **** #include "../common/daisycomm.h"
  41:tactile.c     **** #include "tactsense.h"
  42:tactile.c     **** #include "adc.h"
  43:tactile.c     **** 
  44:tactile.c     **** #include <avr/io.h>
  45:tactile.c     **** #include <avr/interrupt.h>
  46:tactile.c     **** #include <math.h>
  47:tactile.c     **** #include <string.h>
  48:tactile.c     **** #include <avr/wdt.h>
  49:tactile.c     **** #include <avr/eeprom.h>
  50:tactile.c     **** 
  51:tactile.c     **** #define FIRMWARE_VERSION 301
  52:tactile.c     **** 
  53:tactile.c     **** uint16_t testADC[4];
  54:tactile.c     **** static void configureClocks(void);
  55:tactile.c     **** static void WriteIntToEEPROM(uint8_t address, uint8_t* value);
  56:tactile.c     **** static void ReadIntFromEEPROM(uint8_t address, uint8_t* destination);
  57:tactile.c     **** static void verifyVersion(void);
  58:tactile.c     **** static void initStateFromEEPROM(void);
  59:tactile.c     **** 
  60:tactile.c     **** /************************************************************************
  61:tactile.c     **** * configureClocks()
  62:tactile.c     **** *
  63:tactile.c     **** * Configure system clocks
  64:tactile.c     **** * The RTC is being used to generate PID ticks, so ensure that the 32 kHz oscillator
  65:tactile.c     **** * is running.  This will feed a 1.024 kHz clock to the RTC.
  66:tactile.c     **** * The system clock will use the onboard 32MHz oscillator
  67:tactile.c     **** ************************************************************************/
  68:tactile.c     **** static void configureClocks(void)
  69:tactile.c     **** {
  70:tactile.c     ****     OSC.CTRL = OSC_RC32MEN_bm | OSC_RC32KEN_bm;            //enable the 32MHz ring oscillator and t
  71:tactile.c     ****     while(!(OSC.STATUS & OSC_RC32MRDY_bm));                //wait for 32MHz to stabilize
  72:tactile.c     ****     while(!(OSC.STATUS & OSC_RC32KRDY_bm));                //wait for 32kHz to stabilize
  73:tactile.c     **** 
  74:tactile.c     ****     DFLLRC32M.CTRL = DFLL_ENABLE_bm;
  75:tactile.c     ****     DFLLRC2M.CTRL = DFLL_ENABLE_bm;
  76:tactile.c     **** 
  77:tactile.c     ****     CCP = CCP_IOREG_gc;                                    //clock is protected by Configuration Ch
  78:tactile.c     ****     CLK.CTRL = CLK_SCLKSEL_RC32M_gc;                    //switch to 32MHz oscillator
  79:tactile.c     ****     CLK.RTCCTRL = CLK_RTCSRC_RCOSC_gc | CLK_RTCEN_bm;    //Select 1.024 kHz from internal oscillato
  80:tactile.c     **** }
  81:tactile.c     **** 
  82:tactile.c     **** 
  83:tactile.c     **** static void initStateFromEEPROM(void)
  84:tactile.c     **** {
  85:tactile.c     ****     uint32_t zero_check = 0;
  86:tactile.c     ****     ReadIntFromEEPROM(EEPROM_ADDRESS_LED, (uint8_t*)&zero_check);
  87:tactile.c     ****     
  88:tactile.c     ****     if(zero_check)
  89:tactile.c     ****         LEDon();
  90:tactile.c     ****     else
  91:tactile.c     ****         LEDoff();
  92:tactile.c     **** }
  93:tactile.c     **** 
  94:tactile.c     **** static void WriteIntToEEPROM(uint8_t address, uint8_t* value)
  95:tactile.c     **** {
  96:tactile.c     ****     for(uint8_t i=0; i<4; i++)
  97:tactile.c     ****         eeprom_write_byte((uint8_t *) (address*4+i), *(value+i));
  98:tactile.c     **** }
  99:tactile.c     **** 
 100:tactile.c     **** static void ReadIntFromEEPROM(uint8_t address, uint8_t* destination)
 101:tactile.c     **** {
  17               		.loc 1 101 0
  18               		.cfi_startproc
  19               	.LVL0:
  20 0000 EF92      		push r14
  21               	.LCFI0:
  22               		.cfi_def_cfa_offset 3
  23               		.cfi_offset 14, -2
  24 0002 FF92      		push r15
  25               	.LCFI1:
  26               		.cfi_def_cfa_offset 4
  27               		.cfi_offset 15, -3
  28 0004 0F93      		push r16
  29               	.LCFI2:
  30               		.cfi_def_cfa_offset 5
  31               		.cfi_offset 16, -4
  32 0006 1F93      		push r17
  33               	.LCFI3:
  34               		.cfi_def_cfa_offset 6
  35               		.cfi_offset 17, -5
  36 0008 CF93      		push r28
  37               	.LCFI4:
  38               		.cfi_def_cfa_offset 7
  39               		.cfi_offset 28, -6
  40 000a DF93      		push r29
  41               	.LCFI5:
  42               		.cfi_def_cfa_offset 8
  43               		.cfi_offset 29, -7
  44 000c 0F92      		push __tmp_reg__
  45               	.LCFI6:
  46               		.cfi_def_cfa_offset 9
  47 000e CDB7      		in r28,__SP_L__
  48 0010 DEB7      		in r29,__SP_H__
  49               	.LCFI7:
  50               		.cfi_def_cfa_register 28
  51               	/* prologue: function */
  52               	/* frame size = 1 */
  53               	/* stack size = 7 */
  54               	.L__stack_usage = 7
  55               	.LVL1:
  56               	.LBB15:
 102:tactile.c     ****     for(uint8_t i=0; i<4; i++)
 103:tactile.c     ****         *(destination+i) = eeprom_read_byte((uint8_t *) (address*4+i));
  57               		.loc 1 103 0
  58 0012 E82E      		mov r14,r24
  59 0014 FF24      		clr r15
  60 0016 EE0C      		lsl r14
  61 0018 FF1C      		rol r15
  62 001a EE0C      		lsl r14
  63 001c FF1C      		rol r15
  64               	.LVL2:
  65 001e 8B01      		movw r16,r22
 102:tactile.c     ****     for(uint8_t i=0; i<4; i++)
  66               		.loc 1 102 0
  67 0020 20E0      		ldi r18,lo8(0)
  68               	.LVL3:
  69               	.L2:
  70               		.loc 1 103 0 discriminator 2
  71 0022 C701      		movw r24,r14
  72 0024 2983      		std Y+1,r18
  73 0026 0E94 0000 		call __eerd_byte_x32a4
  74 002a F801      		movw r30,r16
  75 002c 8193      		st Z+,r24
  76 002e 8F01      		movw r16,r30
 102:tactile.c     ****     for(uint8_t i=0; i<4; i++)
  77               		.loc 1 102 0 discriminator 2
  78 0030 2981      		ldd r18,Y+1
  79 0032 2F5F      		subi r18,lo8(-(1))
  80               	.LVL4:
  81 0034 0894      		sec
  82 0036 E11C      		adc r14,__zero_reg__
  83 0038 F11C      		adc r15,__zero_reg__
  84 003a 2430      		cpi r18,lo8(4)
  85 003c 01F4      		brne .L2
  86               	/* epilogue start */
  87               	.LBE15:
 104:tactile.c     **** }
  88               		.loc 1 104 0
  89 003e 0F90      		pop __tmp_reg__
  90 0040 DF91      		pop r29
  91 0042 CF91      		pop r28
  92 0044 1F91      		pop r17
  93 0046 0F91      		pop r16
  94 0048 FF90      		pop r15
  95 004a EF90      		pop r14
  96 004c 0895      		ret
  97               		.cfi_endproc
  98               	.LFE9:
 101               	WriteIntToEEPROM:
 102               	.LFB8:
  95:tactile.c     **** {
 103               		.loc 1 95 0
 104               		.cfi_startproc
 105               	.LVL5:
 106 004e EF92      		push r14
 107               	.LCFI8:
 108               		.cfi_def_cfa_offset 3
 109               		.cfi_offset 14, -2
 110 0050 FF92      		push r15
 111               	.LCFI9:
 112               		.cfi_def_cfa_offset 4
 113               		.cfi_offset 15, -3
 114 0052 0F93      		push r16
 115               	.LCFI10:
 116               		.cfi_def_cfa_offset 5
 117               		.cfi_offset 16, -4
 118 0054 1F93      		push r17
 119               	.LCFI11:
 120               		.cfi_def_cfa_offset 6
 121               		.cfi_offset 17, -5
 122 0056 CF93      		push r28
 123               	.LCFI12:
 124               		.cfi_def_cfa_offset 7
 125               		.cfi_offset 28, -6
 126 0058 DF93      		push r29
 127               	.LCFI13:
 128               		.cfi_def_cfa_offset 8
 129               		.cfi_offset 29, -7
 130 005a 0F92      		push __tmp_reg__
 131               	.LCFI14:
 132               		.cfi_def_cfa_offset 9
 133 005c CDB7      		in r28,__SP_L__
 134 005e DEB7      		in r29,__SP_H__
 135               	.LCFI15:
 136               		.cfi_def_cfa_register 28
 137               	/* prologue: function */
 138               	/* frame size = 1 */
 139               	/* stack size = 7 */
 140               	.L__stack_usage = 7
 141               	.LVL6:
 142               	.LBB16:
  97:tactile.c     ****         eeprom_write_byte((uint8_t *) (address*4+i), *(value+i));
 143               		.loc 1 97 0
 144 0060 8B01      		movw r16,r22
 145 0062 E82E      		mov r14,r24
 146 0064 FF24      		clr r15
 147 0066 EE0C      		lsl r14
 148 0068 FF1C      		rol r15
 149 006a EE0C      		lsl r14
 150 006c FF1C      		rol r15
  96:tactile.c     ****     for(uint8_t i=0; i<4; i++)
 151               		.loc 1 96 0
 152 006e 20E0      		ldi r18,lo8(0)
 153               	.LVL7:
 154               	.L5:
  97:tactile.c     ****         eeprom_write_byte((uint8_t *) (address*4+i), *(value+i));
 155               		.loc 1 97 0 discriminator 2
 156 0070 F801      		movw r30,r16
 157 0072 6191      		ld r22,Z+
 158 0074 8F01      		movw r16,r30
 159 0076 C701      		movw r24,r14
 160 0078 2983      		std Y+1,r18
 161 007a 0E94 0000 		call __eewr_byte_x32a4
  96:tactile.c     ****     for(uint8_t i=0; i<4; i++)
 162               		.loc 1 96 0 discriminator 2
 163 007e 2981      		ldd r18,Y+1
 164 0080 2F5F      		subi r18,lo8(-(1))
 165               	.LVL8:
 166 0082 0894      		sec
 167 0084 E11C      		adc r14,__zero_reg__
 168 0086 F11C      		adc r15,__zero_reg__
 169 0088 2430      		cpi r18,lo8(4)
 170 008a 01F4      		brne .L5
 171               	/* epilogue start */
 172               	.LBE16:
  98:tactile.c     **** }
 173               		.loc 1 98 0
 174 008c 0F90      		pop __tmp_reg__
 175 008e DF91      		pop r29
 176 0090 CF91      		pop r28
 177 0092 1F91      		pop r17
 178 0094 0F91      		pop r16
 179 0096 FF90      		pop r15
 180 0098 EF90      		pop r14
 181 009a 0895      		ret
 182               		.cfi_endproc
 183               	.LFE8:
 185               	.global	LEDon
 187               	LEDon:
 188               	.LFB15:
 105:tactile.c     **** 
 106:tactile.c     **** static void verifyVersion()
 107:tactile.c     **** {
 108:tactile.c     ****     uint32_t readversion = 0;
 109:tactile.c     ****     ReadIntFromEEPROM(EEPROM_ADDRESS_FIRMWARE_VERSION, (uint8_t*)&readversion);
 110:tactile.c     ****     if (readversion != FIRMWARE_VERSION)
 111:tactile.c     ****     {
 112:tactile.c     ****         readversion = FIRMWARE_VERSION;
 113:tactile.c     ****         WriteIntToEEPROM(EEPROM_ADDRESS_FIRMWARE_VERSION, (uint8_t*)&readversion);
 114:tactile.c     ****     }
 115:tactile.c     **** }
 116:tactile.c     **** 
 117:tactile.c     **** static int handleEEPROMCommand(uint8_t *commandPacket, uint8_t *outputBuffer)
 118:tactile.c     **** {
 119:tactile.c     ****     uint8_t opcode;
 120:tactile.c     ****     uint8_t address;
 121:tactile.c     ****     uint8_t responseSize = 4;
 122:tactile.c     **** 
 123:tactile.c     ****     opcode = commandPacket[COMMAND_OFFSET] & OPCODE_BITMASK;
 124:tactile.c     ****     address = commandPacket[COMMAND_OFFSET] & 0x1F;
 125:tactile.c     **** 
 126:tactile.c     ****     switch(opcode)
 127:tactile.c     ****     {
 128:tactile.c     ****         case MOTOR_PARAMETER_RE_L_OPCODE:
 129:tactile.c     ****         case MOTOR_PARAMETER_RE_H_OPCODE:
 130:tactile.c     ****             // Read 4 bytes of data
 131:tactile.c     ****             ReadIntFromEEPROM(address, &outputBuffer[RESPONSE_PAYLOAD_OFFSET]);
 132:tactile.c     ****             // finish up the packet
 133:tactile.c     ****             outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3+responseSize;
 134:tactile.c     ****             outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = commandPacket[COMMAND_OFFSET];
 135:tactile.c     ****             outputBuffer[RESPONSE_STATUSCODE_OFFSET] = STATUS_OK;
 136:tactile.c     ****             outputBuffer[3+responseSize] = computeChecksum(outputBuffer,3+responseSize); //this is 
 137:tactile.c     ****             return 4+responseSize;
 138:tactile.c     ****         case MOTOR_PARAMETER_WR_L_OPCODE:
 139:tactile.c     ****         case MOTOR_PARAMETER_WR_H_OPCODE:
 140:tactile.c     ****             if(address==EEPROM_ADDRESS_LED) {
 141:tactile.c     ****                 if(commandPacket[PAYLOAD_OFFSET+0]
 142:tactile.c     ****                    |commandPacket[PAYLOAD_OFFSET+1]
 143:tactile.c     ****                    |commandPacket[PAYLOAD_OFFSET+2]
 144:tactile.c     ****                    |commandPacket[PAYLOAD_OFFSET+3]) {
 145:tactile.c     ****                     LEDon();
 146:tactile.c     ****                 }
 147:tactile.c     ****                 else {
 148:tactile.c     ****                     LEDoff();
 149:tactile.c     ****                 }
 150:tactile.c     ****             }
 151:tactile.c     ****             // Write 32 bits of data
 152:tactile.c     ****             WriteIntToEEPROM(address, &commandPacket[PAYLOAD_OFFSET]);
 153:tactile.c     ****             // ack the command
 154:tactile.c     ****             outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3;
 155:tactile.c     ****             outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = commandPacket[COMMAND_OFFSET];
 156:tactile.c     ****             outputBuffer[RESPONSE_STATUSCODE_OFFSET] = STATUS_OK;
 157:tactile.c     ****             outputBuffer[3] = computeChecksum(outputBuffer,3); //this is the checksum
 158:tactile.c     ****             return 4;
 159:tactile.c     ****         default:
 160:tactile.c     ****             outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3;
 161:tactile.c     ****             outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = commandPacket[COMMAND_OFFSET];
 162:tactile.c     ****             outputBuffer[RESPONSE_STATUSCODE_OFFSET] = UNKNOWN_COMMAND;
 163:tactile.c     ****             outputBuffer[3] = computeChecksum(outputBuffer,3); //this is the checksum
 164:tactile.c     ****             return 4;
 165:tactile.c     ****     }
 166:tactile.c     **** }
 167:tactile.c     **** 
 168:tactile.c     **** static int handleCollectionCommand(uint8_t *commandPacket, uint8_t *outputBuffer)
 169:tactile.c     **** {
 170:tactile.c     ****     uint8_t responseSize = 0;
 171:tactile.c     ****     uint16_t collectionBitfield;
 172:tactile.c     **** 
 173:tactile.c     ****     memcpy(&collectionBitfield,&commandPacket[PAYLOAD_OFFSET],2);
 174:tactile.c     **** 
 175:tactile.c     ****     if(collectionBitfield & DATA_COLLECTION_DYNAMIC_BITMASK)
 176:tactile.c     ****     {
 177:tactile.c     ****         captureSweep((int16_t *)&outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize]);
 178:tactile.c     ****         responseSize += 8;
 179:tactile.c     ****     }
 180:tactile.c     **** 
 181:tactile.c     ****     if(collectionBitfield & DATA_COLLECTION_TACTILE_BITMASK)
 182:tactile.c     ****     {
 183:tactile.c     ****         memcpy(&outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize], pressureData, NUMBER_OF_TACTILE
 184:tactile.c     ****         responseSize += NUMBER_OF_TACTILE_SENSORS*2;
 185:tactile.c     ****     }
 186:tactile.c     ****     
 187:tactile.c     ****     if(collectionBitfield & DATA_COLLECTION_DEBUG_BITMASK)
 188:tactile.c     ****     {
 189:tactile.c     ****         memcpy(&outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize],&RxCheckSumErrCnt,2);
 190:tactile.c     ****         responseSize += 2;
 191:tactile.c     ****     }
 192:tactile.c     ****     
 193:tactile.c     ****     if(collectionBitfield & DATA_COLLECTION_TACTILE_TEMP_BITMASK)
 194:tactile.c     ****     {
 195:tactile.c     ****         memcpy(&outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize], pressureTempData, NUMBER_OF_TAC
 196:tactile.c     ****         responseSize += NUMBER_OF_TACTILE_SENSORS*2;
 197:tactile.c     ****     }
 198:tactile.c     ****     
 199:tactile.c     ****     outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3+responseSize;
 200:tactile.c     ****     outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = DATA_COLLECTION_OPCODE;
 201:tactile.c     ****     outputBuffer[RESPONSE_STATUSCODE_OFFSET] = STATUS_OK;
 202:tactile.c     ****     outputBuffer[3+responseSize] = computeChecksum(outputBuffer,3+responseSize); //this is the chec
 203:tactile.c     ****     return 4+responseSize;
 204:tactile.c     **** 
 205:tactile.c     **** }
 206:tactile.c     **** 
 207:tactile.c     **** static int handleCalibrationCommand(uint8_t *commandPacket, uint8_t *outputBuffer)
 208:tactile.c     **** {
 209:tactile.c     ****     uint16_t collectionBitfield;
 210:tactile.c     **** 
 211:tactile.c     ****     memcpy(&collectionBitfield,&commandPacket[PAYLOAD_OFFSET],2);
 212:tactile.c     **** 
 213:tactile.c     ****     if(collectionBitfield & DATA_COLLECTION_TACTILE_BITMASK)
 214:tactile.c     ****     {
 215:tactile.c     ****         // zero out pressure readings with an offset
 216:tactile.c     ****         for(uint8_t i=0; i<NUMBER_OF_TACTILE_SENSORS; i++)
 217:tactile.c     ****         {
 218:tactile.c     ****             pressureDataOffset[i] = pressureData[i] + pressureDataOffset[i];
 219:tactile.c     ****         }
 220:tactile.c     ****     }
 221:tactile.c     **** 
 222:tactile.c     ****     if (collectionBitfield & DATA_COLLECTION_DEBUG_BITMASK)
 223:tactile.c     ****     {
 224:tactile.c     ****         RxCheckSumErrCnt[0] = 0;
 225:tactile.c     ****         RxCheckSumErrCnt[1] = 0;
 226:tactile.c     ****     }
 227:tactile.c     **** 
 228:tactile.c     ****     outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3;
 229:tactile.c     ****     outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = CALIBRATION_OPCODE;
 230:tactile.c     ****     outputBuffer[RESPONSE_STATUSCODE_OFFSET] = STATUS_OK;
 231:tactile.c     ****     outputBuffer[3] = computeChecksum(outputBuffer,3); //this is the checksum
 232:tactile.c     ****     return 4;
 233:tactile.c     **** }
 234:tactile.c     **** 
 235:tactile.c     **** int processCommand(uint8_t *commandPacket,uint8_t *outputBuffer)
 236:tactile.c     **** {
 237:tactile.c     ****   uint8_t opcode;
 238:tactile.c     **** 
 239:tactile.c     ****   opcode = commandPacket[COMMAND_OFFSET] & OPCODE_BITMASK;
 240:tactile.c     **** 
 241:tactile.c     ****   switch(opcode)
 242:tactile.c     ****     {
 243:tactile.c     **** 
 244:tactile.c     ****     case DATA_COLLECTION_OPCODE:
 245:tactile.c     ****       return handleCollectionCommand(commandPacket,outputBuffer);
 246:tactile.c     ****     case MOTOR_PARAMETER_RE_L_OPCODE:
 247:tactile.c     ****     case MOTOR_PARAMETER_RE_H_OPCODE:
 248:tactile.c     ****     case MOTOR_PARAMETER_WR_L_OPCODE:
 249:tactile.c     ****     case MOTOR_PARAMETER_WR_H_OPCODE:
 250:tactile.c     ****       return handleEEPROMCommand(commandPacket,outputBuffer);
 251:tactile.c     ****     case BOOTLOADER_OPCODE:
 252:tactile.c     ****       // no reply is expected, just reset/reboot to get into bootloader
 253:tactile.c     ****       //wdt_enable(WDT_PER_8CLK_gc);
 254:tactile.c     ****       wdt_enable(0); //x32a4u include files seem broken
 255:tactile.c     ****       while(1);  // use watchdog timer to trigger a reset
 256:tactile.c     ****       return 4; // to keep compiler happy
 257:tactile.c     ****     case CALIBRATION_OPCODE:
 258:tactile.c     ****       return handleCalibrationCommand(commandPacket, outputBuffer);
 259:tactile.c     ****     default:
 260:tactile.c     ****       outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3;
 261:tactile.c     ****       outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = opcode;
 262:tactile.c     ****       outputBuffer[RESPONSE_STATUSCODE_OFFSET] = UNKNOWN_COMMAND;
 263:tactile.c     ****       outputBuffer[3] = computeChecksum(outputBuffer,3); //this is the checksum
 264:tactile.c     ****       return 4;
 265:tactile.c     ****     }
 266:tactile.c     **** }
 267:tactile.c     **** 
 268:tactile.c     **** void LEDon(void)
 269:tactile.c     **** {
 189               		.loc 1 269 0
 190               		.cfi_startproc
 191               	/* prologue: function */
 192               	/* frame size = 0 */
 193               	/* stack size = 0 */
 194               	.L__stack_usage = 0
 270:tactile.c     ****     PORTB.OUT |= 0x08;
 195               		.loc 1 270 0
 196 009c E0E2      		ldi r30,lo8(1568)
 197 009e F6E0      		ldi r31,hi8(1568)
 198 00a0 8481      		ldd r24,Z+4
 199 00a2 8860      		ori r24,lo8(8)
 200 00a4 8483      		std Z+4,r24
 201               	/* epilogue start */
 271:tactile.c     **** }
 202               		.loc 1 271 0
 203 00a6 0895      		ret
 204               		.cfi_endproc
 205               	.LFE15:
 207               	.global	LEDoff
 209               	LEDoff:
 210               	.LFB16:
 272:tactile.c     **** void LEDoff(void)
 273:tactile.c     **** {
 211               		.loc 1 273 0
 212               		.cfi_startproc
 213               	/* prologue: function */
 214               	/* frame size = 0 */
 215               	/* stack size = 0 */
 216               	.L__stack_usage = 0
 274:tactile.c     ****     PORTB.OUT &= ~0x08;
 217               		.loc 1 274 0
 218 00a8 E0E2      		ldi r30,lo8(1568)
 219 00aa F6E0      		ldi r31,hi8(1568)
 220 00ac 8481      		ldd r24,Z+4
 221 00ae 877F      		andi r24,lo8(-9)
 222 00b0 8483      		std Z+4,r24
 223               	/* epilogue start */
 275:tactile.c     **** }
 224               		.loc 1 275 0
 225 00b2 0895      		ret
 226               		.cfi_endproc
 227               	.LFE16:
 229               	.global	processCommand
 231               	processCommand:
 232               	.LFB14:
 236:tactile.c     **** {
 233               		.loc 1 236 0
 234               		.cfi_startproc
 235               	.LVL9:
 236 00b4 CF92      		push r12
 237               	.LCFI16:
 238               		.cfi_def_cfa_offset 3
 239               		.cfi_offset 12, -2
 240 00b6 DF92      		push r13
 241               	.LCFI17:
 242               		.cfi_def_cfa_offset 4
 243               		.cfi_offset 13, -3
 244 00b8 EF92      		push r14
 245               	.LCFI18:
 246               		.cfi_def_cfa_offset 5
 247               		.cfi_offset 14, -4
 248 00ba FF92      		push r15
 249               	.LCFI19:
 250               		.cfi_def_cfa_offset 6
 251               		.cfi_offset 15, -5
 252 00bc 0F93      		push r16
 253               	.LCFI20:
 254               		.cfi_def_cfa_offset 7
 255               		.cfi_offset 16, -6
 256 00be 1F93      		push r17
 257               	.LCFI21:
 258               		.cfi_def_cfa_offset 8
 259               		.cfi_offset 17, -7
 260 00c0 CF93      		push r28
 261               	.LCFI22:
 262               		.cfi_def_cfa_offset 9
 263               		.cfi_offset 28, -8
 264 00c2 DF93      		push r29
 265               	.LCFI23:
 266               		.cfi_def_cfa_offset 10
 267               		.cfi_offset 29, -9
 268 00c4 0F92      		push __tmp_reg__
 269               	.LCFI24:
 270               		.cfi_def_cfa_offset 11
 271 00c6 CDB7      		in r28,__SP_L__
 272 00c8 DEB7      		in r29,__SP_H__
 273               	.LCFI25:
 274               		.cfi_def_cfa_register 28
 275               	/* prologue: function */
 276               	/* frame size = 1 */
 277               	/* stack size = 9 */
 278               	.L__stack_usage = 9
 279 00ca 8C01      		movw r16,r24
 280 00cc 7B01      		movw r14,r22
 239:tactile.c     ****   opcode = commandPacket[COMMAND_OFFSET] & OPCODE_BITMASK;
 281               		.loc 1 239 0
 282 00ce FC01      		movw r30,r24
 283 00d0 8181      		ldd r24,Z+1
 284               	.LVL10:
 285 00d2 982F      		mov r25,r24
 286 00d4 907F      		andi r25,lo8(-16)
 287               	.LVL11:
 241:tactile.c     ****   switch(opcode)
 288               		.loc 1 241 0
 289 00d6 9038      		cpi r25,lo8(-128)
 290 00d8 01F4      		brne .+2
 291 00da 00C0      		rjmp .L12
 292               	.LVL12:
 293 00dc 9138      		cpi r25,lo8(-127)
 294 00de 00F4      		brsh .L15
 295 00e0 9036      		cpi r25,lo8(96)
 296 00e2 01F4      		brne .+2
 297 00e4 00C0      		rjmp .L12
 298 00e6 9037      		cpi r25,lo8(112)
 299 00e8 01F4      		brne .+2
 300 00ea 00C0      		rjmp .L12
 301 00ec 9923      		tst r25
 302 00ee 01F0      		breq .L11
 303 00f0 00C0      		rjmp .L10
 304               	.L15:
 305 00f2 903B      		cpi r25,lo8(-80)
 306 00f4 01F4      		brne .+2
 307 00f6 00C0      		rjmp .L13
 308 00f8 903C      		cpi r25,lo8(-64)
 309 00fa 01F4      		brne .+2
 310 00fc 00C0      		rjmp .L14
 311 00fe 9039      		cpi r25,lo8(-112)
 312 0100 01F0      		breq .+2
 313 0102 00C0      		rjmp .L10
 314 0104 00C0      		rjmp .L12
 315               	.L11:
 316               	.LVL13:
 317               	.LBB24:
 318               	.LBB25:
 173:tactile.c     ****     memcpy(&collectionBitfield,&commandPacket[PAYLOAD_OFFSET],2);
 319               		.loc 1 173 0
 320 0106 F801      		movw r30,r16
 321 0108 0281      		ldd r16,Z+2
 322 010a 1381      		ldd r17,Z+3
 323               	.LVL14:
 175:tactile.c     ****     if(collectionBitfield & DATA_COLLECTION_DYNAMIC_BITMASK)
 324               		.loc 1 175 0
 325 010c 16FF      		sbrs r17,6
 326 010e 00C0      		rjmp .L34
 327               	.LVL15:
 177:tactile.c     ****         captureSweep((int16_t *)&outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize]);
 328               		.loc 1 177 0
 329 0110 CB01      		movw r24,r22
 330 0112 0396      		adiw r24,3
 331 0114 0E94 0000 		call captureSweep
 332               	.LVL16:
 178:tactile.c     ****         responseSize += 8;
 333               		.loc 1 178 0
 334 0118 28E0      		ldi r18,lo8(8)
 335 011a 00C0      		rjmp .L16
 336               	.LVL17:
 337               	.L34:
 170:tactile.c     ****     uint8_t responseSize = 0;
 338               		.loc 1 170 0
 339 011c 20E0      		ldi r18,lo8(0)
 340               	.LVL18:
 341               	.L16:
 181:tactile.c     ****     if(collectionBitfield & DATA_COLLECTION_TACTILE_BITMASK)
 342               		.loc 1 181 0
 343 011e 11FF      		sbrs r17,1
 344 0120 00C0      		rjmp .L17
 183:tactile.c     ****         memcpy(&outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize], pressureData, NUMBER_OF_TACTILE
 345               		.loc 1 183 0
 346 0122 F701      		movw r30,r14
 347 0124 E20F      		add r30,r18
 348 0126 F11D      		adc r31,__zero_reg__
 349 0128 3396      		adiw r30,3
 350 012a A0E0      		ldi r26,lo8(pressureData)
 351 012c B0E0      		ldi r27,hi8(pressureData)
 352 012e 80E6      		ldi r24,lo8(96)
 353               	.L18:
 354 0130 0D90      		ld r0,X+
 355 0132 0192      		st Z+,r0
 356 0134 8150      		subi r24,lo8(-(-1))
 357 0136 01F4      		brne .L18
 184:tactile.c     ****         responseSize += NUMBER_OF_TACTILE_SENSORS*2;
 358               		.loc 1 184 0
 359 0138 205A      		subi r18,lo8(-(96))
 360               	.LVL19:
 361               	.L17:
 187:tactile.c     ****     if(collectionBitfield & DATA_COLLECTION_DEBUG_BITMASK)
 362               		.loc 1 187 0
 363 013a 01FF      		sbrs r16,1
 364 013c 00C0      		rjmp .L19
 189:tactile.c     ****         memcpy(&outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize],&RxCheckSumErrCnt,2);
 365               		.loc 1 189 0
 366 013e 8091 0000 		lds r24,RxCheckSumErrCnt
 367 0142 9091 0000 		lds r25,RxCheckSumErrCnt+1
 368 0146 F701      		movw r30,r14
 369 0148 E20F      		add r30,r18
 370 014a F11D      		adc r31,__zero_reg__
 371 014c 8383      		std Z+3,r24
 372 014e 9483      		std Z+4,r25
 190:tactile.c     ****         responseSize += 2;
 373               		.loc 1 190 0
 374 0150 2E5F      		subi r18,lo8(-(2))
 375               	.LVL20:
 376               	.L19:
 193:tactile.c     ****     if(collectionBitfield & DATA_COLLECTION_TACTILE_TEMP_BITMASK)
 377               		.loc 1 193 0
 378 0152 00FF      		sbrs r16,0
 379 0154 00C0      		rjmp .L20
 195:tactile.c     ****         memcpy(&outputBuffer[RESPONSE_PAYLOAD_OFFSET+responseSize], pressureTempData, NUMBER_OF_TAC
 380               		.loc 1 195 0
 381 0156 F701      		movw r30,r14
 382 0158 E20F      		add r30,r18
 383 015a F11D      		adc r31,__zero_reg__
 384 015c 3396      		adiw r30,3
 385 015e A0E0      		ldi r26,lo8(pressureTempData)
 386 0160 B0E0      		ldi r27,hi8(pressureTempData)
 387 0162 80E6      		ldi r24,lo8(96)
 388               	.L21:
 389 0164 0D90      		ld r0,X+
 390 0166 0192      		st Z+,r0
 391 0168 8150      		subi r24,lo8(-(-1))
 392 016a 01F4      		brne .L21
 196:tactile.c     ****         responseSize += NUMBER_OF_TACTILE_SENSORS*2;
 393               		.loc 1 196 0
 394 016c 205A      		subi r18,lo8(-(96))
 395               	.LVL21:
 396               	.L20:
 199:tactile.c     ****     outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3+responseSize;
 397               		.loc 1 199 0
 398 016e 822F      		mov r24,r18
 399 0170 8D5F      		subi r24,lo8(-(3))
 400 0172 F701      		movw r30,r14
 401 0174 8083      		st Z,r24
 200:tactile.c     ****     outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = DATA_COLLECTION_OPCODE;
 402               		.loc 1 200 0
 403 0176 1182      		std Z+1,__zero_reg__
 201:tactile.c     ****     outputBuffer[RESPONSE_STATUSCODE_OFFSET] = STATUS_OK;
 404               		.loc 1 201 0
 405 0178 1282      		std Z+2,__zero_reg__
 202:tactile.c     ****     outputBuffer[3+responseSize] = computeChecksum(outputBuffer,3+responseSize); //this is the chec
 406               		.loc 1 202 0
 407 017a C22E      		mov r12,r18
 408 017c DD24      		clr r13
 409 017e B601      		movw r22,r12
 410 0180 6D5F      		subi r22,lo8(-(3))
 411 0182 7F4F      		sbci r23,hi8(-(3))
 412 0184 8701      		movw r16,r14
 413               	.LVL22:
 414 0186 060F      		add r16,r22
 415 0188 171F      		adc r17,r23
 416 018a C701      		movw r24,r14
 417 018c 0E94 0000 		call computeChecksum
 418               	.LVL23:
 419 0190 F801      		movw r30,r16
 420 0192 8083      		st Z,r24
 203:tactile.c     ****     return 4+responseSize;
 421               		.loc 1 203 0
 422 0194 C601      		movw r24,r12
 423 0196 0496      		adiw r24,4
 424               	.LBE25:
 425               	.LBE24:
 245:tactile.c     ****       return handleCollectionCommand(commandPacket,outputBuffer);
 426               		.loc 1 245 0
 427 0198 00C0      		rjmp .L22
 428               	.LVL24:
 429               	.L12:
 430               	.LBB26:
 431               	.LBB27:
 124:tactile.c     ****     address = commandPacket[COMMAND_OFFSET] & 0x1F;
 432               		.loc 1 124 0
 433 019a 8F71      		andi r24,lo8(31)
 434               	.LVL25:
 126:tactile.c     ****     switch(opcode)
 435               		.loc 1 126 0
 436 019c 9037      		cpi r25,lo8(112)
 437 019e 01F0      		breq .L24
 438 01a0 9137      		cpi r25,lo8(113)
 439 01a2 00F4      		brsh .L26
 440 01a4 9036      		cpi r25,lo8(96)
 441 01a6 01F4      		brne .L23
 442 01a8 00C0      		rjmp .L24
 443               	.L26:
 444 01aa 9038      		cpi r25,lo8(-128)
 445 01ac 01F0      		breq .L25
 446 01ae 9039      		cpi r25,lo8(-112)
 447 01b0 01F4      		brne .L23
 448 01b2 00C0      		rjmp .L25
 449               	.L24:
 131:tactile.c     ****             ReadIntFromEEPROM(address, &outputBuffer[RESPONSE_PAYLOAD_OFFSET]);
 450               		.loc 1 131 0
 451 01b4 B701      		movw r22,r14
 452 01b6 6D5F      		subi r22,lo8(-(3))
 453 01b8 7F4F      		sbci r23,hi8(-(3))
 454 01ba 0E94 0000 		call ReadIntFromEEPROM
 455               	.LVL26:
 133:tactile.c     ****             outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3+responseSize;
 456               		.loc 1 133 0
 457 01be 87E0      		ldi r24,lo8(7)
 458 01c0 F701      		movw r30,r14
 459 01c2 8083      		st Z,r24
 134:tactile.c     ****             outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = commandPacket[COMMAND_OFFSET];
 460               		.loc 1 134 0
 461 01c4 F801      		movw r30,r16
 462 01c6 8181      		ldd r24,Z+1
 463 01c8 F701      		movw r30,r14
 464 01ca 8183      		std Z+1,r24
 135:tactile.c     ****             outputBuffer[RESPONSE_STATUSCODE_OFFSET] = STATUS_OK;
 465               		.loc 1 135 0
 466 01cc 1282      		std Z+2,__zero_reg__
 136:tactile.c     ****             outputBuffer[3+responseSize] = computeChecksum(outputBuffer,3+responseSize); //this is 
 467               		.loc 1 136 0
 468 01ce C701      		movw r24,r14
 469 01d0 67E0      		ldi r22,lo8(7)
 470 01d2 70E0      		ldi r23,hi8(7)
 471 01d4 0E94 0000 		call computeChecksum
 472 01d8 F701      		movw r30,r14
 473 01da 8783      		std Z+7,r24
 137:tactile.c     ****             return 4+responseSize;
 474               		.loc 1 137 0
 475 01dc 88E0      		ldi r24,lo8(8)
 476 01de 90E0      		ldi r25,hi8(8)
 477 01e0 00C0      		rjmp .L22
 478               	.LVL27:
 479               	.L25:
 140:tactile.c     ****             if(address==EEPROM_ADDRESS_LED) {
 480               		.loc 1 140 0
 481 01e2 8F31      		cpi r24,lo8(31)
 482 01e4 01F4      		brne .L28
 141:tactile.c     ****                 if(commandPacket[PAYLOAD_OFFSET+0]
 483               		.loc 1 141 0
 484 01e6 F801      		movw r30,r16
 485 01e8 9381      		ldd r25,Z+3
 486               	.LVL28:
 487 01ea 2281      		ldd r18,Z+2
 488 01ec 922B      		or r25,r18
 489 01ee 2481      		ldd r18,Z+4
 490 01f0 922B      		or r25,r18
 491 01f2 2581      		ldd r18,Z+5
 492 01f4 922B      		or r25,r18
 145:tactile.c     ****                     LEDon();
 493               		.loc 1 145 0
 494 01f6 8983      		std Y+1,r24
 141:tactile.c     ****                 if(commandPacket[PAYLOAD_OFFSET+0]
 495               		.loc 1 141 0
 496 01f8 9923      		tst r25
 497 01fa 01F0      		breq .L29
 145:tactile.c     ****                     LEDon();
 498               		.loc 1 145 0
 499 01fc 0E94 0000 		call LEDon
 500               	.LVL29:
 501 0200 00C0      		rjmp .L38
 502               	.LVL30:
 503               	.L29:
 148:tactile.c     ****                     LEDoff();
 504               		.loc 1 148 0
 505 0202 0E94 0000 		call LEDoff
 506               	.LVL31:
 507               	.L38:
 508 0206 8981      		ldd r24,Y+1
 509               	.L28:
 152:tactile.c     ****             WriteIntToEEPROM(address, &commandPacket[PAYLOAD_OFFSET]);
 510               		.loc 1 152 0
 511 0208 B801      		movw r22,r16
 512 020a 6E5F      		subi r22,lo8(-(2))
 513 020c 7F4F      		sbci r23,hi8(-(2))
 514 020e 0E94 0000 		call WriteIntToEEPROM
 154:tactile.c     ****             outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3;
 515               		.loc 1 154 0
 516 0212 83E0      		ldi r24,lo8(3)
 517 0214 F701      		movw r30,r14
 518 0216 8083      		st Z,r24
 155:tactile.c     ****             outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = commandPacket[COMMAND_OFFSET];
 519               		.loc 1 155 0
 520 0218 F801      		movw r30,r16
 521 021a 8181      		ldd r24,Z+1
 522 021c F701      		movw r30,r14
 523 021e 00C0      		rjmp .L40
 524               	.LVL32:
 525               	.L23:
 160:tactile.c     ****             outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3;
 526               		.loc 1 160 0
 527 0220 83E0      		ldi r24,lo8(3)
 528               	.LVL33:
 529 0222 F701      		movw r30,r14
 530 0224 8083      		st Z,r24
 161:tactile.c     ****             outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = commandPacket[COMMAND_OFFSET];
 531               		.loc 1 161 0
 532 0226 F801      		movw r30,r16
 533 0228 8181      		ldd r24,Z+1
 534 022a F701      		movw r30,r14
 535 022c 8183      		std Z+1,r24
 536 022e 00C0      		rjmp .L41
 537               	.LVL34:
 538               	.L13:
 539               	.LBE27:
 540               	.LBE26:
 254:tactile.c     ****       wdt_enable(0); //x32a4u include files seem broken
 541               		.loc 1 254 0
 542 0230 93E0      		ldi r25,lo8(3)
 543               	.LVL35:
 544 0232 88ED      		ldi r24,lo8(-40)
 545               	/* #APP */
 546               	 ;  254 "tactile.c" 1
 547 0234 08B6      		in __tmp_reg__, 56
 548 0236 84BF      		out 52, r24
 549 0238 9093 8000 		sts 128, r25
 550 023c A895      		wdr
 551 023e 08BE      		out 56, __tmp_reg__
 552               		
 553               	 ;  0 "" 2
 554               	/* #NOAPP */
 555               	.L30:
 556 0240 00C0      		rjmp .L30
 557               	.LVL36:
 558               	.L14:
 559               	.LBB28:
 560               	.LBB29:
 211:tactile.c     ****     memcpy(&collectionBitfield,&commandPacket[PAYLOAD_OFFSET],2);
 561               		.loc 1 211 0
 562 0242 F801      		movw r30,r16
 563 0244 4281      		ldd r20,Z+2
 564 0246 5381      		ldd r21,Z+3
 565               	.LVL37:
 213:tactile.c     ****     if(collectionBitfield & DATA_COLLECTION_TACTILE_BITMASK)
 566               		.loc 1 213 0
 567 0248 51FF      		sbrs r21,1
 568 024a 00C0      		rjmp .L31
 569 024c A0E0      		ldi r26,lo8(pressureData)
 570 024e B0E0      		ldi r27,hi8(pressureData)
 571 0250 E0E0      		ldi r30,lo8(pressureDataOffset)
 572 0252 F0E0      		ldi r31,hi8(pressureDataOffset)
 573 0254 60E0      		ldi r22,lo8(0)
 574               	.L32:
 575               	.LBB30:
 218:tactile.c     ****             pressureDataOffset[i] = pressureData[i] + pressureDataOffset[i];
 576               		.loc 1 218 0
 577 0256 2D91      		ld r18,X+
 578 0258 3D91      		ld r19,X+
 579 025a 8081      		ld r24,Z
 580 025c 9181      		ldd r25,Z+1
 581 025e 820F      		add r24,r18
 582 0260 931F      		adc r25,r19
 583 0262 8193      		st Z+,r24
 584 0264 9193      		st Z+,r25
 216:tactile.c     ****         for(uint8_t i=0; i<NUMBER_OF_TACTILE_SENSORS; i++)
 585               		.loc 1 216 0
 586 0266 6F5F      		subi r22,lo8(-(1))
 587               	.LVL38:
 588 0268 6033      		cpi r22,lo8(48)
 589 026a 01F4      		brne .L32
 590               	.LVL39:
 591               	.L31:
 592               	.LBE30:
 222:tactile.c     ****     if (collectionBitfield & DATA_COLLECTION_DEBUG_BITMASK)
 593               		.loc 1 222 0
 594 026c 41FF      		sbrs r20,1
 595 026e 00C0      		rjmp .L33
 224:tactile.c     ****         RxCheckSumErrCnt[0] = 0;
 596               		.loc 1 224 0
 597 0270 1092 0000 		sts RxCheckSumErrCnt,__zero_reg__
 598 0274 1092 0000 		sts RxCheckSumErrCnt+1,__zero_reg__
 225:tactile.c     ****         RxCheckSumErrCnt[1] = 0;
 599               		.loc 1 225 0
 600 0278 1092 0000 		sts RxCheckSumErrCnt+2,__zero_reg__
 601 027c 1092 0000 		sts RxCheckSumErrCnt+2+1,__zero_reg__
 602               	.L33:
 228:tactile.c     ****     outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3;
 603               		.loc 1 228 0
 604 0280 83E0      		ldi r24,lo8(3)
 605 0282 F701      		movw r30,r14
 606 0284 8083      		st Z,r24
 229:tactile.c     ****     outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = CALIBRATION_OPCODE;
 607               		.loc 1 229 0
 608 0286 80EC      		ldi r24,lo8(-64)
 609               	.LVL40:
 610               	.L40:
 611 0288 8183      		std Z+1,r24
 230:tactile.c     ****     outputBuffer[RESPONSE_STATUSCODE_OFFSET] = STATUS_OK;
 612               		.loc 1 230 0
 613 028a 1282      		std Z+2,__zero_reg__
 614 028c 00C0      		rjmp .L39
 615               	.LVL41:
 616               	.L10:
 617               	.LBE29:
 618               	.LBE28:
 260:tactile.c     ****       outputBuffer[RESPONSE_PACKETSIZE_OFFSET] = 3;
 619               		.loc 1 260 0
 620 028e 83E0      		ldi r24,lo8(3)
 621 0290 F701      		movw r30,r14
 622 0292 8083      		st Z,r24
 261:tactile.c     ****       outputBuffer[RESPONSE_REFLECTEDOPCODE_OFFSET] = opcode;
 623               		.loc 1 261 0
 624 0294 9183      		std Z+1,r25
 625               	.L41:
 262:tactile.c     ****       outputBuffer[RESPONSE_STATUSCODE_OFFSET] = UNKNOWN_COMMAND;
 626               		.loc 1 262 0
 627 0296 82E0      		ldi r24,lo8(2)
 628 0298 8283      		std Z+2,r24
 629               	.LVL42:
 630               	.L39:
 263:tactile.c     ****       outputBuffer[3] = computeChecksum(outputBuffer,3); //this is the checksum
 631               		.loc 1 263 0
 632 029a C701      		movw r24,r14
 633 029c 63E0      		ldi r22,lo8(3)
 634 029e 70E0      		ldi r23,hi8(3)
 635 02a0 0E94 0000 		call computeChecksum
 636 02a4 F701      		movw r30,r14
 637 02a6 8383      		std Z+3,r24
 264:tactile.c     ****       return 4;
 638               		.loc 1 264 0
 639 02a8 84E0      		ldi r24,lo8(4)
 640 02aa 90E0      		ldi r25,hi8(4)
 641               	.LVL43:
 642               	.L22:
 643               	/* epilogue start */
 266:tactile.c     **** }
 644               		.loc 1 266 0
 645 02ac 0F90      		pop __tmp_reg__
 646 02ae DF91      		pop r29
 647 02b0 CF91      		pop r28
 648 02b2 1F91      		pop r17
 649 02b4 0F91      		pop r16
 650 02b6 FF90      		pop r15
 651 02b8 EF90      		pop r14
 652               	.LVL44:
 653 02ba DF90      		pop r13
 654 02bc CF90      		pop r12
 655 02be 0895      		ret
 656               		.cfi_endproc
 657               	.LFE14:
 659               	.global	LEDtoggle
 661               	LEDtoggle:
 662               	.LFB17:
 276:tactile.c     **** void LEDtoggle(void)
 277:tactile.c     **** {
 663               		.loc 1 277 0
 664               		.cfi_startproc
 665               	/* prologue: function */
 666               	/* frame size = 0 */
 667               	/* stack size = 0 */
 668               	.L__stack_usage = 0
 278:tactile.c     ****     PORTB.OUTTGL = 0x08;
 669               		.loc 1 278 0
 670 02c0 88E0      		ldi r24,lo8(8)
 671 02c2 E0E2      		ldi r30,lo8(1568)
 672 02c4 F6E0      		ldi r31,hi8(1568)
 673 02c6 8783      		std Z+7,r24
 674               	/* epilogue start */
 279:tactile.c     **** }
 675               		.loc 1 279 0
 676 02c8 0895      		ret
 677               		.cfi_endproc
 678               	.LFE17:
 680               		.section	.text.startup,"ax",@progbits
 681               	.global	main
 683               	main:
 684               	.LFB18:
 280:tactile.c     **** 
 281:tactile.c     **** /************************************************************************
 282:tactile.c     **** * MAIN function.
 283:tactile.c     **** *
 284:tactile.c     **** * This initializes the other port modules and polls a few volatile status
 285:tactile.c     **** * bits set in ISRs.
 286:tactile.c     **** ************************************************************************/
 287:tactile.c     **** int main(void)
 288:tactile.c     **** {
 685               		.loc 1 288 0
 686               		.cfi_startproc
 687 0000 CF93      		push r28
 688               	.LCFI26:
 689               		.cfi_def_cfa_offset 3
 690               		.cfi_offset 28, -2
 691 0002 DF93      		push r29
 692               	.LCFI27:
 693               		.cfi_def_cfa_offset 4
 694               		.cfi_offset 29, -3
 695 0004 00D0      		rcall .
 696 0006 00D0      		rcall .
 697               	.LCFI28:
 698               		.cfi_def_cfa_offset 8
 699 0008 CDB7      		in r28,__SP_L__
 700 000a DEB7      		in r29,__SP_H__
 701               	.LCFI29:
 702               		.cfi_def_cfa_register 28
 703               	/* prologue: function */
 704               	/* frame size = 4 */
 705               	/* stack size = 6 */
 706               	.L__stack_usage = 6
 289:tactile.c     ****     cli();                                    //disable all interrupts for clock reset
 707               		.loc 1 289 0
 708               	/* #APP */
 709               	 ;  289 "tactile.c" 1
 710 000c F894      		cli
 711               	 ;  0 "" 2
 712               	.LVL45:
 713               	/* #NOAPP */
 714               	.LBB31:
 715               	.LBB32:
 716               		.file 2 "/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../av
   1:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   6:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   9:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  12:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      distribution.
  16:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  17:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  21:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  33:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  35:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  38:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  41:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  42:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <math.h>
  45:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  46:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \file */
  47:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \code
  49:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \endcode
  53:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  54:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     used.
  58:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  59:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  68:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  77:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  81:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** */
  82:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  83:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  87:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  88:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  93:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  94:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  97:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  98:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #  include <math.h>
 102:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
 103:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 104:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /**
 105:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 107:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 109:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 112:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 114:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 120:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 125:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 129:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 132:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 140:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  */
 141:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** void
 142:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** {
 144:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 153:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 156:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 159:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#else
 160:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//round up by default
 161:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#endif
 163:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 164:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 717               		.loc 2 164 0
 718 000e 8FE3      		 ldi r24,lo8(7999)
 719 0010 9FE1      	    ldi r25,hi8(7999)
 720 0012 0197      	    1:sbiw r24,1
 721 0014 01F4      	    brne 1b
 722 0016 00C0      		rjmp .
 723 0018 0000      		nop
 724               	.LBE32:
 725               	.LBE31:
 726               	.LBB33:
 727               	.LBB34:
  70:tactile.c     ****     OSC.CTRL = OSC_RC32MEN_bm | OSC_RC32KEN_bm;            //enable the 32MHz ring oscillator and t
 728               		.loc 1 70 0
 729 001a 86E0      		ldi r24,lo8(6)
 730 001c 8093 5000 		sts 80,r24
 731               	.L44:
  71:tactile.c     ****     while(!(OSC.STATUS & OSC_RC32MRDY_bm));                //wait for 32MHz to stabilize
 732               		.loc 1 71 0
 733 0020 8091 5100 		lds r24,81
 734 0024 81FF      		sbrs r24,1
 735 0026 00C0      		rjmp .L44
 736               	.L53:
  72:tactile.c     ****     while(!(OSC.STATUS & OSC_RC32KRDY_bm));                //wait for 32kHz to stabilize
 737               		.loc 1 72 0
 738 0028 8091 5100 		lds r24,81
 739 002c 82FF      		sbrs r24,2
 740 002e 00C0      		rjmp .L53
  74:tactile.c     ****     DFLLRC32M.CTRL = DFLL_ENABLE_bm;
 741               		.loc 1 74 0
 742 0030 81E0      		ldi r24,lo8(1)
 743 0032 8093 6000 		sts 96,r24
  75:tactile.c     ****     DFLLRC2M.CTRL = DFLL_ENABLE_bm;
 744               		.loc 1 75 0
 745 0036 8093 6800 		sts 104,r24
  77:tactile.c     ****     CCP = CCP_IOREG_gc;                                    //clock is protected by Configuration Ch
 746               		.loc 1 77 0
 747 003a 98ED      		ldi r25,lo8(-40)
 748 003c 94BF      		out 52-0,r25
  78:tactile.c     ****     CLK.CTRL = CLK_SCLKSEL_RC32M_gc;                    //switch to 32MHz oscillator
 749               		.loc 1 78 0
 750 003e 8093 4000 		sts 64,r24
  79:tactile.c     ****     CLK.RTCCTRL = CLK_RTCSRC_RCOSC_gc | CLK_RTCEN_bm;    //Select 1.024 kHz from internal oscillato
 751               		.loc 1 79 0
 752 0042 85E0      		ldi r24,lo8(5)
 753 0044 E0E4      		ldi r30,lo8(64)
 754 0046 F0E0      		ldi r31,hi8(64)
 755 0048 8383      		std Z+3,r24
 756               	.LVL46:
 757               	.LBE34:
 758               	.LBE33:
 759               	.LBB35:
 760               	.LBB36:
 761               		.loc 2 164 0
 762 004a 8FE3      		 ldi r24,lo8(7999)
 763 004c 9FE1      	    ldi r25,hi8(7999)
 764 004e 0197      	    1:sbiw r24,1
 765 0050 01F4      	    brne 1b
 766 0052 00C0      		rjmp .
 767 0054 0000      		nop
 768               	.LBE36:
 769               	.LBE35:
 290:tactile.c     ****     _delay_ms(1); // for stability of supplies
 291:tactile.c     ****     configureClocks();
 292:tactile.c     ****     _delay_ms(1); // for stability of clocks
 293:tactile.c     ****     configurePortIO();
 770               		.loc 1 293 0
 771 0056 0E94 0000 		call configurePortIO
 294:tactile.c     ****     configureSPIModules();
 772               		.loc 1 294 0
 773 005a 0E94 0000 		call configureSPIModules
 295:tactile.c     ****     configureADC();
 774               		.loc 1 295 0
 775 005e 0E94 0000 		call configureADC
 296:tactile.c     ****     configureDaisyUSART();
 776               		.loc 1 296 0
 777 0062 0E94 0000 		call configureDaisyUSART
 778               	.LBB37:
 779               	.LBB38:
  85:tactile.c     ****     uint32_t zero_check = 0;
 780               		.loc 1 85 0
 781 0066 1982      		std Y+1,__zero_reg__
 782 0068 1A82      		std Y+2,__zero_reg__
 783 006a 1B82      		std Y+3,__zero_reg__
 784 006c 1C82      		std Y+4,__zero_reg__
 785               	.LVL47:
  86:tactile.c     ****     ReadIntFromEEPROM(EEPROM_ADDRESS_LED, (uint8_t*)&zero_check);
 786               		.loc 1 86 0
 787 006e 8FE1      		ldi r24,lo8(31)
 788 0070 BE01      		movw r22,r28
 789 0072 6F5F      		subi r22,lo8(-(1))
 790 0074 7F4F      		sbci r23,hi8(-(1))
 791 0076 0E94 0000 		call ReadIntFromEEPROM
  88:tactile.c     ****     if(zero_check)
 792               		.loc 1 88 0
 793 007a 8981      		ldd r24,Y+1
 794 007c 9A81      		ldd r25,Y+2
 795 007e AB81      		ldd r26,Y+3
 796 0080 BC81      		ldd r27,Y+4
 797 0082 0097      		sbiw r24,0
 798 0084 A105      		cpc r26,__zero_reg__
 799 0086 B105      		cpc r27,__zero_reg__
 800 0088 01F0      		breq .L46
  89:tactile.c     ****         LEDon();
 801               		.loc 1 89 0
 802 008a 0E94 0000 		call LEDon
 803 008e 00C0      		rjmp .L47
 804               	.L46:
  91:tactile.c     ****         LEDoff();
 805               		.loc 1 91 0
 806 0090 0E94 0000 		call LEDoff
 807               	.L47:
 808               	.LBE38:
 809               	.LBE37:
 810               	.LBB39:
 811               	.LBB40:
 108:tactile.c     ****     uint32_t readversion = 0;
 812               		.loc 1 108 0
 813 0094 1982      		std Y+1,__zero_reg__
 814 0096 1A82      		std Y+2,__zero_reg__
 815 0098 1B82      		std Y+3,__zero_reg__
 816 009a 1C82      		std Y+4,__zero_reg__
 817               	.LVL48:
 109:tactile.c     ****     ReadIntFromEEPROM(EEPROM_ADDRESS_FIRMWARE_VERSION, (uint8_t*)&readversion);
 818               		.loc 1 109 0
 819 009c 8DE1      		ldi r24,lo8(29)
 820 009e BE01      		movw r22,r28
 821 00a0 6F5F      		subi r22,lo8(-(1))
 822 00a2 7F4F      		sbci r23,hi8(-(1))
 823 00a4 0E94 0000 		call ReadIntFromEEPROM
 110:tactile.c     ****     if (readversion != FIRMWARE_VERSION)
 824               		.loc 1 110 0
 825 00a8 8981      		ldd r24,Y+1
 826 00aa 9A81      		ldd r25,Y+2
 827 00ac AB81      		ldd r26,Y+3
 828 00ae BC81      		ldd r27,Y+4
 829 00b0 8D32      		cpi r24,lo8(301)
 830 00b2 21E0      		ldi r18,hi8(301)
 831 00b4 9207      		cpc r25,r18
 832 00b6 20E0      		ldi r18,hlo8(301)
 833 00b8 A207      		cpc r26,r18
 834 00ba 20E0      		ldi r18,hhi8(301)
 835 00bc B207      		cpc r27,r18
 836 00be 01F0      		breq .L48
 112:tactile.c     ****         readversion = FIRMWARE_VERSION;
 837               		.loc 1 112 0
 838 00c0 8DE2      		ldi r24,lo8(301)
 839 00c2 91E0      		ldi r25,hi8(301)
 840 00c4 A0E0      		ldi r26,hlo8(301)
 841 00c6 B0E0      		ldi r27,hhi8(301)
 842 00c8 8983      		std Y+1,r24
 843 00ca 9A83      		std Y+2,r25
 844 00cc AB83      		std Y+3,r26
 845 00ce BC83      		std Y+4,r27
 113:tactile.c     ****         WriteIntToEEPROM(EEPROM_ADDRESS_FIRMWARE_VERSION, (uint8_t*)&readversion);
 846               		.loc 1 113 0
 847 00d0 8DE1      		ldi r24,lo8(29)
 848 00d2 BE01      		movw r22,r28
 849 00d4 6F5F      		subi r22,lo8(-(1))
 850 00d6 7F4F      		sbci r23,hi8(-(1))
 851 00d8 0E94 0000 		call WriteIntToEEPROM
 852               	.L48:
 853               	.LBE40:
 854               	.LBE39:
 297:tactile.c     ****     initStateFromEEPROM();
 298:tactile.c     ****     verifyVersion();
 299:tactile.c     ****     initTactileModule(); // initialize variables of the tactile buffer
 855               		.loc 1 299 0
 856 00dc 0E94 0000 		call initTactileModule
 300:tactile.c     ****     notifyDaisy = 0;
 857               		.loc 1 300 0
 858 00e0 1092 0000 		sts notifyDaisy,__zero_reg__
 301:tactile.c     ****     tactReady = 0;
 859               		.loc 1 301 0
 860 00e4 1092 0000 		sts tactReady,__zero_reg__
 302:tactile.c     **** 
 303:tactile.c     ****     PMIC.CTRL |= PMIC_LOLVLEN_bm;            //tell event system to pay attention to low-priority i
 861               		.loc 1 303 0
 862 00e8 8091 A200 		lds r24,162
 863 00ec 8160      		ori r24,lo8(1)
 864 00ee E0EA      		ldi r30,lo8(160)
 865 00f0 F0E0      		ldi r31,hi8(160)
 866 00f2 8283      		std Z+2,r24
 304:tactile.c     ****     sei();
 867               		.loc 1 304 0
 868               	/* #APP */
 869               	 ;  304 "tactile.c" 1
 870 00f4 7894      		sei
 871               	 ;  0 "" 2
 305:tactile.c     **** 
 306:tactile.c     ****     collectAllCalibrationValues();
 872               		.loc 1 306 0
 873               	/* #NOAPP */
 874 00f6 0E94 0000 		call collectAllCalibrationValues
 875               	.L57:
 307:tactile.c     **** 
 308:tactile.c     ****     while(1){
 309:tactile.c     **** 
 310:tactile.c     ****         if(notifyDaisy)
 876               		.loc 1 310 0
 877 00fa 8091 0000 		lds r24,notifyDaisy
 878 00fe 8823      		tst r24
 879 0100 01F0      		breq .L49
 311:tactile.c     ****         {
 312:tactile.c     ****             doDaisyTask();
 880               		.loc 1 312 0
 881 0102 0E94 0000 		call doDaisyTask
 882               	.L49:
 313:tactile.c     ****         }
 314:tactile.c     **** 
 315:tactile.c     ****         if(tactReady)
 883               		.loc 1 315 0
 884 0106 8091 0000 		lds r24,tactReady
 885 010a 8823      		tst r24
 886 010c 01F0      		breq .L57
 316:tactile.c     ****         {
 317:tactile.c     ****             doTactSensors();
 887               		.loc 1 317 0
 888 010e 0E94 0000 		call doTactSensors
 889 0112 00C0      		rjmp .L57
 890               		.cfi_endproc
 891               	.LFE18:
 893               		.comm testADC,8,1
 894               		.text
 895               	.Letext0:
 896               		.file 3 "/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../av
 897               		.file 4 "/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../av
 898               		.file 5 "../common/daisycomm.h"
 899               		.file 6 "tactsense.h"
DEFINED SYMBOLS
                            *ABS*:00000000 tactile.c
     /tmp/ccZ8Hp04.s:2      *ABS*:0000003f __SREG__
     /tmp/ccZ8Hp04.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccZ8Hp04.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccZ8Hp04.s:5      *ABS*:00000034 __CCP__
     /tmp/ccZ8Hp04.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccZ8Hp04.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccZ8Hp04.s:14     .text:00000000 ReadIntFromEEPROM
     /tmp/ccZ8Hp04.s:101    .text:0000004e WriteIntToEEPROM
     /tmp/ccZ8Hp04.s:187    .text:0000009c LEDon
     /tmp/ccZ8Hp04.s:209    .text:000000a8 LEDoff
     /tmp/ccZ8Hp04.s:231    .text:000000b4 processCommand
     /tmp/ccZ8Hp04.s:661    .text:000002c0 LEDtoggle
     /tmp/ccZ8Hp04.s:683    .text.startup:00000000 main
                            *COM*:00000008 testADC

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__eerd_byte_x32a4
__eewr_byte_x32a4
captureSweep
pressureData
RxCheckSumErrCnt
pressureTempData
computeChecksum
pressureDataOffset
configurePortIO
configureSPIModules
configureADC
configureDaisyUSART
initTactileModule
notifyDaisy
tactReady
collectAllCalibrationValues
doDaisyTask
doTactSensors
