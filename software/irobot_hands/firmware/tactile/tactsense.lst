   1               		.file	"tactsense.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  14               	getDoubleWord:
  15               	.LFB9:
  16               		.file 1 "tactsense.c"
   1:tactsense.c   **** /****************************************************
   2:tactsense.c   **** 
   3:tactsense.c   ****  // Author:            Zachary Clifford
   4:tactsense.c   ****  // File Name:        C1482-SRC-TACMCU-0_tactsense.c
   5:tactsense.c   ****  // Creation Date:    24 February, 2012
   6:tactsense.c   ****  // Revision:        00
   7:tactsense.c   ****  // Hardware:        ATxmega32A4U
   8:tactsense.c   ****  // Description:    Tactile sensor driver
   9:tactsense.c   **** 
  10:tactsense.c   **** ****************************************************/
  11:tactsense.c   **** 
  12:tactsense.c   **** /******************************************************************************
  13:tactsense.c   ****     File Revision History:
  14:tactsense.c   **** -------------------------------------------------------------------------------
  15:tactsense.c   **** Revision    Date        Engineer    Description
  16:tactsense.c   **** --------    --------    --------    -------------------------------------------
  17:tactsense.c   **** 00            MM/DD/YY    ZAC            Initial Release
  18:tactsense.c   **** -------------------------------------------------------------------------------
  19:tactsense.c   **** 
  20:tactsense.c   **** ******************************************************************************/
  21:tactsense.c   **** 
  22:tactsense.c   **** #include "tactile.h"
  23:tactsense.c   **** #include "tactsense.h"
  24:tactsense.c   **** 
  25:tactsense.c   **** #include <avr/io.h>
  26:tactsense.c   **** #include <avr/interrupt.h>
  27:tactsense.c   **** #include <stdlib.h>
  28:tactsense.c   **** 
  29:tactsense.c   **** #define SPI0 SPIC
  30:tactsense.c   **** #define SPI1 SPID
  31:tactsense.c   **** 
  32:tactsense.c   **** #define TACT_ADDR_MASK 0x07
  33:tactsense.c   **** #define TACT_CS_MASK 0x18
  34:tactsense.c   **** #define TACT_CS1_CS4 0x00
  35:tactsense.c   **** #define TACT_CS2_CS5 0x08
  36:tactsense.c   **** #define TACT_CS3_CS6 0x10
  37:tactsense.c   **** 
  38:tactsense.c   **** #define TACT_TIMEOUT 96
  39:tactsense.c   **** 
  40:tactsense.c   **** #define CONVERT_OPCODE 0x24
  41:tactsense.c   **** #define READ_PRESSURE_MSB_OPCODE 0x80
  42:tactsense.c   **** #define READ_PRESSURE_LSB_OPCODE 0x82
  43:tactsense.c   **** #define READ_TEMPERATURE_MSB_OPCODE 0x84
  44:tactsense.c   **** #define READ_TEMPERATURE_LSB_OPCODE 0x86
  45:tactsense.c   **** #define READ_COEFFA0_MSB_OPCODE 0x88
  46:tactsense.c   **** #define READ_COEFFA0_LSB_OPCODE 0x8A
  47:tactsense.c   **** #define READ_COEFFB1_MSB_OPCODE 0x8C
  48:tactsense.c   **** #define READ_COEFFB1_LSB_OPCODE 0x8E
  49:tactsense.c   **** #define READ_COEFFB2_MSB_OPCODE 0x90
  50:tactsense.c   **** #define READ_COEFFB2_LSB_OPCODE 0x92
  51:tactsense.c   **** #define READ_COEFFC12_MSB_OPCODE 0x94
  52:tactsense.c   **** #define READ_COEFFC12_LSB_OPCODE 0x96
  53:tactsense.c   **** 
  54:tactsense.c   **** 
  55:tactsense.c   **** int16_t pressureData[NUMBER_OF_TACTILE_SENSORS];
  56:tactsense.c   **** int16_t pressureDataOffset[NUMBER_OF_TACTILE_SENSORS];
  57:tactsense.c   **** int16_t pressureTempData[NUMBER_OF_TACTILE_SENSORS];
  58:tactsense.c   **** 
  59:tactsense.c   **** // int16_t a0coeff[NUMBER_OF_TACTILE_SENSORS];
  60:tactsense.c   **** // int16_t b1coeff[NUMBER_OF_TACTILE_SENSORS];
  61:tactsense.c   **** // int16_t b2coeff[NUMBER_OF_TACTILE_SENSORS];
  62:tactsense.c   **** // int16_t c12coeff[NUMBER_OF_TACTILE_SENSORS];
  63:tactsense.c   **** 
  64:tactsense.c   **** //float floatingPressureData[NUMBER_OF_TACTILE_SENSORS];
  65:tactsense.c   **** // uint16_t rawpressure[NUMBER_OF_TACTILE_SENSORS];
  66:tactsense.c   **** // uint16_t rawtemp[NUMBER_OF_TACTILE_SENSORS];
  67:tactsense.c   **** 
  68:tactsense.c   **** uint8_t pressureCalibrated[NUMBER_OF_TACTILE_SENSORS];
  69:tactsense.c   **** uint16_t lastPressure[NUMBER_OF_TACTILE_SENSORS];
  70:tactsense.c   **** int16_t adjustedPressure[NUMBER_OF_TACTILE_SENSORS];
  71:tactsense.c   **** 
  72:tactsense.c   **** void compensatePressure(uint16_t tempReading, uint16_t pressureReading,uint8_t sensorIndex);
  73:tactsense.c   **** static void convertTactSensorPair(uint8_t tactAddress);
  74:tactsense.c   **** static void readTactSensorPair(uint8_t tactAddress, int16_t *firstSensor, int16_t *secondSensor);
  75:tactsense.c   **** static void selectSensorPair(uint8_t tactAddress);
  76:tactsense.c   **** 
  77:tactsense.c   **** volatile uint8_t tactReady = 0;
  78:tactsense.c   **** 
  79:tactsense.c   **** ISR(TACT_TC_vect)
  80:tactsense.c   **** {
  81:tactsense.c   ****     tactReady = 1;
  82:tactsense.c   ****     TACT_TC.CTRLA = TC_CLKSEL_OFF_gc;
  83:tactsense.c   ****     return;
  84:tactsense.c   **** }
  85:tactsense.c   **** 
  86:tactsense.c   **** //The system can take 8 MHz.  Peripheral clock is set to 32 MHz internally, so a divide by 4 presca
  87:tactsense.c   **** 
  88:tactsense.c   **** void configureSPIModules(void)
  89:tactsense.c   **** {
  90:tactsense.c   ****     SPI0.INTCTRL = SPI_INTLVL_OFF_gc;
  91:tactsense.c   ****     SPI0.CTRL = SPI_ENABLE_bm | SPI_MASTER_bm | SPI_MODE_0_gc | SPI_PRESCALER_DIV4_gc;
  92:tactsense.c   **** 
  93:tactsense.c   ****     SPI1.INTCTRL = SPI_INTLVL_OFF_gc;
  94:tactsense.c   ****     SPI1.CTRL = SPI_ENABLE_bm | SPI_MASTER_bm | SPI_MODE_0_gc | SPI_PRESCALER_DIV4_gc;
  95:tactsense.c   **** 
  96:tactsense.c   **** }
  97:tactsense.c   **** 
  98:tactsense.c   **** //initialization
  99:tactsense.c   **** void initTactileModule(void)
 100:tactsense.c   **** {
 101:tactsense.c   ****     for(uint8_t i=0; i<NUMBER_OF_TACTILE_SENSORS; i++)
 102:tactsense.c   ****     {
 103:tactsense.c   ****         pressureCalibrated[i] = 0;
 104:tactsense.c   ****         pressureData[i] = 0;
 105:tactsense.c   ****         pressureDataOffset[i] = 0;
 106:tactsense.c   ****         pressureTempData[i] = 0;
 107:tactsense.c   ****         // a0coeff[i] = 0;
 108:tactsense.c   ****         // b1coeff[i] = 0;
 109:tactsense.c   ****         // b2coeff[i] = 0;
 110:tactsense.c   ****         // c12coeff[i] = 0;
 111:tactsense.c   ****         // rawpressure[i] = 0;
 112:tactsense.c   ****         // rawtemp[i] = 0;
 113:tactsense.c   ****         lastPressure[i] = 0;
 114:tactsense.c   ****         adjustedPressure[i] = 0;
 115:tactsense.c   ****     }
 116:tactsense.c   **** }
 117:tactsense.c   **** 
 118:tactsense.c   **** static void getDoubleWord(uint8_t startingOpcode, uint16_t *firstResponse, uint16_t *secondResponse
 119:tactsense.c   **** {
  17               		.loc 1 119 0
  18               		.cfi_startproc
  19               	.LVL0:
  20 0000 CF93      		push r28
  21               	.LCFI0:
  22               		.cfi_def_cfa_offset 3
  23               		.cfi_offset 28, -2
  24 0002 DF93      		push r29
  25               	.LCFI1:
  26               		.cfi_def_cfa_offset 4
  27               		.cfi_offset 29, -3
  28               	/* prologue: function */
  29               	/* frame size = 0 */
  30               	/* stack size = 2 */
  31               	.L__stack_usage = 2
  32 0004 FB01      		movw r30,r22
  33 0006 EA01      		movw r28,r20
 120:tactsense.c   ****     uint8_t dummyRead;
 121:tactsense.c   **** 
 122:tactsense.c   ****     //Send the data.
 123:tactsense.c   ****     SPI0.DATA = startingOpcode;
  34               		.loc 1 123 0
  35 0008 A0EC      		ldi r26,lo8(2240)
  36 000a B8E0      		ldi r27,hi8(2240)
  37 000c 1396      		adiw r26,3
  38 000e 8C93      		st X,r24
 124:tactsense.c   ****     SPI1.DATA = startingOpcode;
  39               		.loc 1 124 0
  40 0010 A0EC      		ldi r26,lo8(2496)
  41 0012 B9E0      		ldi r27,hi8(2496)
  42 0014 1396      		adiw r26,3
  43 0016 8C93      		st X,r24
  44 0018 1397      		sbiw r26,3
  45               	.L2:
 125:tactsense.c   **** 
 126:tactsense.c   ****     while(!(SPI0.STATUS & SPI_IF_bm));
  46               		.loc 1 126 0 discriminator 1
  47 001a 9091 C208 		lds r25,2242
  48 001e 97FF      		sbrs r25,7
  49 0020 00C0      		rjmp .L2
  50               	.L13:
 127:tactsense.c   ****     while(!(SPI1.STATUS & SPI_IF_bm));
  51               		.loc 1 127 0 discriminator 1
  52 0022 9091 C209 		lds r25,2498
  53 0026 97FF      		sbrs r25,7
  54 0028 00C0      		rjmp .L13
 128:tactsense.c   **** 
 129:tactsense.c   ****     //Read the dummy data
 130:tactsense.c   ****     dummyRead = SPI0.DATA;
  55               		.loc 1 130 0
  56 002a 9091 C308 		lds r25,2243
 131:tactsense.c   ****     dummyRead = SPI1.DATA;
  57               		.loc 1 131 0
  58 002e 9091 C309 		lds r25,2499
 132:tactsense.c   **** 
 133:tactsense.c   ****     //Send the dummy byte
 134:tactsense.c   ****     SPI0.DATA = 0x00;
  59               		.loc 1 134 0
  60 0032 A0EC      		ldi r26,lo8(2240)
  61 0034 B8E0      		ldi r27,hi8(2240)
  62 0036 1396      		adiw r26,3
  63 0038 1C92      		st X,__zero_reg__
 135:tactsense.c   ****     SPI1.DATA = 0x00;
  64               		.loc 1 135 0
  65 003a A0EC      		ldi r26,lo8(2496)
  66 003c B9E0      		ldi r27,hi8(2496)
  67 003e 1396      		adiw r26,3
  68 0040 1C92      		st X,__zero_reg__
  69 0042 1397      		sbiw r26,3
  70               	.L4:
 136:tactsense.c   **** 
 137:tactsense.c   ****     while(!(SPI0.STATUS & SPI_IF_bm));
  71               		.loc 1 137 0 discriminator 1
  72 0044 9091 C208 		lds r25,2242
  73 0048 97FF      		sbrs r25,7
  74 004a 00C0      		rjmp .L4
  75               	.L12:
 138:tactsense.c   ****     while(!(SPI1.STATUS & SPI_IF_bm));
  76               		.loc 1 138 0 discriminator 1
  77 004c 9091 C209 		lds r25,2498
  78 0050 97FF      		sbrs r25,7
  79 0052 00C0      		rjmp .L12
 139:tactsense.c   **** 
 140:tactsense.c   ****     //Read the MSB data
 141:tactsense.c   ****     dummyRead = SPI0.DATA;
  80               		.loc 1 141 0
  81 0054 9091 C308 		lds r25,2243
  82               	.LVL1:
 142:tactsense.c   ****     *firstResponse = dummyRead << 8;
  83               		.loc 1 142 0
  84 0058 1082      		st Z,__zero_reg__
  85 005a 9183      		std Z+1,r25
 143:tactsense.c   ****     dummyRead = SPI1.DATA;
  86               		.loc 1 143 0
  87 005c 9091 C309 		lds r25,2499
  88               	.LVL2:
 144:tactsense.c   ****     *secondResponse = dummyRead << 8;
  89               		.loc 1 144 0
  90 0060 1882      		st Y,__zero_reg__
  91 0062 9983      		std Y+1,r25
 145:tactsense.c   **** 
 146:tactsense.c   ****     //Send the data.
 147:tactsense.c   ****     SPI0.DATA = startingOpcode+2;
  92               		.loc 1 147 0
  93 0064 8E5F      		subi r24,lo8(-(2))
  94               	.LVL3:
  95 0066 A0EC      		ldi r26,lo8(2240)
  96 0068 B8E0      		ldi r27,hi8(2240)
  97               	.LVL4:
  98 006a 1396      		adiw r26,3
  99 006c 8C93      		st X,r24
 148:tactsense.c   ****     SPI1.DATA = startingOpcode+2;
 100               		.loc 1 148 0
 101 006e A0EC      		ldi r26,lo8(2496)
 102 0070 B9E0      		ldi r27,hi8(2496)
 103               	.LVL5:
 104 0072 1396      		adiw r26,3
 105 0074 8C93      		st X,r24
 106 0076 1397      		sbiw r26,3
 107               	.L6:
 149:tactsense.c   **** 
 150:tactsense.c   ****     while(!(SPI0.STATUS & SPI_IF_bm));
 108               		.loc 1 150 0 discriminator 1
 109 0078 8091 C208 		lds r24,2242
 110 007c 87FF      		sbrs r24,7
 111 007e 00C0      		rjmp .L6
 112               	.L11:
 151:tactsense.c   ****     while(!(SPI1.STATUS & SPI_IF_bm));
 113               		.loc 1 151 0 discriminator 1
 114 0080 8091 C209 		lds r24,2498
 115 0084 87FF      		sbrs r24,7
 116 0086 00C0      		rjmp .L11
 152:tactsense.c   **** 
 153:tactsense.c   ****     //Read the dummy data
 154:tactsense.c   ****     dummyRead = SPI0.DATA;
 117               		.loc 1 154 0
 118 0088 8091 C308 		lds r24,2243
 119               	.LVL6:
 155:tactsense.c   ****     dummyRead = SPI1.DATA;
 120               		.loc 1 155 0
 121 008c 8091 C309 		lds r24,2499
 156:tactsense.c   **** 
 157:tactsense.c   ****     //Send the dummy byte
 158:tactsense.c   ****     SPI0.DATA = 0x00;
 122               		.loc 1 158 0
 123 0090 A0EC      		ldi r26,lo8(2240)
 124 0092 B8E0      		ldi r27,hi8(2240)
 125               	.LVL7:
 126 0094 1396      		adiw r26,3
 127 0096 1C92      		st X,__zero_reg__
 159:tactsense.c   ****     SPI1.DATA = 0x00;
 128               		.loc 1 159 0
 129 0098 A0EC      		ldi r26,lo8(2496)
 130 009a B9E0      		ldi r27,hi8(2496)
 131               	.LVL8:
 132 009c 1396      		adiw r26,3
 133 009e 1C92      		st X,__zero_reg__
 134 00a0 1397      		sbiw r26,3
 135               	.L8:
 160:tactsense.c   **** 
 161:tactsense.c   ****     while(!(SPI0.STATUS & SPI_IF_bm));
 136               		.loc 1 161 0 discriminator 1
 137 00a2 8091 C208 		lds r24,2242
 138 00a6 87FF      		sbrs r24,7
 139 00a8 00C0      		rjmp .L8
 140               	.L10:
 162:tactsense.c   ****     while(!(SPI1.STATUS & SPI_IF_bm));
 141               		.loc 1 162 0 discriminator 1
 142 00aa 8091 C209 		lds r24,2498
 143 00ae 87FF      		sbrs r24,7
 144 00b0 00C0      		rjmp .L10
 163:tactsense.c   **** 
 164:tactsense.c   ****     //Read the LSB data
 165:tactsense.c   ****     dummyRead = SPI0.DATA;
 145               		.loc 1 165 0
 146 00b2 2091 C308 		lds r18,2243
 147               	.LVL9:
 166:tactsense.c   ****     *firstResponse |= dummyRead;
 148               		.loc 1 166 0
 149 00b6 30E0      		ldi r19,lo8(0)
 150 00b8 8081      		ld r24,Z
 151 00ba 9181      		ldd r25,Z+1
 152 00bc 822B      		or r24,r18
 153 00be 932B      		or r25,r19
 154 00c0 8083      		st Z,r24
 155 00c2 9183      		std Z+1,r25
 167:tactsense.c   ****     dummyRead = SPI1.DATA;
 156               		.loc 1 167 0
 157 00c4 2091 C309 		lds r18,2499
 158               	.LVL10:
 168:tactsense.c   ****     *secondResponse |= dummyRead;
 159               		.loc 1 168 0
 160 00c8 30E0      		ldi r19,lo8(0)
 161 00ca 8881      		ld r24,Y
 162 00cc 9981      		ldd r25,Y+1
 163 00ce 822B      		or r24,r18
 164 00d0 932B      		or r25,r19
 165 00d2 8883      		st Y,r24
 166 00d4 9983      		std Y+1,r25
 167               	/* epilogue start */
 169:tactsense.c   **** 
 170:tactsense.c   ****     return;
 171:tactsense.c   **** }
 168               		.loc 1 171 0
 169 00d6 DF91      		pop r29
 170 00d8 CF91      		pop r28
 171 00da 0895      		ret
 172               		.cfi_endproc
 173               	.LFE9:
 176               	selectSensorPair:
 177               	.LFB11:
 172:tactsense.c   **** 
 173:tactsense.c   **** /**
 174:tactsense.c   ****  * readTactSensorPair(uint8_t tactAddress)
 175:tactsense.c   ****  * Reads a tactile sensor pair given by tactAddress.
 176:tactsense.c   ****  * It assumes that the pair had been previously told to begin a conversion
 177:tactsense.c   ****  * the lower three bits of tactAddress denote the Address line status to be used.  The next two bit
 178:tactsense.c   ****  * set the proper chip selects to be used according to the following table:
 179:tactsense.c   ****  * 00 - nCS1 and nCS4
 180:tactsense.c   ****  * 01 - nCS2 and nCS5
 181:tactsense.c   ****  * 10 - nCS3 and nCS6
 182:tactsense.c   ****  * 11 - Invalid
 183:tactsense.c   ****  *
 184:tactsense.c   ****  * The remaining bits are don't cares.  This means that the addressing is all adjacent and that a r
 185:tactsense.c   ****  * feed incrementing addresses up to decimal 24 to read all 48 tactile sensors.
 186:tactsense.c   ****  */
 187:tactsense.c   **** static void readTactSensorPair(uint8_t tactAddress, int16_t *firstSensor, int16_t *secondSensor)
 188:tactsense.c   **** {
 189:tactsense.c   ****     uint8_t dummyRead;
 190:tactsense.c   ****     uint16_t firstPressureReading,secondPressureReading;
 191:tactsense.c   ****     uint16_t firstTempReading,secondTempReading;
 192:tactsense.c   **** 
 193:tactsense.c   ****     selectSensorPair(tactAddress);
 194:tactsense.c   **** 
 195:tactsense.c   ****     getDoubleWord(READ_PRESSURE_MSB_OPCODE,&firstPressureReading,&secondPressureReading);
 196:tactsense.c   **** 
 197:tactsense.c   ****     getDoubleWord(READ_TEMPERATURE_MSB_OPCODE,&firstTempReading,&secondTempReading);
 198:tactsense.c   **** 
 199:tactsense.c   ****     //Do a final dummy write
 200:tactsense.c   **** 
 201:tactsense.c   ****     //Send the data.
 202:tactsense.c   ****     SPI0.DATA = 0x00;
 203:tactsense.c   ****     SPI1.DATA = 0x00;
 204:tactsense.c   **** 
 205:tactsense.c   ****     while(!(SPI0.STATUS & SPI_IF_bm));
 206:tactsense.c   ****     while(!(SPI1.STATUS & SPI_IF_bm));
 207:tactsense.c   **** 
 208:tactsense.c   ****     //Read the dummy data
 209:tactsense.c   ****     dummyRead = SPI0.DATA;
 210:tactsense.c   ****     dummyRead = SPI1.DATA;
 211:tactsense.c   **** 
 212:tactsense.c   ****     //Reset the chip select and address lines
 213:tactsense.c   ****     PORTE.OUTSET = 0xFF;
 214:tactsense.c   ****     PORTD.OUTSET = 0x18;
 215:tactsense.c   ****     PORTD.OUTCLR = TACT_ADDR_MASK;
 216:tactsense.c   **** 
 217:tactsense.c   ****     // protect against bad data if reading accelerometer
 218:tactsense.c   ****     if (firstPressureReading != 0)
 219:tactsense.c   ****     {
 220:tactsense.c   ****         //floatingPressureData[tactAddress] = compensatePressure(firstTempReading,firstPressureRead
 221:tactsense.c   ****         compensatePressure(firstTempReading, firstPressureReading, tactAddress);
 222:tactsense.c   ****         //rawtemp[tactAddress] = firstTempReading;
 223:tactsense.c   ****         //rawpressure[tactAddress] = firstPressureReading;
 224:tactsense.c   ****     }
 225:tactsense.c   **** 
 226:tactsense.c   ****     // protect against bad data if reading accelerometer
 227:tactsense.c   ****     if (secondPressureReading != 0)
 228:tactsense.c   ****     {
 229:tactsense.c   ****         //floatingPressureData[tactAddress+24] = compensatePressure(secondTempReading,secondPressur
 230:tactsense.c   ****         compensatePressure(secondTempReading, secondPressureReading, tactAddress+24);
 231:tactsense.c   ****         //rawtemp[tactAddress+24] = secondTempReading;
 232:tactsense.c   ****         //rawpressure[tactAddress+24] = secondPressureReading;
 233:tactsense.c   ****     }
 234:tactsense.c   **** 
 235:tactsense.c   ****     return;
 236:tactsense.c   **** }
 237:tactsense.c   **** 
 238:tactsense.c   **** /**
 239:tactsense.c   ****  * convertTactSensorPair(uint8_t tactAddress)
 240:tactsense.c   ****  * Reads a tactile sensor pair given by tactAddress.
 241:tactsense.c   ****  * It assumes that the pair had been previously told to begin a conversion
 242:tactsense.c   ****  * the lower three bits of tactAddress denote the Address line status to be used.  The next two bit
 243:tactsense.c   ****  * set the proper chip selects to be used according to the following table:
 244:tactsense.c   ****  * 00 - nCS1 and nCS4
 245:tactsense.c   ****  * 01 - nCS2 and nCS5
 246:tactsense.c   ****  * 10 - nCS3 and nCS6
 247:tactsense.c   ****  * 11 - Invalid
 248:tactsense.c   ****  *
 249:tactsense.c   ****  * The remaining bits are don't cares.  This means that the addressing is all adjacent and that a r
 250:tactsense.c   ****  * feed incrementing addresses up to decimal 24 to read all 48 tactile sensors.
 251:tactsense.c   ****  */
 252:tactsense.c   **** 
 253:tactsense.c   **** //For simplicity, the Tactile sensor address pins are all on PD0 - PD2
 254:tactsense.c   **** static void selectSensorPair(uint8_t tactAddress)
 255:tactsense.c   **** {
 178               		.loc 1 255 0
 179               		.cfi_startproc
 180               	.LVL11:
 181               	/* prologue: function */
 182               	/* frame size = 0 */
 183               	/* stack size = 0 */
 184               	.L__stack_usage = 0
 256:tactsense.c   ****     uint8_t dummyRead;
 257:tactsense.c   ****     //First set the address properly
 258:tactsense.c   ****     PORTD.OUTSET = tactAddress & TACT_ADDR_MASK;
 185               		.loc 1 258 0
 186 00dc 982F      		mov r25,r24
 187 00de 9770      		andi r25,lo8(7)
 188 00e0 E0E6      		ldi r30,lo8(1632)
 189 00e2 F6E0      		ldi r31,hi8(1632)
 190 00e4 9583      		std Z+5,r25
 259:tactsense.c   **** 
 260:tactsense.c   ****     //Now assert the proper chip selects
 261:tactsense.c   ****     switch(tactAddress & TACT_CS_MASK)
 191               		.loc 1 261 0
 192 00e6 90E0      		ldi r25,lo8(0)
 193 00e8 8871      		andi r24,lo8(24)
 194 00ea 9070      		andi r25,hi8(24)
 195               	.LVL12:
 196 00ec 8830      		cpi r24,8
 197 00ee 9105      		cpc r25,__zero_reg__
 198 00f0 01F0      		breq .L25
 199 00f2 8031      		cpi r24,16
 200 00f4 9105      		cpc r25,__zero_reg__
 201 00f6 01F0      		breq .L26
 202 00f8 0097      		sbiw r24,0
 203 00fa 01F4      		brne .L30
 262:tactsense.c   ****     {
 263:tactsense.c   ****         case TACT_CS1_CS4:
 264:tactsense.c   ****             PORTD.OUTCLR = 0x08;
 204               		.loc 1 264 0
 205 00fc 88E0      		ldi r24,lo8(8)
 206 00fe 8683      		std Z+6,r24
 265:tactsense.c   ****             PORTE.OUTCLR = 0x02;
 207               		.loc 1 265 0
 208 0100 82E0      		ldi r24,lo8(2)
 209 0102 00C0      		rjmp .L31
 210               	.L25:
 266:tactsense.c   ****             break;
 267:tactsense.c   ****         case TACT_CS2_CS5:
 268:tactsense.c   ****             PORTD.OUTCLR = 0x10;
 211               		.loc 1 268 0
 212 0104 80E1      		ldi r24,lo8(16)
 213 0106 8683      		std Z+6,r24
 269:tactsense.c   ****             PORTE.OUTCLR = 0x04;
 214               		.loc 1 269 0
 215 0108 84E0      		ldi r24,lo8(4)
 216 010a 00C0      		rjmp .L31
 217               	.L26:
 270:tactsense.c   ****             break;
 271:tactsense.c   ****         case TACT_CS3_CS6:
 272:tactsense.c   ****             PORTE.OUTCLR = 0x09;
 218               		.loc 1 272 0
 219 010c 89E0      		ldi r24,lo8(9)
 220               	.L31:
 221 010e E0E8      		ldi r30,lo8(1664)
 222 0110 F6E0      		ldi r31,hi8(1664)
 223 0112 8683      		std Z+6,r24
 273:tactsense.c   ****             break;
 274:tactsense.c   ****         default:
 275:tactsense.c   ****             //Should never get here.  Invalid address
 276:tactsense.c   ****             //Reset address lines and get out
 277:tactsense.c   ****             PORTD.OUTCLR = TACT_ADDR_MASK;
 278:tactsense.c   ****             return;
 279:tactsense.c   ****     }
 280:tactsense.c   **** 
 281:tactsense.c   ****     //Make sure transmitters are OK
 282:tactsense.c   ****     if(SPI0.STATUS & SPI_IF_bm)
 224               		.loc 1 282 0
 225 0114 8091 C208 		lds r24,2242
 226 0118 87FF      		sbrs r24,7
 227 011a 00C0      		rjmp .L29
 228 011c 00C0      		rjmp .L32
 229               	.L30:
 277:tactsense.c   ****             PORTD.OUTCLR = TACT_ADDR_MASK;
 230               		.loc 1 277 0
 231 011e 87E0      		ldi r24,lo8(7)
 232 0120 8683      		std Z+6,r24
 278:tactsense.c   ****             return;
 233               		.loc 1 278 0
 234 0122 0895      		ret
 235               	.L32:
 283:tactsense.c   ****     {
 284:tactsense.c   ****         dummyRead = SPI0.DATA;
 236               		.loc 1 284 0
 237 0124 8091 C308 		lds r24,2243
 238               	.L29:
 285:tactsense.c   ****     }
 286:tactsense.c   **** 
 287:tactsense.c   ****     if(SPI1.STATUS & SPI_IF_bm)
 239               		.loc 1 287 0
 240 0128 8091 C209 		lds r24,2498
 241 012c 87FF      		sbrs r24,7
 242 012e 00C0      		rjmp .L22
 288:tactsense.c   ****     {
 289:tactsense.c   ****         dummyRead = SPI1.DATA;
 243               		.loc 1 289 0
 244 0130 8091 C309 		lds r24,2499
 245               	.L22:
 246 0134 0895      		ret
 247               		.cfi_endproc
 248               	.LFE11:
 250               	.global	__vector_20
 252               	__vector_20:
 253               	.LFB6:
  80:tactsense.c   **** {
 254               		.loc 1 80 0
 255               		.cfi_startproc
 256 0136 1F92      		push r1
 257               	.LCFI2:
 258               		.cfi_def_cfa_offset 3
 259               		.cfi_offset 1, -2
 260 0138 0F92      		push r0
 261               	.LCFI3:
 262               		.cfi_def_cfa_offset 4
 263               		.cfi_offset 0, -3
 264 013a 0FB6      		in r0,__SREG__
 265 013c 0F92      		push r0
 266 013e 1124      		clr __zero_reg__
 267 0140 8F93      		push r24
 268               	.LCFI4:
 269               		.cfi_def_cfa_offset 5
 270               		.cfi_offset 24, -4
 271               	/* prologue: Signal */
 272               	/* frame size = 0 */
 273               	/* stack size = 4 */
 274               	.L__stack_usage = 4
  81:tactsense.c   ****     tactReady = 1;
 275               		.loc 1 81 0
 276 0142 81E0      		ldi r24,lo8(1)
 277 0144 8093 0000 		sts tactReady,r24
  82:tactsense.c   ****     TACT_TC.CTRLA = TC_CLKSEL_OFF_gc;
 278               		.loc 1 82 0
 279 0148 1092 4008 		sts 2112,__zero_reg__
 280               	/* epilogue start */
  84:tactsense.c   **** }
 281               		.loc 1 84 0
 282 014c 8F91      		pop r24
 283 014e 0F90      		pop r0
 284 0150 0FBE      		out __SREG__,r0
 285 0152 0F90      		pop r0
 286 0154 1F90      		pop r1
 287 0156 1895      		reti
 288               		.cfi_endproc
 289               	.LFE6:
 291               	.global	configureSPIModules
 293               	configureSPIModules:
 294               	.LFB7:
  89:tactsense.c   **** {
 295               		.loc 1 89 0
 296               		.cfi_startproc
 297               	/* prologue: function */
 298               	/* frame size = 0 */
 299               	/* stack size = 0 */
 300               	.L__stack_usage = 0
  90:tactsense.c   ****     SPI0.INTCTRL = SPI_INTLVL_OFF_gc;
 301               		.loc 1 90 0
 302 0158 E0EC      		ldi r30,lo8(2240)
 303 015a F8E0      		ldi r31,hi8(2240)
 304 015c 1182      		std Z+1,__zero_reg__
  91:tactsense.c   ****     SPI0.CTRL = SPI_ENABLE_bm | SPI_MASTER_bm | SPI_MODE_0_gc | SPI_PRESCALER_DIV4_gc;
 305               		.loc 1 91 0
 306 015e 80E5      		ldi r24,lo8(80)
 307 0160 8083      		st Z,r24
  93:tactsense.c   ****     SPI1.INTCTRL = SPI_INTLVL_OFF_gc;
 308               		.loc 1 93 0
 309 0162 E0EC      		ldi r30,lo8(2496)
 310 0164 F9E0      		ldi r31,hi8(2496)
 311 0166 1182      		std Z+1,__zero_reg__
  94:tactsense.c   ****     SPI1.CTRL = SPI_ENABLE_bm | SPI_MASTER_bm | SPI_MODE_0_gc | SPI_PRESCALER_DIV4_gc;
 312               		.loc 1 94 0
 313 0168 8083      		st Z,r24
 314               	/* epilogue start */
  96:tactsense.c   **** }
 315               		.loc 1 96 0
 316 016a 0895      		ret
 317               		.cfi_endproc
 318               	.LFE7:
 320               	.global	initTactileModule
 322               	initTactileModule:
 323               	.LFB8:
 100:tactsense.c   **** {
 324               		.loc 1 100 0
 325               		.cfi_startproc
 326 016c 0F93      		push r16
 327               	.LCFI5:
 328               		.cfi_def_cfa_offset 3
 329               		.cfi_offset 16, -2
 330 016e 1F93      		push r17
 331               	.LCFI6:
 332               		.cfi_def_cfa_offset 4
 333               		.cfi_offset 17, -3
 334 0170 CF93      		push r28
 335               	.LCFI7:
 336               		.cfi_def_cfa_offset 5
 337               		.cfi_offset 28, -4
 338 0172 DF93      		push r29
 339               	.LCFI8:
 340               		.cfi_def_cfa_offset 6
 341               		.cfi_offset 29, -5
 342               	/* prologue: function */
 343               	/* frame size = 0 */
 344               	/* stack size = 4 */
 345               	.L__stack_usage = 4
 346               	.LVL13:
 100:tactsense.c   **** {
 347               		.loc 1 100 0
 348 0174 00E0      		ldi r16,lo8(pressureCalibrated)
 349 0176 10E0      		ldi r17,hi8(pressureCalibrated)
 350 0178 A0E0      		ldi r26,lo8(pressureData)
 351 017a B0E0      		ldi r27,hi8(pressureData)
 352 017c C0E0      		ldi r28,lo8(pressureDataOffset)
 353 017e D0E0      		ldi r29,hi8(pressureDataOffset)
 354 0180 80E0      		ldi r24,lo8(pressureTempData)
 355 0182 90E0      		ldi r25,hi8(pressureTempData)
 356 0184 20E0      		ldi r18,lo8(lastPressure)
 357 0186 30E0      		ldi r19,hi8(lastPressure)
 358 0188 40E0      		ldi r20,lo8(adjustedPressure)
 359 018a 50E0      		ldi r21,hi8(adjustedPressure)
 360 018c 60E3      		ldi r22,lo8(48)
 361               	.LVL14:
 362               	.L36:
 363               	.LBB4:
 103:tactsense.c   ****         pressureCalibrated[i] = 0;
 364               		.loc 1 103 0 discriminator 2
 365 018e F801      		movw r30,r16
 366 0190 1192      		st Z+,__zero_reg__
 367 0192 8F01      		movw r16,r30
 104:tactsense.c   ****         pressureData[i] = 0;
 368               		.loc 1 104 0 discriminator 2
 369 0194 1D92      		st X+,__zero_reg__
 370 0196 1D92      		st X+,__zero_reg__
 105:tactsense.c   ****         pressureDataOffset[i] = 0;
 371               		.loc 1 105 0 discriminator 2
 372 0198 1992      		st Y+,__zero_reg__
 373 019a 1992      		st Y+,__zero_reg__
 106:tactsense.c   ****         pressureTempData[i] = 0;
 374               		.loc 1 106 0 discriminator 2
 375 019c FC01      		movw r30,r24
 376 019e 1192      		st Z+,__zero_reg__
 377 01a0 1192      		st Z+,__zero_reg__
 378 01a2 CF01      		movw r24,r30
 113:tactsense.c   ****         lastPressure[i] = 0;
 379               		.loc 1 113 0 discriminator 2
 380 01a4 F901      		movw r30,r18
 381 01a6 1192      		st Z+,__zero_reg__
 382 01a8 1192      		st Z+,__zero_reg__
 383 01aa 9F01      		movw r18,r30
 114:tactsense.c   ****         adjustedPressure[i] = 0;
 384               		.loc 1 114 0 discriminator 2
 385 01ac FA01      		movw r30,r20
 386 01ae 1192      		st Z+,__zero_reg__
 387 01b0 1192      		st Z+,__zero_reg__
 388 01b2 AF01      		movw r20,r30
 389 01b4 6150      		subi r22,lo8(-(-1))
 101:tactsense.c   ****     for(uint8_t i=0; i<NUMBER_OF_TACTILE_SENSORS; i++)
 390               		.loc 1 101 0 discriminator 2
 391 01b6 01F4      		brne .L36
 392               	/* epilogue start */
 393               	.LBE4:
 116:tactsense.c   **** }
 394               		.loc 1 116 0
 395 01b8 DF91      		pop r29
 396 01ba CF91      		pop r28
 397 01bc 1F91      		pop r17
 398 01be 0F91      		pop r16
 399 01c0 0895      		ret
 400               		.cfi_endproc
 401               	.LFE8:
 403               	.global	collectAllCalibrationValues
 405               	collectAllCalibrationValues:
 406               	.LFB14:
 290:tactsense.c   ****     }
 291:tactsense.c   **** 
 292:tactsense.c   ****     return;
 293:tactsense.c   **** }
 294:tactsense.c   **** 
 295:tactsense.c   **** static void convertTactSensorPair(uint8_t tactAddress)
 296:tactsense.c   **** {
 297:tactsense.c   ****     uint8_t dummyRead;
 298:tactsense.c   ****     selectSensorPair(tactAddress);
 299:tactsense.c   **** 
 300:tactsense.c   ****     //Send the data.
 301:tactsense.c   ****     SPI0.DATA = CONVERT_OPCODE;
 302:tactsense.c   ****     SPI1.DATA = CONVERT_OPCODE;
 303:tactsense.c   **** 
 304:tactsense.c   ****     while(!(SPI0.STATUS & SPI_IF_bm));
 305:tactsense.c   ****     while(!(SPI1.STATUS & SPI_IF_bm));
 306:tactsense.c   **** 
 307:tactsense.c   ****     //Read the dummy data
 308:tactsense.c   ****     dummyRead = SPI0.DATA;
 309:tactsense.c   ****     dummyRead = SPI1.DATA;
 310:tactsense.c   **** 
 311:tactsense.c   ****     //Send the dummy byte
 312:tactsense.c   ****     SPI0.DATA = 0x00;
 313:tactsense.c   ****     SPI1.DATA = 0x00;
 314:tactsense.c   **** 
 315:tactsense.c   ****     while(!(SPI0.STATUS & SPI_IF_bm));
 316:tactsense.c   ****     while(!(SPI1.STATUS & SPI_IF_bm));
 317:tactsense.c   **** 
 318:tactsense.c   ****     //Read the dummy data
 319:tactsense.c   ****     dummyRead = SPI0.DATA;
 320:tactsense.c   ****     dummyRead = SPI1.DATA;
 321:tactsense.c   **** 
 322:tactsense.c   ****     //Reset the chip select and address lines
 323:tactsense.c   ****     PORTE.OUTSET = 0xFF;
 324:tactsense.c   ****     PORTD.OUTSET = 0x18;
 325:tactsense.c   ****     PORTD.OUTCLR = TACT_ADDR_MASK;
 326:tactsense.c   **** 
 327:tactsense.c   ****     return;
 328:tactsense.c   **** }
 329:tactsense.c   **** 
 330:tactsense.c   **** uint8_t activeSensor = 0;
 331:tactsense.c   **** 
 332:tactsense.c   **** void doTactSensors(void)
 333:tactsense.c   **** {
 334:tactsense.c   ****     uint8_t i;
 335:tactsense.c   **** 
 336:tactsense.c   ****     //Set all chip selects high
 337:tactsense.c   ****     PORTE.OUTSET = 0xFF;
 338:tactsense.c   ****     PORTD.OUTSET = 0x18;
 339:tactsense.c   **** 
 340:tactsense.c   ****     //Lower all address lines
 341:tactsense.c   ****     PORTD.OUTCLR = TACT_ADDR_MASK;
 342:tactsense.c   **** 
 343:tactsense.c   ****     if(activeSensor == 24)
 344:tactsense.c   ****     {
 345:tactsense.c   ****         //Set the Tactile Timer to expire at 3 ms and begin conversion
 346:tactsense.c   ****         cli();
 347:tactsense.c   ****         tactReady = 0;
 348:tactsense.c   ****         sei();
 349:tactsense.c   ****         for(i=0;i<24;i++)
 350:tactsense.c   ****         {
 351:tactsense.c   ****             convertTactSensorPair(i);
 352:tactsense.c   ****         }
 353:tactsense.c   **** 
 354:tactsense.c   ****         TACT_TC.CTRLB = TC_WGMODE_NORMAL_gc;
 355:tactsense.c   ****         TACT_TC.CTRLC = 0x00;
 356:tactsense.c   ****         TACT_TC.CTRLD = TC_EVACT_OFF_gc | TC_EVSEL_OFF_gc;
 357:tactsense.c   ****         TACT_TC.CTRLE = 0x00;
 358:tactsense.c   ****         TACT_TC.PERBUF = TACT_TIMEOUT;
 359:tactsense.c   ****         TACT_TC.CNT = 0x0000;
 360:tactsense.c   ****         TACT_TC.INTCTRLA = TC_OVFINTLVL_LO_gc;
 361:tactsense.c   ****         TACT_TC.CTRLA = TC_CLKSEL_DIV1024_gc;
 362:tactsense.c   ****         activeSensor = 0;
 363:tactsense.c   ****         return;
 364:tactsense.c   ****     }
 365:tactsense.c   **** 
 366:tactsense.c   ****     //readTactSensor(activeSensor, &pressureData[activeSensor]);
 367:tactsense.c   ****     readTactSensorPair(activeSensor, &pressureData[activeSensor], &pressureData[activeSensor+24]);
 368:tactsense.c   ****     activeSensor++;
 369:tactsense.c   ****     //Leave tactReady asserted so that we can quickly return after giving command a chance
 370:tactsense.c   **** }
 371:tactsense.c   **** 
 372:tactsense.c   **** /************************************************************************
 373:tactsense.c   ****  * collectAllTactSensors(void)
 374:tactsense.c   ****  * Blocking call to read all tactile sensors right now.
 375:tactsense.c   ****  ***********************************************************************
 376:tactsense.c   **** void collectAllTactSensors(void)
 377:tactsense.c   **** {
 378:tactsense.c   ****     int i=0;
 379:tactsense.c   ****     //First set the pins to known values to tighten inner reading loops
 380:tactsense.c   **** 
 381:tactsense.c   ****     //Set all chip selects high
 382:tactsense.c   ****     PORTE.OUTSET = 0xFF;
 383:tactsense.c   ****     PORTD.OUTSET = 0x18;
 384:tactsense.c   **** 
 385:tactsense.c   ****     //Lower all address lines
 386:tactsense.c   ****     PORTD.OUTCLR = TACT_ADDR_MASK;
 387:tactsense.c   **** 
 388:tactsense.c   ****     for(i=0;i<24;i++)
 389:tactsense.c   ****     {
 390:tactsense.c   ****         convertTactSensorPair(i);
 391:tactsense.c   ****     }
 392:tactsense.c   **** 
 393:tactsense.c   ****     //Each sensor takes two bytes at 8MHz, so the delay per sensor is 2 usec.
 394:tactsense.c   ****     //There are 24 groups receiving the conversion signals, so there are at a minimum
 395:tactsense.c   ****     //48 usecs of delay.  Measurement in the system will confirm how fast this really is.
 396:tactsense.c   ****     //For now, assume that only 50 usecs have passed since the first conversion start signal was se
 397:tactsense.c   ****     //
 398:tactsense.c   ****     //The sensors take 3 ms to convert.  This means that the system must sleep for 2.95 ms.
 399:tactsense.c   ****     _delay_ms(2.95);
 400:tactsense.c   **** 
 401:tactsense.c   ****     //Now read the pressure sensors.
 402:tactsense.c   ****     for(i=0;i<24;i++)
 403:tactsense.c   ****     {
 404:tactsense.c   ****         readTactSensorPair(i, &pressureData[i], &pressureData[i+24]);
 405:tactsense.c   ****     }
 406:tactsense.c   **** 
 407:tactsense.c   ****     return;
 408:tactsense.c   **** 
 409:tactsense.c   **** }
 410:tactsense.c   **** */
 411:tactsense.c   **** 
 412:tactsense.c   **** 
 413:tactsense.c   **** // static void readCoefficientPair(uint8_t tactAddress)
 414:tactsense.c   **** // {
 415:tactsense.c   **** //     uint8_t dummyRead;
 416:tactsense.c   **** 
 417:tactsense.c   **** //     selectSensorPair(tactAddress);
 418:tactsense.c   **** //     getDoubleWord(READ_COEFFA0_MSB_OPCODE,(uint16_t *)&a0coeff[tactAddress],(uint16_t *)&a0coeff
 419:tactsense.c   **** //     getDoubleWord(READ_COEFFB1_MSB_OPCODE,(uint16_t *)&b1coeff[tactAddress],(uint16_t *)&b1coeff
 420:tactsense.c   **** //     getDoubleWord(READ_COEFFB2_MSB_OPCODE,(uint16_t *)&b2coeff[tactAddress],(uint16_t *)&b2coeff
 421:tactsense.c   **** //     getDoubleWord(READ_COEFFA0_MSB_OPCODE,(uint16_t *)&c12coeff[tactAddress],(uint16_t *)&c12coe
 422:tactsense.c   **** 
 423:tactsense.c   **** //     //Send the dummy byte
 424:tactsense.c   **** //     SPI0.DATA = 0x00;
 425:tactsense.c   **** //     SPI1.DATA = 0x00;
 426:tactsense.c   **** 
 427:tactsense.c   **** //     while(!(SPI0.STATUS & SPI_IF_bm));
 428:tactsense.c   **** //     while(!(SPI1.STATUS & SPI_IF_bm));
 429:tactsense.c   **** 
 430:tactsense.c   **** //     //Read the dummy data
 431:tactsense.c   **** //     dummyRead = SPI0.DATA;
 432:tactsense.c   **** //     dummyRead = SPI1.DATA;
 433:tactsense.c   **** 
 434:tactsense.c   **** //     //Reset the chip select and address lines
 435:tactsense.c   **** //     PORTE.OUTSET = 0xFF;
 436:tactsense.c   **** //     PORTD.OUTSET = 0x18;
 437:tactsense.c   **** //     PORTD.OUTCLR = TACT_ADDR_MASK;
 438:tactsense.c   **** 
 439:tactsense.c   **** //     return;
 440:tactsense.c   **** // }
 441:tactsense.c   **** 
 442:tactsense.c   **** void collectAllCalibrationValues(void)
 443:tactsense.c   **** {
 407               		.loc 1 443 0
 408               		.cfi_startproc
 409               	/* prologue: function */
 410               	/* frame size = 0 */
 411               	/* stack size = 0 */
 412               	.L__stack_usage = 0
 413               	.LVL15:
 444:tactsense.c   ****     int i=0;
 445:tactsense.c   ****     //First set the pins to known values to tighten inner reading loops
 446:tactsense.c   **** 
 447:tactsense.c   ****     //Set all chip selects high
 448:tactsense.c   ****     PORTE.OUTSET = 0xFF;
 414               		.loc 1 448 0
 415 01c2 8FEF      		ldi r24,lo8(-1)
 416 01c4 E0E8      		ldi r30,lo8(1664)
 417 01c6 F6E0      		ldi r31,hi8(1664)
 418 01c8 8583      		std Z+5,r24
 449:tactsense.c   ****     PORTD.OUTSET = 0x18;
 419               		.loc 1 449 0
 420 01ca E0E6      		ldi r30,lo8(1632)
 421 01cc F6E0      		ldi r31,hi8(1632)
 422 01ce 88E1      		ldi r24,lo8(24)
 423 01d0 8583      		std Z+5,r24
 450:tactsense.c   **** 
 451:tactsense.c   ****     //Lower all address lines
 452:tactsense.c   ****     PORTD.OUTCLR = TACT_ADDR_MASK;
 424               		.loc 1 452 0
 425 01d2 27E0      		ldi r18,lo8(7)
 426 01d4 2683      		std Z+6,r18
 453:tactsense.c   **** 
 454:tactsense.c   ****     // for(i=0;i<24;i++)
 455:tactsense.c   ****     // {
 456:tactsense.c   ****     //     readCoefficientPair(i);
 457:tactsense.c   ****     // }
 458:tactsense.c   **** 
 459:tactsense.c   ****     //Set the Tactile Timer to expire at 3 ms
 460:tactsense.c   ****     TACT_TC.CTRLB = TC_WGMODE_NORMAL_gc;
 427               		.loc 1 460 0
 428 01d6 E0E4      		ldi r30,lo8(2112)
 429 01d8 F8E0      		ldi r31,hi8(2112)
 430 01da 1182      		std Z+1,__zero_reg__
 461:tactsense.c   ****     TACT_TC.CTRLC = 0x00;
 431               		.loc 1 461 0
 432 01dc 1282      		std Z+2,__zero_reg__
 462:tactsense.c   ****     TACT_TC.CTRLD = TC_EVACT_OFF_gc | TC_EVSEL_OFF_gc;
 433               		.loc 1 462 0
 434 01de 1382      		std Z+3,__zero_reg__
 463:tactsense.c   ****     TACT_TC.CTRLE = 0x00;
 435               		.loc 1 463 0
 436 01e0 1482      		std Z+4,__zero_reg__
 464:tactsense.c   ****     TACT_TC.PERBUF = TACT_TIMEOUT;
 437               		.loc 1 464 0
 438 01e2 80E6      		ldi r24,lo8(96)
 439 01e4 90E0      		ldi r25,hi8(96)
 440 01e6 86AB      		std Z+54,r24
 441 01e8 97AB      		std Z+55,r25
 465:tactsense.c   ****     TACT_TC.CNT = 0x0000;
 442               		.loc 1 465 0
 443 01ea 10A2      		std Z+32,__zero_reg__
 444 01ec 11A2      		std Z+33,__zero_reg__
 466:tactsense.c   ****     TACT_TC.INTCTRLA = TC_OVFINTLVL_LO_gc;
 445               		.loc 1 466 0
 446 01ee 81E0      		ldi r24,lo8(1)
 447 01f0 8683      		std Z+6,r24
 467:tactsense.c   ****     TACT_TC.CTRLA = TC_CLKSEL_DIV1024_gc;
 448               		.loc 1 467 0
 449 01f2 2083      		st Z,r18
 450               	/* epilogue start */
 468:tactsense.c   **** 
 469:tactsense.c   ****     return;
 470:tactsense.c   **** }
 451               		.loc 1 470 0
 452 01f4 0895      		ret
 453               		.cfi_endproc
 454               	.LFE14:
 456               	.global	compensatePressure
 458               	compensatePressure:
 459               	.LFB15:
 471:tactsense.c   **** 
 472:tactsense.c   **** // typedef int16_t S16;
 473:tactsense.c   **** // typedef int32_t S32;
 474:tactsense.c   **** 
 475:tactsense.c   **** /************************************************************************
 476:tactsense.c   ****  * compensatePressure()
 477:tactsense.c   ****  *
 478:tactsense.c   ****  * This routine was pulled from Freescale app note AN3785 and modified
 479:tactsense.c   ****  * for this microprocessor.  The original code assumed two extra parameters
 480:tactsense.c   ****  * that have now been removed.
 481:tactsense.c   ****  ************************************************************************/
 482:tactsense.c   **** void compensatePressure(uint16_t tempReading, uint16_t pressureReading, uint8_t sensorIndex)
 483:tactsense.c   **** {
 460               		.loc 1 483 0
 461               		.cfi_startproc
 462               	.LVL16:
 463 01f6 EF92      		push r14
 464               	.LCFI9:
 465               		.cfi_def_cfa_offset 3
 466               		.cfi_offset 14, -2
 467 01f8 FF92      		push r15
 468               	.LCFI10:
 469               		.cfi_def_cfa_offset 4
 470               		.cfi_offset 15, -3
 471 01fa 0F93      		push r16
 472               	.LCFI11:
 473               		.cfi_def_cfa_offset 5
 474               		.cfi_offset 16, -4
 475 01fc 1F93      		push r17
 476               	.LCFI12:
 477               		.cfi_def_cfa_offset 6
 478               		.cfi_offset 17, -5
 479 01fe CF93      		push r28
 480               	.LCFI13:
 481               		.cfi_def_cfa_offset 7
 482               		.cfi_offset 28, -6
 483 0200 DF93      		push r29
 484               	.LCFI14:
 485               		.cfi_def_cfa_offset 8
 486               		.cfi_offset 29, -7
 487               	/* prologue: function */
 488               	/* frame size = 0 */
 489               	/* stack size = 6 */
 490               	.L__stack_usage = 6
 484:tactsense.c   ****     //===================================================
 485:tactsense.c   ****     //Coefficient 9 equation compensation
 486:tactsense.c   ****     //===================================================
 487:tactsense.c   ****     //
 488:tactsense.c   ****     //Variable sizes:
 489:tactsense.c   ****     //For placing high and low bytes of the Memory addresses for each of the 6 coefficients:
 490:tactsense.c   ****     //signed char (S8) sia0MSB, sia0LSB, sib1MSB,sib1LSB, sib2MSB,sib2LSB, sic12MSB,sic12LSB, sic11
 491:tactsense.c   ****     //
 492:tactsense.c   ****     //Variable for use in the compensation, this is the 6 coefficients in 16bit form, MSB+LSB.
 493:tactsense.c   ****     //signed int (S16) sia0, sib1, sib2, sic12, sic11, sic22;
 494:tactsense.c   ****     //
 495:tactsense.c   ****     //Variable used to do large calculation as 3 temp variables in the process below
 496:tactsense.c   ****     //signed long (S32) lt1, lt2, lt3;
 497:tactsense.c   ****     //
 498:tactsense.c   ****     //Variables used for Pressure and Temperature Raw.
 499:tactsense.c   ****     //unsigned int (U16) uiPadc, uiTadc.
 500:tactsense.c   ****     //signed (N=number of bits in coefficient, F-fractional bits)
 501:tactsense.c   ****     //s(N,F)
 502:tactsense.c   ****     //The below Pressure and Temp or uiPadc and uiTadc are shifted from the MSB+LSB values to remov
 503:tactsense.c   ****     // 10bit number is stored in 16 bits. i.e 0123456789XXXXXX becomes 0000000123456789
 504:tactsense.c   **** 
 505:tactsense.c   ****     // int32_t lt1,lt2,lt3;
 506:tactsense.c   ****     uint16_t pressureLocal;
 507:tactsense.c   ****     uint16_t tempLocal;
 508:tactsense.c   **** 
 509:tactsense.c   ****     // //#define S32 uint32_t
 510:tactsense.c   ****     // //#define S16 int16_t
 511:tactsense.c   **** 
 512:tactsense.c   ****     // int32_t si_a2x2,si_y1,si_a1x1,si_c12x2,si_a1;
 513:tactsense.c   **** 
 514:tactsense.c   ****     // int16_t siPcomp;
 515:tactsense.c   ****     // //float decPcomp;
 516:tactsense.c   **** 
 517:tactsense.c   ****     pressureLocal=pressureReading>>6; //Note that the PressCntdec is the raw value from the MPL115A
 491               		.loc 1 517 0
 492 0202 36E0      		ldi r19,6
 493 0204 7695      	1:	lsr r23
 494 0206 6795      		ror r22
 495 0208 3A95      		dec r19
 496 020a 01F4      		brne 1b
 497               	.LVL17:
 518:tactsense.c   ****     tempLocal=tempReading>>6; //Note that the TempCntdec is the raw value from the MPL115A data add
 498               		.loc 1 518 0
 499 020c 7C01      		movw r14,r24
 500 020e 56E0      		ldi r21,6
 501 0210 F694      	1:	lsr r15
 502 0212 E794      		ror r14
 503 0214 5A95      		dec r21
 504 0216 01F4      		brne 1b
 505               	.LVL18:
 506               	.LBB5:
 519:tactsense.c   **** 
 520:tactsense.c   ****     // since we are operating the sensor outside its normal range, it seems to behave as if it has 
 521:tactsense.c   ****     // however, its range is still 10 bits, (0-1023).  So we need to track the "actual" value of th
 522:tactsense.c   ****     {
 523:tactsense.c   ****         if (!pressureCalibrated[sensorIndex])
 507               		.loc 1 523 0
 508 0218 042F      		mov r16,r20
 509 021a 10E0      		ldi r17,lo8(0)
 510 021c D801      		movw r26,r16
 511 021e A050      		subi r26,lo8(-(pressureCalibrated))
 512 0220 B040      		sbci r27,hi8(-(pressureCalibrated))
 513 0222 2C91      		ld r18,X
 514 0224 C801      		movw r24,r16
 515               	.LVL19:
 516 0226 880F      		lsl r24
 517 0228 991F      		rol r25
 518 022a 2223      		tst r18
 519 022c 01F4      		brne .L40
 520               	.LVL20:
 524:tactsense.c   ****         {
 525:tactsense.c   ****             lastPressure[sensorIndex] = pressureLocal;
 521               		.loc 1 525 0
 522 022e FC01      		movw r30,r24
 523 0230 E050      		subi r30,lo8(-(lastPressure))
 524 0232 F040      		sbci r31,hi8(-(lastPressure))
 525 0234 6083      		st Z,r22
 526 0236 7183      		std Z+1,r23
 526:tactsense.c   ****             adjustedPressure[sensorIndex] = pressureLocal;
 527               		.loc 1 526 0
 528 0238 FC01      		movw r30,r24
 529 023a E050      		subi r30,lo8(-(adjustedPressure))
 530 023c F040      		sbci r31,hi8(-(adjustedPressure))
 531 023e 6083      		st Z,r22
 532 0240 7183      		std Z+1,r23
 527:tactsense.c   ****             pressureCalibrated[sensorIndex] = 1;
 533               		.loc 1 527 0
 534 0242 21E0      		ldi r18,lo8(1)
 535 0244 2C93      		st X,r18
 536               	.L40:
 528:tactsense.c   ****         }
 529:tactsense.c   **** 
 530:tactsense.c   ****         int16_t delta = pressureLocal - lastPressure[sensorIndex];
 537               		.loc 1 530 0
 538 0246 DC01      		movw r26,r24
 539 0248 A050      		subi r26,lo8(-(lastPressure))
 540 024a B040      		sbci r27,hi8(-(lastPressure))
 541 024c 4D91      		ld r20,X+
 542 024e 5C91      		ld r21,X
 543 0250 1197      		sbiw r26,1
 544 0252 9B01      		movw r18,r22
 545 0254 241B      		sub r18,r20
 546 0256 350B      		sbc r19,r21
 547               	.LVL21:
 531:tactsense.c   **** 
 532:tactsense.c   ****         if (abs(delta) < 512)
 548               		.loc 1 532 0
 549 0258 E901      		movw r28,r18
 550 025a C150      		subi r28,lo8(-(511))
 551 025c DE4F      		sbci r29,hi8(-(511))
 552 025e FC01      		movw r30,r24
 553 0260 E050      		subi r30,lo8(-(adjustedPressure))
 554 0262 F040      		sbci r31,hi8(-(adjustedPressure))
 555 0264 83E0      		ldi r24,hi8(1023)
 556 0266 CF3F      		cpi r28,lo8(1023)
 557 0268 D807      		cpc r29,r24
 558 026a 00F4      		brsh .L41
 533:tactsense.c   ****         {
 534:tactsense.c   ****             lastPressure[sensorIndex] = pressureLocal;
 559               		.loc 1 534 0
 560 026c 6D93      		st X+,r22
 561 026e 7C93      		st X,r23
 562 0270 1197      		sbiw r26,1
 535:tactsense.c   ****             adjustedPressure[sensorIndex] = adjustedPressure[sensorIndex] + delta;
 563               		.loc 1 535 0
 564 0272 8081      		ld r24,Z
 565 0274 9181      		ldd r25,Z+1
 566 0276 00C0      		rjmp .L43
 567               	.L41:
 568               	.LBB6:
 536:tactsense.c   ****         }
 537:tactsense.c   ****         else
 538:tactsense.c   ****         {
 539:tactsense.c   ****             int16_t bottom = lastPressure[sensorIndex] + (1024 - pressureLocal);
 569               		.loc 1 539 0
 570 0278 461B      		sub r20,r22
 571 027a 570B      		sbc r21,r23
 572 027c 4050      		subi r20,lo8(-(1024))
 573 027e 5C4F      		sbci r21,hi8(-(1024))
 574               	.LVL22:
 540:tactsense.c   ****             int16_t top = pressureLocal + (1024 - lastPressure[sensorIndex]);
 575               		.loc 1 540 0
 576 0280 2050      		subi r18,lo8(-(1024))
 577 0282 3C4F      		sbci r19,hi8(-(1024))
 578               	.LVL23:
 541:tactsense.c   ****             lastPressure[sensorIndex] = pressureLocal;
 579               		.loc 1 541 0
 580 0284 6D93      		st X+,r22
 581 0286 7C93      		st X,r23
 582 0288 1197      		sbiw r26,1
 542:tactsense.c   ****             if (bottom<top) // crossing 0
 543:tactsense.c   ****                 adjustedPressure[sensorIndex] = adjustedPressure[sensorIndex] - bottom;
 583               		.loc 1 543 0
 584 028a 8081      		ld r24,Z
 585 028c 9181      		ldd r25,Z+1
 542:tactsense.c   ****             if (bottom<top) // crossing 0
 586               		.loc 1 542 0
 587 028e 4217      		cp r20,r18
 588 0290 5307      		cpc r21,r19
 589 0292 04F4      		brge .L43
 590               	.LVL24:
 591               		.loc 1 543 0
 592 0294 841B      		sub r24,r20
 593 0296 950B      		sbc r25,r21
 594 0298 00C0      		rjmp .L44
 595               	.LVL25:
 596               	.L43:
 544:tactsense.c   ****             else // crossing 1024
 545:tactsense.c   ****                 adjustedPressure[sensorIndex] = adjustedPressure[sensorIndex] + top;
 597               		.loc 1 545 0
 598 029a 820F      		add r24,r18
 599 029c 931F      		adc r25,r19
 600               	.L44:
 601 029e 8083      		st Z,r24
 602 02a0 9183      		std Z+1,r25
 603               	.LBE6:
 604               	.LBE5:
 546:tactsense.c   ****         }
 547:tactsense.c   ****     }
 548:tactsense.c   **** 
 549:tactsense.c   ****     // /*
 550:tactsense.c   ****     // // ******* STEP 1 c11x1= c11 * Padc
 551:tactsense.c   ****     // lt1 = (S32)sic11; // s(16,27) s(N,F+zeropad) goes from s(11,10)+11ZeroPad = s(11,22) => Left
 552:tactsense.c   ****     // lt2 = (S32)pressureLocal; // u(10,0) s(N,F)
 553:tactsense.c   ****     // lt3 = lt1 * lt2; // s(26,27) /c11*Padc
 554:tactsense.c   ****     // si_c11x1 = (S32)(lt3); // s(26,27)- EQ 1 =c11x1 /checked
 555:tactsense.c   ****     // //divide this hex number by 2^30 to get the correct decimal value.
 556:tactsense.c   ****     // //b1 =s(14,11) => s(16,13) Left justified
 557:tactsense.c   ****     // */
 558:tactsense.c   **** 
 559:tactsense.c   ****     // //si_c11x1 is zero
 560:tactsense.c   **** 
 561:tactsense.c   ****     // /*
 562:tactsense.c   ****     // // ******* STEP 2 a11= b1 + c11x1
 563:tactsense.c   ****     // lt1 = ((S32)b1coeff[sensorIndex]<<14); // s(30,27) b1=s(16,13) Shift b1 so that the F matche
 564:tactsense.c   ****     // lt2 = (S32)si_c11x1; // s(26,27) //ensure fractional bits are compatible
 565:tactsense.c   ****     // lt3 = lt1 + lt2; // s(30,27) /b1+c11x1
 566:tactsense.c   ****     // si_a11 = (S32)(lt3>>14); // s(16,13) - EQ 2 =a11 Convert this block back to s(16,X)
 567:tactsense.c   ****     // */
 568:tactsense.c   **** 
 569:tactsense.c   ****     // //si_a11 is just b1
 570:tactsense.c   **** 
 571:tactsense.c   ****     // // ******* STEP 3 c12x2= c12 * Tadc
 572:tactsense.c   ****     // // sic12 is s(14,13)+9zero pad = s(16,15)+9 => s(16,24) left justified
 573:tactsense.c   ****     // lt1 = (S32)c12coeff[sensorIndex]; // s(16,24)
 574:tactsense.c   ****     // lt2 = (S32)tempLocal; // u(10,0)
 575:tactsense.c   ****     // lt3 = lt1 * lt2; // s(26,24)
 576:tactsense.c   ****     // si_c12x2 = (S32)(lt3); // s(26,24) - EQ 3 =c12x2 /checked
 577:tactsense.c   **** 
 578:tactsense.c   **** 
 579:tactsense.c   ****     // //Changed si_a11 to b1coeff
 580:tactsense.c   **** 
 581:tactsense.c   ****     // // ******* STEP 4 a1= a11 + c12x2
 582:tactsense.c   ****     // lt1 = ((S32)b1coeff[sensorIndex]<<11); // s(27,24) This is done by s(16,13) <<11 goes to s(2
 583:tactsense.c   ****     // lt2 = (S32)si_c12x2; // s(26,24)
 584:tactsense.c   ****     // lt3 = lt1 + lt2; // s(27,24) /a11+c12x2
 585:tactsense.c   ****     // si_a1 =(S32)(lt3>>11); // s(16,13) - EQ 4 =a1 /check
 586:tactsense.c   **** 
 587:tactsense.c   ****     // /*
 588:tactsense.c   ****     // // ******* STEP 5 c22x2= c22 * Tadc
 589:tactsense.c   ****     // // c22 is s(11,10)+9zero pad = s(11,19) => s(16,24) left justified
 590:tactsense.c   ****     // lt1 = (S32)sic22; // s(16,30) This is done by s(11,10) + 15 zero pad goes to s(16,15)+15, to
 591:tactsense.c   ****     // lt2 = (S32)tempLocal; // u(10,0)
 592:tactsense.c   ****     // lt3 = lt1 * lt2; // s(26,30) /c22*Tadc
 593:tactsense.c   ****     // si_c22x2 = (S32)(lt3); // s(26,30) - EQ 5 /=c22x2
 594:tactsense.c   ****     // */
 595:tactsense.c   **** 
 596:tactsense.c   ****     // //si_c22x2 is zero
 597:tactsense.c   **** 
 598:tactsense.c   ****     // /*
 599:tactsense.c   ****     // // ******* STEP 6 a2= b2 + c22x2
 600:tactsense.c   ****     // //WORKS and loses the least in data. One extra execution. Note how the 31 is really a 32 due
 601:tactsense.c   ****     // // b2 is s(16,14) User shifted left to => s(31,29) to match c22x2 F value
 602:tactsense.c   ****     // lt1 = ((S32)b2coeff[sensorIndex]<<15); //s(31,29)
 603:tactsense.c   ****     // lt2 = ((S32)si_c22x2>>1); //s(25,29) s(26,30) goes to >>16 s(10,14) to match F from sib2
 604:tactsense.c   ****     // lt3 = lt1+lt2; //s(32,29) but really is a s(31,29) due to overflow the 31 becomes a 32.
 605:tactsense.c   ****     // si_a2 = ((S32)lt3>>16); //s(16,13)
 606:tactsense.c   ****     // */
 607:tactsense.c   **** 
 608:tactsense.c   ****     // //si_a2 is b2coeff shifted right by 1 bit
 609:tactsense.c   **** 
 610:tactsense.c   ****     // // ******* STEP 7 a1x1= a1 * Padc
 611:tactsense.c   ****     // lt1 = (S32)si_a1; // s(16,13)
 612:tactsense.c   ****     // lt2 = (S32)adjustedPressure[sensorIndex];  //lt2 = (S32)pressureLocal; // u(10,0)
 613:tactsense.c   ****     // lt3 = lt1 * lt2; // s(26,13) /a1*Padc
 614:tactsense.c   ****     // si_a1x1 = (S32)(lt3); // s(26,13) - EQ 7 /=a1x1 /check
 615:tactsense.c   **** 
 616:tactsense.c   ****     // // ******* STEP 8 y1= a0 + a1x1
 617:tactsense.c   ****     // // a0 = s(16,3)
 618:tactsense.c   ****     // lt1 = ((S32)a0coeff[sensorIndex]<<10); // s(26,13) This is done since has to match a1x1 F va
 619:tactsense.c   ****     // lt2 = (S32)si_a1x1; // s(26,13)
 620:tactsense.c   ****     // lt3 = lt1 + lt2; // s(26,13) /a0+a1x1
 621:tactsense.c   ****     // si_y1 = (S32)(lt3>>10); // s(16,3) - EQ 8 /=y1 /check
 622:tactsense.c   **** 
 623:tactsense.c   ****     // //changed si_a2 to b2coeff.
 624:tactsense.c   ****     // //no other changes here
 625:tactsense.c   **** 
 626:tactsense.c   ****     // // ******* STEP 9 a2x2= a2 *Tadc
 627:tactsense.c   ****     // lt1 = (S32)b2coeff[sensorIndex]; // s(16,13)
 628:tactsense.c   ****     // lt2 = (S32)tempLocal; // u(10,0)
 629:tactsense.c   ****     // lt3 = lt1 * lt2; // s(26,13) /a2*Tadc
 630:tactsense.c   ****     // si_a2x2 = (S32)(lt3); // s(26,13) - EQ 9 /=a2x2
 631:tactsense.c   **** 
 632:tactsense.c   ****     // //Since I didn't shift b2coeff right by 1 above, si_y1 needs to be shifted left by 11 instea
 633:tactsense.c   **** 
 634:tactsense.c   ****     // // ******* STEP 10 pComp = y1 +a2x2
 635:tactsense.c   ****     // // y1= s(16,3)
 636:tactsense.c   ****     // lt1 = ((S32)si_y1<<11); // s(26,13) This is done to match a2x2 F value so addition can match
 637:tactsense.c   ****     // lt2 = (S32)si_a2x2; // s(26,13)
 638:tactsense.c   ****     // lt3 = lt1 + lt2; // s(26,13) /y1+a2x2
 639:tactsense.c   **** 
 640:tactsense.c   ****     // //The above addition has an extra F bit, so round down by 14
 641:tactsense.c   **** 
 642:tactsense.c   ****     // // FIXED POINT RESULT WITH ROUNDING:
 643:tactsense.c   ****     // siPcomp = (int16_t)(lt3>>14); //&0x3FF); // goes to no fractional parts since this is an ADC
 644:tactsense.c   ****     // //decPcomp is defined as a floating point number.
 645:tactsense.c   ****     // //Conversion to Decimal value from 1023 ADC count value. ADC counts are 0 to 1023. Pressure 
 646:tactsense.c   ****     // //decPcomp = ((65.0/1023.0)*(float)siPcomp)+50.0;
 647:tactsense.c   ****     
 648:tactsense.c   ****     pressureTempData[sensorIndex] = tempLocal;
 605               		.loc 1 648 0
 606 02a2 C801      		movw r24,r16
 607 02a4 880F      		lsl r24
 608 02a6 991F      		rol r25
 609 02a8 FC01      		movw r30,r24
 610 02aa E050      		subi r30,lo8(-(pressureTempData))
 611 02ac F040      		sbci r31,hi8(-(pressureTempData))
 612 02ae E082      		st Z,r14
 613 02b0 F182      		std Z+1,r15
 649:tactsense.c   ****     //pressureData[sensorIndex] = siPcomp - pressureDataOffset[sensorIndex];
 650:tactsense.c   ****     pressureData[sensorIndex] = adjustedPressure[sensorIndex] - pressureDataOffset[sensorIndex];
 614               		.loc 1 650 0
 615 02b2 DC01      		movw r26,r24
 616 02b4 A050      		subi r26,lo8(-(pressureData))
 617 02b6 B040      		sbci r27,hi8(-(pressureData))
 618 02b8 FC01      		movw r30,r24
 619 02ba E050      		subi r30,lo8(-(adjustedPressure))
 620 02bc F040      		sbci r31,hi8(-(adjustedPressure))
 621 02be 8050      		subi r24,lo8(-(pressureDataOffset))
 622 02c0 9040      		sbci r25,hi8(-(pressureDataOffset))
 623 02c2 2081      		ld r18,Z
 624 02c4 3181      		ldd r19,Z+1
 625 02c6 FC01      		movw r30,r24
 626 02c8 8081      		ld r24,Z
 627 02ca 9181      		ldd r25,Z+1
 628 02cc 281B      		sub r18,r24
 629 02ce 390B      		sbc r19,r25
 630 02d0 2D93      		st X+,r18
 631 02d2 3C93      		st X,r19
 632 02d4 1197      		sbiw r26,1
 633               	/* epilogue start */
 651:tactsense.c   ****     return;
 652:tactsense.c   **** }
 634               		.loc 1 652 0
 635 02d6 DF91      		pop r29
 636 02d8 CF91      		pop r28
 637               	.LVL26:
 638 02da 1F91      		pop r17
 639 02dc 0F91      		pop r16
 640               	.LVL27:
 641 02de FF90      		pop r15
 642 02e0 EF90      		pop r14
 643               	.LVL28:
 644 02e2 0895      		ret
 645               		.cfi_endproc
 646               	.LFE15:
 648               	.global	doTactSensors
 650               	doTactSensors:
 651               	.LFB13:
 333:tactsense.c   **** {
 652               		.loc 1 333 0
 653               		.cfi_startproc
 654 02e4 4F92      		push r4
 655               	.LCFI15:
 656               		.cfi_def_cfa_offset 3
 657               		.cfi_offset 4, -2
 658 02e6 5F92      		push r5
 659               	.LCFI16:
 660               		.cfi_def_cfa_offset 4
 661               		.cfi_offset 5, -3
 662 02e8 6F92      		push r6
 663               	.LCFI17:
 664               		.cfi_def_cfa_offset 5
 665               		.cfi_offset 6, -4
 666 02ea 7F92      		push r7
 667               	.LCFI18:
 668               		.cfi_def_cfa_offset 6
 669               		.cfi_offset 7, -5
 670 02ec 8F92      		push r8
 671               	.LCFI19:
 672               		.cfi_def_cfa_offset 7
 673               		.cfi_offset 8, -6
 674 02ee 9F92      		push r9
 675               	.LCFI20:
 676               		.cfi_def_cfa_offset 8
 677               		.cfi_offset 9, -7
 678 02f0 AF92      		push r10
 679               	.LCFI21:
 680               		.cfi_def_cfa_offset 9
 681               		.cfi_offset 10, -8
 682 02f2 BF92      		push r11
 683               	.LCFI22:
 684               		.cfi_def_cfa_offset 10
 685               		.cfi_offset 11, -9
 686 02f4 CF92      		push r12
 687               	.LCFI23:
 688               		.cfi_def_cfa_offset 11
 689               		.cfi_offset 12, -10
 690 02f6 DF92      		push r13
 691               	.LCFI24:
 692               		.cfi_def_cfa_offset 12
 693               		.cfi_offset 13, -11
 694 02f8 EF92      		push r14
 695               	.LCFI25:
 696               		.cfi_def_cfa_offset 13
 697               		.cfi_offset 14, -12
 698 02fa FF92      		push r15
 699               	.LCFI26:
 700               		.cfi_def_cfa_offset 14
 701               		.cfi_offset 15, -13
 702 02fc 0F93      		push r16
 703               	.LCFI27:
 704               		.cfi_def_cfa_offset 15
 705               		.cfi_offset 16, -14
 706 02fe 1F93      		push r17
 707               	.LCFI28:
 708               		.cfi_def_cfa_offset 16
 709               		.cfi_offset 17, -15
 710 0300 CF93      		push r28
 711               	.LCFI29:
 712               		.cfi_def_cfa_offset 17
 713               		.cfi_offset 28, -16
 714 0302 DF93      		push r29
 715               	.LCFI30:
 716               		.cfi_def_cfa_offset 18
 717               		.cfi_offset 29, -17
 718 0304 CDB7      		in r28,__SP_L__
 719 0306 DEB7      		in r29,__SP_H__
 720 0308 2997      		sbiw r28,9
 721               	.LCFI31:
 722               		.cfi_def_cfa 28, 27
 723 030a CDBF      		out __SP_L__,r28
 724 030c DEBF      		out __SP_H__,r29
 725               	/* prologue: function */
 726               	/* frame size = 9 */
 727               	/* stack size = 25 */
 728               	.L__stack_usage = 25
 337:tactsense.c   ****     PORTE.OUTSET = 0xFF;
 729               		.loc 1 337 0
 730 030e 8FEF      		ldi r24,lo8(-1)
 731 0310 E0E8      		ldi r30,lo8(1664)
 732 0312 F6E0      		ldi r31,hi8(1664)
 733 0314 8583      		std Z+5,r24
 338:tactsense.c   ****     PORTD.OUTSET = 0x18;
 734               		.loc 1 338 0
 735 0316 E0E6      		ldi r30,lo8(1632)
 736 0318 F6E0      		ldi r31,hi8(1632)
 737 031a 88E1      		ldi r24,lo8(24)
 738 031c 8583      		std Z+5,r24
 341:tactsense.c   ****     PORTD.OUTCLR = TACT_ADDR_MASK;
 739               		.loc 1 341 0
 740 031e 87E0      		ldi r24,lo8(7)
 741 0320 8683      		std Z+6,r24
 343:tactsense.c   ****     if(activeSensor == 24)
 742               		.loc 1 343 0
 743 0322 1091 0000 		lds r17,activeSensor
 744 0326 1831      		cpi r17,lo8(24)
 745 0328 01F0      		breq .+2
 746 032a 00C0      		rjmp .L46
 346:tactsense.c   ****         cli();
 747               		.loc 1 346 0
 748               	/* #APP */
 749               	 ;  346 "tactsense.c" 1
 750 032c F894      		cli
 751               	 ;  0 "" 2
 347:tactsense.c   ****         tactReady = 0;
 752               		.loc 1 347 0
 753               	/* #NOAPP */
 754 032e 1092 0000 		sts tactReady,__zero_reg__
 348:tactsense.c   ****         sei();
 755               		.loc 1 348 0
 756               	/* #APP */
 757               	 ;  348 "tactsense.c" 1
 758 0332 7894      		sei
 759               	 ;  0 "" 2
 760               	.LVL29:
 349:tactsense.c   ****         for(i=0;i<24;i++)
 761               		.loc 1 349 0
 762               	/* #NOAPP */
 763 0334 90E0      		ldi r25,lo8(0)
 764               	.LBB11:
 765               	.LBB12:
 301:tactsense.c   ****     SPI0.DATA = CONVERT_OPCODE;
 766               		.loc 1 301 0
 767 0336 00EC      		ldi r16,lo8(2240)
 768 0338 18E0      		ldi r17,hi8(2240)
 769 033a F4E2      		ldi r31,lo8(36)
 770 033c DF2E      		mov r13,r31
 302:tactsense.c   ****     SPI1.DATA = CONVERT_OPCODE;
 771               		.loc 1 302 0
 772 033e A0EC      		ldi r26,lo8(2496)
 773 0340 8A2E      		mov r8,r26
 774 0342 A9E0      		ldi r26,hi8(2496)
 775 0344 9A2E      		mov r9,r26
 305:tactsense.c   ****     while(!(SPI1.STATUS & SPI_IF_bm));
 776               		.loc 1 305 0
 777 0346 B0EC      		ldi r27,lo8(2496)
 778 0348 6B2E      		mov r6,r27
 779 034a B9E0      		ldi r27,hi8(2496)
 780 034c 7B2E      		mov r7,r27
 323:tactsense.c   ****     PORTE.OUTSET = 0xFF;
 781               		.loc 1 323 0
 782 034e 80E8      		ldi r24,lo8(1664)
 783 0350 482E      		mov r4,r24
 784 0352 86E0      		ldi r24,hi8(1664)
 785 0354 582E      		mov r5,r24
 786 0356 BB24      		clr r11
 787 0358 BA94      		dec r11
 324:tactsense.c   ****     PORTD.OUTSET = 0x18;
 788               		.loc 1 324 0
 789 035a 20E6      		ldi r18,lo8(1632)
 790 035c E22E      		mov r14,r18
 791 035e 26E0      		ldi r18,hi8(1632)
 792 0360 F22E      		mov r15,r18
 793 0362 38E1      		ldi r19,lo8(24)
 794 0364 C32E      		mov r12,r19
 325:tactsense.c   ****     PORTD.OUTCLR = TACT_ADDR_MASK;
 795               		.loc 1 325 0
 796 0366 47E0      		ldi r20,lo8(7)
 797 0368 A42E      		mov r10,r20
 798               	.LVL30:
 799               	.L51:
 298:tactsense.c   ****     selectSensorPair(tactAddress);
 800               		.loc 1 298 0
 801 036a 892F      		mov r24,r25
 802 036c 9987      		std Y+9,r25
 803 036e 0E94 0000 		call selectSensorPair
 804               	.LVL31:
 301:tactsense.c   ****     SPI0.DATA = CONVERT_OPCODE;
 805               		.loc 1 301 0
 806 0372 F801      		movw r30,r16
 807 0374 D382      		std Z+3,r13
 302:tactsense.c   ****     SPI1.DATA = CONVERT_OPCODE;
 808               		.loc 1 302 0
 809 0376 F401      		movw r30,r8
 810 0378 D382      		std Z+3,r13
 811 037a 9985      		ldd r25,Y+9
 812               	.L47:
 304:tactsense.c   ****     while(!(SPI0.STATUS & SPI_IF_bm));
 813               		.loc 1 304 0
 814 037c 8091 C208 		lds r24,2242
 815 0380 87FF      		sbrs r24,7
 816 0382 00C0      		rjmp .L47
 817               	.L58:
 305:tactsense.c   ****     while(!(SPI1.STATUS & SPI_IF_bm));
 818               		.loc 1 305 0
 819 0384 8091 C209 		lds r24,2498
 820 0388 87FF      		sbrs r24,7
 821 038a 00C0      		rjmp .L58
 308:tactsense.c   ****     dummyRead = SPI0.DATA;
 822               		.loc 1 308 0
 823 038c 8091 C308 		lds r24,2243
 309:tactsense.c   ****     dummyRead = SPI1.DATA;
 824               		.loc 1 309 0
 825 0390 8091 C309 		lds r24,2499
 312:tactsense.c   ****     SPI0.DATA = 0x00;
 826               		.loc 1 312 0
 827 0394 F801      		movw r30,r16
 828 0396 1382      		std Z+3,__zero_reg__
 313:tactsense.c   ****     SPI1.DATA = 0x00;
 829               		.loc 1 313 0
 830 0398 F301      		movw r30,r6
 831 039a 1382      		std Z+3,__zero_reg__
 832               	.L49:
 315:tactsense.c   ****     while(!(SPI0.STATUS & SPI_IF_bm));
 833               		.loc 1 315 0
 834 039c 8091 C208 		lds r24,2242
 835 03a0 87FF      		sbrs r24,7
 836 03a2 00C0      		rjmp .L49
 837               	.L57:
 316:tactsense.c   ****     while(!(SPI1.STATUS & SPI_IF_bm));
 838               		.loc 1 316 0
 839 03a4 8091 C209 		lds r24,2498
 840 03a8 87FF      		sbrs r24,7
 841 03aa 00C0      		rjmp .L57
 319:tactsense.c   ****     dummyRead = SPI0.DATA;
 842               		.loc 1 319 0
 843 03ac 8091 C308 		lds r24,2243
 320:tactsense.c   ****     dummyRead = SPI1.DATA;
 844               		.loc 1 320 0
 845 03b0 8091 C309 		lds r24,2499
 323:tactsense.c   ****     PORTE.OUTSET = 0xFF;
 846               		.loc 1 323 0
 847 03b4 F201      		movw r30,r4
 848 03b6 B582      		std Z+5,r11
 324:tactsense.c   ****     PORTD.OUTSET = 0x18;
 849               		.loc 1 324 0
 850 03b8 F701      		movw r30,r14
 851 03ba C582      		std Z+5,r12
 325:tactsense.c   ****     PORTD.OUTCLR = TACT_ADDR_MASK;
 852               		.loc 1 325 0
 853 03bc A682      		std Z+6,r10
 854               	.LBE12:
 855               	.LBE11:
 349:tactsense.c   ****         for(i=0;i<24;i++)
 856               		.loc 1 349 0
 857 03be 9F5F      		subi r25,lo8(-(1))
 858               	.LVL32:
 859 03c0 9831      		cpi r25,lo8(24)
 860 03c2 01F4      		brne .L51
 354:tactsense.c   ****         TACT_TC.CTRLB = TC_WGMODE_NORMAL_gc;
 861               		.loc 1 354 0
 862 03c4 E0E4      		ldi r30,lo8(2112)
 863 03c6 F8E0      		ldi r31,hi8(2112)
 864 03c8 1182      		std Z+1,__zero_reg__
 355:tactsense.c   ****         TACT_TC.CTRLC = 0x00;
 865               		.loc 1 355 0
 866 03ca 1282      		std Z+2,__zero_reg__
 356:tactsense.c   ****         TACT_TC.CTRLD = TC_EVACT_OFF_gc | TC_EVSEL_OFF_gc;
 867               		.loc 1 356 0
 868 03cc 1382      		std Z+3,__zero_reg__
 357:tactsense.c   ****         TACT_TC.CTRLE = 0x00;
 869               		.loc 1 357 0
 870 03ce 1482      		std Z+4,__zero_reg__
 358:tactsense.c   ****         TACT_TC.PERBUF = TACT_TIMEOUT;
 871               		.loc 1 358 0
 872 03d0 80E6      		ldi r24,lo8(96)
 873 03d2 90E0      		ldi r25,hi8(96)
 874 03d4 86AB      		std Z+54,r24
 875 03d6 97AB      		std Z+55,r25
 359:tactsense.c   ****         TACT_TC.CNT = 0x0000;
 876               		.loc 1 359 0
 877 03d8 10A2      		std Z+32,__zero_reg__
 878 03da 11A2      		std Z+33,__zero_reg__
 360:tactsense.c   ****         TACT_TC.INTCTRLA = TC_OVFINTLVL_LO_gc;
 879               		.loc 1 360 0
 880 03dc 81E0      		ldi r24,lo8(1)
 881 03de 8683      		std Z+6,r24
 361:tactsense.c   ****         TACT_TC.CTRLA = TC_CLKSEL_DIV1024_gc;
 882               		.loc 1 361 0
 883 03e0 87E0      		ldi r24,lo8(7)
 884 03e2 8093 4008 		sts 2112,r24
 362:tactsense.c   ****         activeSensor = 0;
 885               		.loc 1 362 0
 886 03e6 1092 0000 		sts activeSensor,__zero_reg__
 363:tactsense.c   ****         return;
 887               		.loc 1 363 0
 888 03ea 00C0      		rjmp .L45
 889               	.LVL33:
 890               	.L46:
 891               	.LBB13:
 892               	.LBB14:
 193:tactsense.c   ****     selectSensorPair(tactAddress);
 893               		.loc 1 193 0
 894 03ec 812F      		mov r24,r17
 895 03ee 0E94 0000 		call selectSensorPair
 195:tactsense.c   ****     getDoubleWord(READ_PRESSURE_MSB_OPCODE,&firstPressureReading,&secondPressureReading);
 896               		.loc 1 195 0
 897 03f2 80E8      		ldi r24,lo8(-128)
 898 03f4 BE01      		movw r22,r28
 899 03f6 695F      		subi r22,lo8(-(7))
 900 03f8 7F4F      		sbci r23,hi8(-(7))
 901 03fa AE01      		movw r20,r28
 902 03fc 4B5F      		subi r20,lo8(-(5))
 903 03fe 5F4F      		sbci r21,hi8(-(5))
 904 0400 0E94 0000 		call getDoubleWord
 197:tactsense.c   ****     getDoubleWord(READ_TEMPERATURE_MSB_OPCODE,&firstTempReading,&secondTempReading);
 905               		.loc 1 197 0
 906 0404 84E8      		ldi r24,lo8(-124)
 907 0406 BE01      		movw r22,r28
 908 0408 6D5F      		subi r22,lo8(-(3))
 909 040a 7F4F      		sbci r23,hi8(-(3))
 910 040c AE01      		movw r20,r28
 911 040e 4F5F      		subi r20,lo8(-(1))
 912 0410 5F4F      		sbci r21,hi8(-(1))
 913 0412 0E94 0000 		call getDoubleWord
 202:tactsense.c   ****     SPI0.DATA = 0x00;
 914               		.loc 1 202 0
 915 0416 E0EC      		ldi r30,lo8(2240)
 916 0418 F8E0      		ldi r31,hi8(2240)
 917 041a 1382      		std Z+3,__zero_reg__
 203:tactsense.c   ****     SPI1.DATA = 0x00;
 918               		.loc 1 203 0
 919 041c E0EC      		ldi r30,lo8(2496)
 920 041e F9E0      		ldi r31,hi8(2496)
 921 0420 1382      		std Z+3,__zero_reg__
 922               	.L53:
 205:tactsense.c   ****     while(!(SPI0.STATUS & SPI_IF_bm));
 923               		.loc 1 205 0
 924 0422 8091 C208 		lds r24,2242
 925 0426 87FF      		sbrs r24,7
 926 0428 00C0      		rjmp .L53
 927               	.L59:
 206:tactsense.c   ****     while(!(SPI1.STATUS & SPI_IF_bm));
 928               		.loc 1 206 0
 929 042a 8091 C209 		lds r24,2498
 930 042e 87FF      		sbrs r24,7
 931 0430 00C0      		rjmp .L59
 209:tactsense.c   ****     dummyRead = SPI0.DATA;
 932               		.loc 1 209 0
 933 0432 8091 C308 		lds r24,2243
 210:tactsense.c   ****     dummyRead = SPI1.DATA;
 934               		.loc 1 210 0
 935 0436 8091 C309 		lds r24,2499
 213:tactsense.c   ****     PORTE.OUTSET = 0xFF;
 936               		.loc 1 213 0
 937 043a 8FEF      		ldi r24,lo8(-1)
 938 043c E0E8      		ldi r30,lo8(1664)
 939 043e F6E0      		ldi r31,hi8(1664)
 940 0440 8583      		std Z+5,r24
 214:tactsense.c   ****     PORTD.OUTSET = 0x18;
 941               		.loc 1 214 0
 942 0442 E0E6      		ldi r30,lo8(1632)
 943 0444 F6E0      		ldi r31,hi8(1632)
 944 0446 88E1      		ldi r24,lo8(24)
 945 0448 8583      		std Z+5,r24
 215:tactsense.c   ****     PORTD.OUTCLR = TACT_ADDR_MASK;
 946               		.loc 1 215 0
 947 044a 87E0      		ldi r24,lo8(7)
 948 044c 8683      		std Z+6,r24
 949               	.LVL34:
 218:tactsense.c   ****     if (firstPressureReading != 0)
 950               		.loc 1 218 0
 951 044e 6F81      		ldd r22,Y+7
 952 0450 7885      		ldd r23,Y+8
 953 0452 6115      		cp r22,__zero_reg__
 954 0454 7105      		cpc r23,__zero_reg__
 955 0456 01F0      		breq .L55
 956               	.LVL35:
 221:tactsense.c   ****         compensatePressure(firstTempReading, firstPressureReading, tactAddress);
 957               		.loc 1 221 0
 958 0458 8B81      		ldd r24,Y+3
 959 045a 9C81      		ldd r25,Y+4
 960 045c 412F      		mov r20,r17
 961 045e 0E94 0000 		call compensatePressure
 962               	.L55:
 963               	.LVL36:
 227:tactsense.c   ****     if (secondPressureReading != 0)
 964               		.loc 1 227 0
 965 0462 6D81      		ldd r22,Y+5
 966 0464 7E81      		ldd r23,Y+6
 967 0466 6115      		cp r22,__zero_reg__
 968 0468 7105      		cpc r23,__zero_reg__
 969 046a 01F0      		breq .L56
 230:tactsense.c   ****         compensatePressure(secondTempReading, secondPressureReading, tactAddress+24);
 970               		.loc 1 230 0
 971 046c 412F      		mov r20,r17
 972 046e 485E      		subi r20,lo8(-(24))
 973               	.LVL37:
 974 0470 8981      		ldd r24,Y+1
 975 0472 9A81      		ldd r25,Y+2
 976 0474 0E94 0000 		call compensatePressure
 977               	.L56:
 978               	.LBE14:
 979               	.LBE13:
 368:tactsense.c   ****     activeSensor++;
 980               		.loc 1 368 0
 981 0478 8091 0000 		lds r24,activeSensor
 982 047c 8F5F      		subi r24,lo8(-(1))
 983 047e 8093 0000 		sts activeSensor,r24
 984               	.LVL38:
 985               	.L45:
 986               	/* epilogue start */
 370:tactsense.c   **** }
 987               		.loc 1 370 0
 988 0482 2996      		adiw r28,9
 989 0484 CDBF      		out __SP_L__,r28
 990 0486 DEBF      		out __SP_H__,r29
 991 0488 DF91      		pop r29
 992 048a CF91      		pop r28
 993 048c 1F91      		pop r17
 994 048e 0F91      		pop r16
 995 0490 FF90      		pop r15
 996 0492 EF90      		pop r14
 997 0494 DF90      		pop r13
 998 0496 CF90      		pop r12
 999 0498 BF90      		pop r11
 1000 049a AF90      		pop r10
 1001 049c 9F90      		pop r9
 1002 049e 8F90      		pop r8
 1003 04a0 7F90      		pop r7
 1004 04a2 6F90      		pop r6
 1005 04a4 5F90      		pop r5
 1006 04a6 4F90      		pop r4
 1007 04a8 0895      		ret
 1008               		.cfi_endproc
 1009               	.LFE13:
 1011               	.global	activeSensor
 1012               	.global	activeSensor
 1013               		.section .bss
 1016               	activeSensor:
 1017 0000 00        		.skip 1,0
 1018               	.global	tactReady
 1019               	.global	tactReady
 1022               	tactReady:
 1023 0001 00        		.skip 1,0
 1024               		.comm adjustedPressure,96,1
 1025               		.comm lastPressure,96,1
 1026               		.comm pressureCalibrated,48,1
 1027               		.comm pressureTempData,96,1
 1028               		.comm pressureDataOffset,96,1
 1029               		.comm pressureData,96,1
 1030               		.text
 1031               	.Letext0:
 1032               		.file 2 "/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../av
 1033               		.file 3 "/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../av
 1034               		.file 4 "tactsense.h"
DEFINED SYMBOLS
                            *ABS*:00000000 tactsense.c
     /tmp/ccrfx183.s:2      *ABS*:0000003f __SREG__
     /tmp/ccrfx183.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccrfx183.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccrfx183.s:5      *ABS*:00000034 __CCP__
     /tmp/ccrfx183.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccrfx183.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccrfx183.s:14     .text:00000000 getDoubleWord
     /tmp/ccrfx183.s:176    .text:000000dc selectSensorPair
     /tmp/ccrfx183.s:252    .text:00000136 __vector_20
     /tmp/ccrfx183.s:1022   .bss:00000001 tactReady
     /tmp/ccrfx183.s:293    .text:00000158 configureSPIModules
     /tmp/ccrfx183.s:322    .text:0000016c initTactileModule
                            *COM*:00000030 pressureCalibrated
                            *COM*:00000060 pressureData
                            *COM*:00000060 pressureDataOffset
                            *COM*:00000060 pressureTempData
                            *COM*:00000060 lastPressure
                            *COM*:00000060 adjustedPressure
     /tmp/ccrfx183.s:405    .text:000001c2 collectAllCalibrationValues
     /tmp/ccrfx183.s:458    .text:000001f6 compensatePressure
     /tmp/ccrfx183.s:650    .text:000002e4 doTactSensors
     /tmp/ccrfx183.s:1016   .bss:00000000 activeSensor

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
