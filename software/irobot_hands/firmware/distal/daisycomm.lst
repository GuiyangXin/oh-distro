   1               		.file	"daisycomm.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  14               	prepareDMAChannel.constprop.0:
  15               	.LFB17:
  16               		.file 1 "daisycomm.c"
   1:daisycomm.c   **** /****************************************************
   2:daisycomm.c   **** 
   3:daisycomm.c   ****  // Author:            Zachary Clifford
   4:daisycomm.c   ****  // File Name:        C1482-SRC-COMMON-0-daisycomm.c
   5:daisycomm.c   ****  // Creation Date:    22 February, 2012
   6:daisycomm.c   ****  // Revision:        00
   7:daisycomm.c   ****  // Hardware:        ATxmega32A4U
   8:daisycomm.c   ****  // Description:    Common routines for daisy chaining
   9:daisycomm.c   **** 
  10:daisycomm.c   **** ****************************************************/
  11:daisycomm.c   **** 
  12:daisycomm.c   **** /******************************************************************************
  13:daisycomm.c   ****     File Revision History:
  14:daisycomm.c   **** -------------------------------------------------------------------------------
  15:daisycomm.c   **** Revision    Date        Engineer    Description
  16:daisycomm.c   **** --------    --------    --------    -------------------------------------------
  17:daisycomm.c   **** 00            MM/DD/YY    ZAC            Initial Release
  18:daisycomm.c   **** -------------------------------------------------------------------------------
  19:daisycomm.c   **** 
  20:daisycomm.c   **** ******************************************************************************/
  21:daisycomm.c   **** 
  22:daisycomm.c   **** /************************************************************************
  23:daisycomm.c   ****  * This module operates the Daisy Chain protocol in the ARM-H system.
  24:daisycomm.c   ****  * It assumes DMA transfers will be used on a half-duplex downstream
  25:daisycomm.c   ****  * and half-duplex upstream link to move data between various devices in
  26:daisycomm.c   ****  * the system.  Configuration must be provided in the file
  27:daisycomm.c   ****  * C1482-SRC-COMMON-0-daisyconfig.h for each project using this module.
  28:daisycomm.c   ****  *
  29:daisycomm.c   ****  * Data arrives on an interrupt-driven transfer to determine the number of additional
  30:daisycomm.c   ****  * bytes to arrive.  A DMA transfer then captures the remaining bytes of payload.
  31:daisycomm.c   ****  ************************************************************************/
  32:daisycomm.c   **** 
  33:daisycomm.c   **** #include <avr/io.h>
  34:daisycomm.c   **** #include <avr/interrupt.h>
  35:daisycomm.c   **** #include <string.h>
  36:daisycomm.c   **** 
  37:daisycomm.c   **** #define F_CPU 32000000L
  38:daisycomm.c   **** #include <util/delay.h>
  39:daisycomm.c   **** 
  40:daisycomm.c   **** #include "distal.h"
  41:daisycomm.c   **** #include "../common/daisycomm.h"
  42:daisycomm.c   **** #include "daisyconfig.h"
  43:daisycomm.c   **** 
  44:daisycomm.c   **** void LEDtoggle(void); // function in finger.c
  45:daisycomm.c   **** 
  46:daisycomm.c   **** //#define DELAY_ROUTINE() asm("nop")
  47:daisycomm.c   **** #define DELAY_ROUTINE() _delay_us(6); //enough for a full character
  48:daisycomm.c   **** //#define DELAY_ROUTINE() _delay_us(10);
  49:daisycomm.c   **** 
  50:daisycomm.c   **** typedef enum SERIAL_STREAM_enum
  51:daisycomm.c   **** {
  52:daisycomm.c   ****     DOWNSTREAM,
  53:daisycomm.c   ****     UPSTREAM
  54:daisycomm.c   **** } SERIAL_STREAM_t;
  55:daisycomm.c   **** 
  56:daisycomm.c   **** typedef enum SERIAL_DIRECTION_enum
  57:daisycomm.c   **** {
  58:daisycomm.c   ****     INBOUND,
  59:daisycomm.c   ****     OUTBOUND
  60:daisycomm.c   **** } SERIAL_DIRECTION_t;
  61:daisycomm.c   **** 
  62:daisycomm.c   **** typedef enum DAISY_STATE_enum
  63:daisycomm.c   **** {
  64:daisycomm.c   ****     DAISY_IDLE,
  65:daisycomm.c   ****     DAISY_TRANSMITTING
  66:daisycomm.c   **** } DAISY_STATE_t;
  67:daisycomm.c   **** 
  68:daisycomm.c   **** volatile uint8_t notifyDaisy = 0;
  69:daisycomm.c   **** 
  70:daisycomm.c   **** static volatile uint8_t inbound_upstream_data[COMMAND_PACKET_SIZE];
  71:daisycomm.c   **** static volatile uint8_t outbound_upstream_data[MAX_PACKET_SIZE];
  72:daisycomm.c   **** 
  73:daisycomm.c   **** 
  74:daisycomm.c   **** static volatile SERIAL_DIRECTION_t UPSTREAM_CONFIG = INBOUND;
  75:daisycomm.c   **** 
  76:daisycomm.c   **** static volatile int upstreamRxDone = 0;
  77:daisycomm.c   **** static volatile int upstreamTxDone = 0;
  78:daisycomm.c   **** static volatile uint8_t upstreamBusy = 0;
  79:daisycomm.c   **** uint16_t RxCheckSumErrCnt[2] = {0, 0};
  80:daisycomm.c   **** 
  81:daisycomm.c   **** 
  82:daisycomm.c   **** static void configureUSARTHardware(USART_t *targetUSART, int isPC, int isDownstream);
  83:daisycomm.c   **** static void prepareDMAChannel(DMA_CH_t *targetChannel, uint8_t usartTrigger, USART_t *targetUSART, 
  84:daisycomm.c   **** static void activateDMAChannel(DMA_CH_t *targetChannel,int numBytes);
  85:daisycomm.c   **** static void configureHalfDuplexLink(SERIAL_STREAM_t selectedStream, SERIAL_DIRECTION_t selectedDire
  86:daisycomm.c   **** 
  87:daisycomm.c   **** 
  88:daisycomm.c   **** ISR(DAISY_TC_vect)
  89:daisycomm.c   **** {
  90:daisycomm.c   ****     //Check if the DMA is busy and waiting on incoming data
  91:daisycomm.c   ****     if(UPSTREAM_CONFIG == OUTBOUND)
  92:daisycomm.c   ****     {
  93:daisycomm.c   ****         //No need to reset DMA
  94:daisycomm.c   ****         upstreamBusy = 0;
  95:daisycomm.c   ****     }
  96:daisycomm.c   ****     else
  97:daisycomm.c   ****     {
  98:daisycomm.c   ****         if((UPSTREAM_DMA.CTRLB & DMA_CH_CHBUSY_bm) || !(UPSTREAM_DMA.CTRLA & DMA_CH_ENABLE_bm))
  99:daisycomm.c   ****         {
 100:daisycomm.c   ****             upstreamBusy++;
 101:daisycomm.c   ****         }
 102:daisycomm.c   **** 
 103:daisycomm.c   ****         if(upstreamBusy > 2)
 104:daisycomm.c   ****         {
 105:daisycomm.c   ****             //Cancel and rearm the incoming DMA
 106:daisycomm.c   ****             UPSTREAM_DMA.CTRLA = 0x00;
 107:daisycomm.c   ****             //Wait for it to disable
 108:daisycomm.c   ****             while(UPSTREAM_DMA.CTRLA & DMA_CH_ENABLE_bm);
 109:daisycomm.c   **** 
 110:daisycomm.c   ****             //Issue a reset
 111:daisycomm.c   ****             UPSTREAM_DMA.CTRLA = DMA_CH_RESET_bm;
 112:daisycomm.c   **** 
 113:daisycomm.c   ****             //Re-arm
 114:daisycomm.c   ****             prepareDMAChannel(&UPSTREAM_DMA, UPSTREAM_DIST_USART_INBOUND_TRIGGER, &UPSTREAM_DIST_US
 115:daisycomm.c   ****             activateDMAChannel(&UPSTREAM_DMA,COMMAND_PACKET_SIZE);
 116:daisycomm.c   ****         }
 117:daisycomm.c   ****     }
 118:daisycomm.c   **** }
 119:daisycomm.c   **** 
 120:daisycomm.c   **** /************************************************************************
 121:daisycomm.c   ****  * ISRs for the DMA engines.
 122:daisycomm.c   ****  * Set flags for the Daisy Chain Task
 123:daisycomm.c   ****  ************************************************************************/
 124:daisycomm.c   **** ISR(UPSTREAM_DMA_vect)
 125:daisycomm.c   **** {
 126:daisycomm.c   ****     //LEDtoggle();
 127:daisycomm.c   ****     
 128:daisycomm.c   ****     if(UPSTREAM_DMA.CTRLB & DMA_CH_ERRIF_bm)
 129:daisycomm.c   ****     {
 130:daisycomm.c   ****         //Acknowledge the error
 131:daisycomm.c   ****         //It may be from an aborted transfer, so just return.  Re-arm the DMA
 132:daisycomm.c   ****         //UPSTREAM_DMA.CTRLB = UPSTREAM_DMA.CTRLB | DMA_CH_ERRIF_bm;
 133:daisycomm.c   ****         //Cancel and rearm the incoming DMA
 134:daisycomm.c   ****         return;
 135:daisycomm.c   ****     }
 136:daisycomm.c   **** 
 137:daisycomm.c   ****     if(UPSTREAM_DMA.CTRLB & DMA_CH_TRNIF_bm)
 138:daisycomm.c   ****     {
 139:daisycomm.c   ****         //The transfer is complete and should be acked
 140:daisycomm.c   ****         UPSTREAM_DMA.CTRLB = UPSTREAM_DMA.CTRLB | DMA_CH_TRNIF_bm;
 141:daisycomm.c   ****         upstreamBusy = 0;
 142:daisycomm.c   ****         notifyDaisy = 1;
 143:daisycomm.c   ****         upstreamRxDone = 1;
 144:daisycomm.c   ****     }
 145:daisycomm.c   **** }
 146:daisycomm.c   **** 
 147:daisycomm.c   **** /*
 148:daisycomm.c   **** ISR(UPSTREAM_PROX_USART_TXDONE_vect)
 149:daisycomm.c   **** {
 150:daisycomm.c   ****     upstreamBusy = 0;
 151:daisycomm.c   ****     notifyDaisy = 1;
 152:daisycomm.c   ****     upstreamTxDone = 1;
 153:daisycomm.c   ****     UPSTREAM_PROX_USART.CTRLA = USART_TXCINTLVL_OFF_gc | USART_RXCINTLVL_OFF_gc;
 154:daisycomm.c   ****     UPSTREAM_PROX_USART.STATUS = USART_TXCIF_bm;
 155:daisycomm.c   **** }
 156:daisycomm.c   **** */
 157:daisycomm.c   **** 
 158:daisycomm.c   **** ISR(UPSTREAM_DIST_USART_TXDONE_vect)
 159:daisycomm.c   **** {
 160:daisycomm.c   ****     upstreamBusy = 0;
 161:daisycomm.c   ****     notifyDaisy = 1;
 162:daisycomm.c   ****     upstreamTxDone = 1;
 163:daisycomm.c   ****     UPSTREAM_DIST_USART.CTRLA = USART_TXCINTLVL_OFF_gc | USART_RXCINTLVL_OFF_gc;
 164:daisycomm.c   ****     UPSTREAM_DIST_USART.STATUS = USART_TXCIF_bm;
 165:daisycomm.c   **** }
 166:daisycomm.c   **** 
 167:daisycomm.c   **** 
 168:daisycomm.c   **** 
 169:daisycomm.c   **** 
 170:daisycomm.c   **** /************************************************************************
 171:daisycomm.c   **** * configureUSART(targetUSART, isPC, useDMA):
 172:daisycomm.c   **** * Responsible for configuring the USART module.
 173:daisycomm.c   **** *
 174:daisycomm.c   **** * targetUSART is a pointer to the USART_t struct to be configured
 175:daisycomm.c   **** * when isPC is 1, set to communicate at 115200 baud
 176:daisycomm.c   **** * using 8 data bits, 1 stop bit.
 177:daisycomm.c   **** *
 178:daisycomm.c   **** * When isPC is 0, set to communicate at 2 MBaud
 179:daisycomm.c   **** * using 8 data bits, 1 stop bit.
 180:daisycomm.c   **** *
 181:daisycomm.c   **** ************************************************************************/
 182:daisycomm.c   **** static void configureUSARTHardware(USART_t *targetUSART, int isPC, int isDownstream)
 183:daisycomm.c   **** {
 184:daisycomm.c   ****     if(isDownstream)
 185:daisycomm.c   ****     {
 186:daisycomm.c   ****         targetUSART->CTRLA = USART_RXCINTLVL_LO_gc;            //Enable RX interrupt at LO priority
 187:daisycomm.c   ****     }
 188:daisycomm.c   **** 
 189:daisycomm.c   **** 
 190:daisycomm.c   ****     if(isPC)
 191:daisycomm.c   ****     {
 192:daisycomm.c   ****         //COMMAND_USART.BAUDCTRLA = 34;                            //Configure for 57600 baud rate 
 193:daisycomm.c   ****         //COMMAND_USART.BAUDCTRLB = 0;
 194:daisycomm.c   ****         targetUSART->BAUDCTRLA = 33;                            //Configure for 115200 with fractio
 195:daisycomm.c   ****         targetUSART->BAUDCTRLB = 0xF0;
 196:daisycomm.c   ****     } else {
 197:daisycomm.c   ****         targetUSART->BAUDCTRLA = 0;                                //Configure for 2 MBaud by setti
 198:daisycomm.c   ****         targetUSART->BAUDCTRLB = 0x00;                            //and BSEL to zero
 199:daisycomm.c   ****     }
 200:daisycomm.c   ****     targetUSART->CTRLC = USART_CMODE_ASYNCHRONOUS_gc | \
 201:daisycomm.c   ****                          USART_PMODE_DISABLED_gc | \
 202:daisycomm.c   ****                           USART_CHSIZE_8BIT_gc;                //Configure port settings for 8 bits
 203:daisycomm.c   ****     targetUSART->CTRLB |= USART_RXEN_bm | USART_TXEN_bm;    //enable RX and TX
 204:daisycomm.c   ****     return;
 205:daisycomm.c   **** }
 206:daisycomm.c   **** 
 207:daisycomm.c   **** /************************************************************************
 208:daisycomm.c   ****  * configureHalfDuplexLink(selectedStream,selectedDirection)
 209:daisycomm.c   ****  *
 210:daisycomm.c   ****  * Configures hardware and DMA channels to support the requested stream configuration
 211:daisycomm.c   ****  ************************************************************************/
 212:daisycomm.c   **** 
 213:daisycomm.c   **** static void configureHalfDuplexLink(SERIAL_STREAM_t selectedStream, SERIAL_DIRECTION_t selectedDire
 214:daisycomm.c   **** {
 215:daisycomm.c   ****     cli();
 216:daisycomm.c   ****     switch(selectedStream)
 217:daisycomm.c   ****     {
 218:daisycomm.c   ****         case UPSTREAM:
 219:daisycomm.c   ****             //Abort any pending DMA transfers
 220:daisycomm.c   ****             if(UPSTREAM_DMA.CTRLB & DMA_CH_CHBUSY_bm)
 221:daisycomm.c   ****             {
 222:daisycomm.c   ****                 UPSTREAM_DMA.CTRLA &= ~DMA_CH_ENABLE_bm;
 223:daisycomm.c   ****             }
 224:daisycomm.c   **** 
 225:daisycomm.c   ****             upstreamRxDone = 0;
 226:daisycomm.c   ****             //upstreamTxDone = 0;
 227:daisycomm.c   ****             upstreamBusy = 0;
 228:daisycomm.c   **** 
 229:daisycomm.c   ****             //Configure the transceivers and prepare DMA
 230:daisycomm.c   ****             if(selectedDirection == INBOUND)
 231:daisycomm.c   ****             {
 232:daisycomm.c   ****                 prepareDMAChannel(&UPSTREAM_DMA, UPSTREAM_DIST_USART_INBOUND_TRIGGER, &UPSTREAM_DIS
 233:daisycomm.c   **** 
 234:daisycomm.c   ****                 activateDMAChannel(&UPSTREAM_DMA,COMMAND_PACKET_SIZE);
 235:daisycomm.c   ****                 UPSTREAM_CONFIG = INBOUND;
 236:daisycomm.c   **** 
 237:daisycomm.c   ****             } else {
 238:daisycomm.c   ****                 UPSTREAM_DIST_USART.STATUS = USART_TXCIF_bm;
 239:daisycomm.c   ****                 UPSTREAM_DIST_USART.CTRLA = USART_TXCINTLVL_LO_gc | USART_RXCINTLVL_OFF_gc;
 240:daisycomm.c   ****                 prepareDMAChannel(&UPSTREAM_DMA, UPSTREAM_DIST_USART_OUTBOUND_TRIGGER, &UPSTREAM_DI
 241:daisycomm.c   ****                 //Do not send all data through DMA.  Instead send outbound upstream data + 1.  This
 242:daisycomm.c   ****                 UPSTREAM_CONFIG = OUTBOUND;
 243:daisycomm.c   ****             }
 244:daisycomm.c   ****             break;
 245:daisycomm.c   ****         default:
 246:daisycomm.c   ****             break;
 247:daisycomm.c   ****     }
 248:daisycomm.c   **** 
 249:daisycomm.c   ****     sei();
 250:daisycomm.c   ****     return;
 251:daisycomm.c   **** }
 252:daisycomm.c   **** 
 253:daisycomm.c   **** /************************************************************************
 254:daisycomm.c   **** * prepareDMAChannel(targetChannel,usartTrigger, targetUSART,targetBuffer)
 255:daisycomm.c   **** *
 256:daisycomm.c   **** * Configures targetChannel (a DMA.CHX structure) of the DMA module
 257:daisycomm.c   **** * to collect data on usartTrigger signal produced by targetUSART and place
 258:daisycomm.c   **** * it into the buffer targetBuffer.
 259:daisycomm.c   **** *
 260:daisycomm.c   **** * This should be called before fireDMAChannel()
 261:daisycomm.c   **** ************************************************************************/
 262:daisycomm.c   **** static void prepareDMAChannel(DMA_CH_t *selectedChannel, uint8_t usartTrigger, USART_t *targetUSART
  17               		.loc 1 262 0
  18               		.cfi_startproc
  19               	.LVL0:
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 0 */
  23               	.L__stack_usage = 0
 263:daisycomm.c   **** {
 264:daisycomm.c   ****     //Configure the chosen channel to read from a fixed UART into a linear array
 265:daisycomm.c   ****     if(isOutbound)
  24               		.loc 1 265 0
  25 0000 4423      		tst r20
  26 0002 01F0      		breq .L2
 266:daisycomm.c   ****     {
 267:daisycomm.c   ****         selectedChannel->ADDRCTRL = DMA_CH_SRCRELOAD_TRANSACTION_gc | DMA_CH_SRCDIR_INC_gc | \
  27               		.loc 1 267 0
  28 0004 98ED      		ldi r25,lo8(-40)
  29 0006 00C0      		rjmp .L8
  30               	.L2:
 268:daisycomm.c   ****                        DMA_CH_DESTRELOAD_BURST_gc | DMA_CH_DESTDIR_FIXED_gc;
 269:daisycomm.c   ****     } else {
 270:daisycomm.c   ****         selectedChannel->ADDRCTRL = DMA_CH_SRCRELOAD_BURST_gc | DMA_CH_SRCDIR_FIXED_gc | \
  31               		.loc 1 270 0
  32 0008 9DE8      		ldi r25,lo8(-115)
  33               	.L8:
  34 000a E0E1      		ldi r30,lo8(272)
  35 000c F1E0      		ldi r31,hi8(272)
  36 000e 9283      		std Z+2,r25
 271:daisycomm.c   ****                        DMA_CH_DESTRELOAD_TRANSACTION_gc | DMA_CH_DESTDIR_INC_gc;
 272:daisycomm.c   ****     }
 273:daisycomm.c   **** 
 274:daisycomm.c   ****     //Set to perform one block transfer corresponding to one command packet
 275:daisycomm.c   ****     //Technically not necessary because REPEAT will not be set in CTRLA
 276:daisycomm.c   ****     selectedChannel->REPCNT = 0x01;
  37               		.loc 1 276 0
  38 0010 E0E1      		ldi r30,lo8(272)
  39 0012 F1E0      		ldi r31,hi8(272)
  40 0014 91E0      		ldi r25,lo8(1)
  41 0016 9683      		std Z+6,r25
 277:daisycomm.c   **** 
 278:daisycomm.c   ****     //This part has 16 bit pointers, so cast appropriately.
 279:daisycomm.c   ****     //Memory addresses are 24 bits to allow for external memory to be mapped into one address space
 280:daisycomm.c   ****     //Same with internal EEPROM Data memory.
 281:daisycomm.c   ****     //Since these locations are in lower memory, fix the high order address bits to zero.
 282:daisycomm.c   ****     //Mapping external memory will require more care.
 283:daisycomm.c   ****     if(isOutbound)
  42               		.loc 1 283 0
  43 0018 4423      		tst r20
  44 001a 01F0      		breq .L4
 284:daisycomm.c   ****     {
 285:daisycomm.c   ****         selectedChannel->DESTADDR0 = (uint16_t) &targetUSART->DATA & 0x00FF;
  45               		.loc 1 285 0
  46 001c 90EA      		ldi r25,lo8(-96)
  47 001e 9487      		std Z+12,r25
 286:daisycomm.c   ****         selectedChannel->DESTADDR1 = (uint16_t) &targetUSART->DATA >> 8;
  48               		.loc 1 286 0
  49 0020 99E0      		ldi r25,lo8(9)
  50 0022 9587      		std Z+13,r25
 287:daisycomm.c   ****         selectedChannel->DESTADDR2 = 0;
  51               		.loc 1 287 0
  52 0024 1686      		std Z+14,__zero_reg__
 288:daisycomm.c   **** 
 289:daisycomm.c   ****         selectedChannel->SRCADDR0 = (uint16_t)targetBuffer & 0x00FF;
  53               		.loc 1 289 0
  54 0026 6087      		std Z+8,r22
 290:daisycomm.c   ****         selectedChannel->SRCADDR1 = (uint16_t)targetBuffer >> 8;
  55               		.loc 1 290 0
  56 0028 7187      		std Z+9,r23
  57 002a 00C0      		rjmp .L9
  58               	.L4:
 291:daisycomm.c   ****         selectedChannel->SRCADDR2 = 0;
 292:daisycomm.c   ****     } else {
 293:daisycomm.c   ****         selectedChannel->DESTADDR0 = (uint16_t)targetBuffer & 0x00FF;
  59               		.loc 1 293 0
  60 002c 6487      		std Z+12,r22
 294:daisycomm.c   ****         selectedChannel->DESTADDR1 = (uint16_t)targetBuffer >> 8;
  61               		.loc 1 294 0
  62 002e 7587      		std Z+13,r23
 295:daisycomm.c   ****         selectedChannel->DESTADDR2 = 0;
  63               		.loc 1 295 0
  64 0030 1686      		std Z+14,__zero_reg__
 296:daisycomm.c   **** 
 297:daisycomm.c   ****         selectedChannel->SRCADDR0 = (uint16_t) &targetUSART->DATA & 0x00FF;
  65               		.loc 1 297 0
  66 0032 90EA      		ldi r25,lo8(-96)
  67 0034 9087      		std Z+8,r25
 298:daisycomm.c   ****         selectedChannel->SRCADDR1 = (uint16_t) &targetUSART->DATA >> 8;
  68               		.loc 1 298 0
  69 0036 99E0      		ldi r25,lo8(9)
  70 0038 9187      		std Z+9,r25
  71               	.L9:
 299:daisycomm.c   ****         selectedChannel->SRCADDR2 = 0;
  72               		.loc 1 299 0
  73 003a 1286      		std Z+10,__zero_reg__
 300:daisycomm.c   ****     }
 301:daisycomm.c   **** 
 302:daisycomm.c   ****     //Trigger on received data
 303:daisycomm.c   ****     selectedChannel->TRIGSRC = usartTrigger;
  74               		.loc 1 303 0
  75 003c E0E1      		ldi r30,lo8(272)
  76 003e F1E0      		ldi r31,hi8(272)
  77 0040 8383      		std Z+3,r24
 304:daisycomm.c   **** 
 305:daisycomm.c   ****     //Interrupt on this channel when the transaction is complete, and clear any pending flags
 306:daisycomm.c   ****     if(isOutbound)
  78               		.loc 1 306 0
  79 0042 4423      		tst r20
  80 0044 01F0      		breq .L6
 307:daisycomm.c   ****     {
 308:daisycomm.c   ****         selectedChannel->CTRLB = DMA_CH_TRNINTLVL_OFF_gc | DMA_CH_TRNIF_bm;
  81               		.loc 1 308 0
  82 0046 80E1      		ldi r24,lo8(16)
  83               	.LVL1:
  84 0048 8183      		std Z+1,r24
 309:daisycomm.c   ****         targetUSART->STATUS = USART_TXCIF_bm;
  85               		.loc 1 309 0
  86 004a E0EA      		ldi r30,lo8(2464)
  87 004c F9E0      		ldi r31,hi8(2464)
  88               	.LVL2:
  89 004e 80E4      		ldi r24,lo8(64)
  90 0050 8183      		std Z+1,r24
 310:daisycomm.c   ****         targetUSART->CTRLA = USART_TXCINTLVL_LO_gc | USART_RXCINTLVL_OFF_gc;
  91               		.loc 1 310 0
  92 0052 84E0      		ldi r24,lo8(4)
  93 0054 8383      		std Z+3,r24
  94 0056 0895      		ret
  95               	.LVL3:
  96               	.L6:
 311:daisycomm.c   ****     } else
 312:daisycomm.c   ****     {
 313:daisycomm.c   ****         selectedChannel->CTRLB = DMA_CH_TRNINTLVL_LO_gc | DMA_CH_TRNIF_bm;
  97               		.loc 1 313 0
  98 0058 81E1      		ldi r24,lo8(17)
  99 005a 8183      		std Z+1,r24
 100 005c 0895      		ret
 101               		.cfi_endproc
 102               	.LFE17:
 105               	configureHalfDuplexLink.constprop.1:
 106               	.LFB16:
 213:daisycomm.c   **** static void configureHalfDuplexLink(SERIAL_STREAM_t selectedStream, SERIAL_DIRECTION_t selectedDire
 107               		.loc 1 213 0
 108               		.cfi_startproc
 109               	.LVL4:
 110               	/* prologue: function */
 111               	/* frame size = 0 */
 112               	/* stack size = 0 */
 113               	.L__stack_usage = 0
 215:daisycomm.c   ****     cli();
 114               		.loc 1 215 0
 115               	/* #APP */
 116               	 ;  215 "daisycomm.c" 1
 117 005e F894      		cli
 118               	 ;  0 "" 2
 220:daisycomm.c   ****             if(UPSTREAM_DMA.CTRLB & DMA_CH_CHBUSY_bm)
 119               		.loc 1 220 0
 120               	/* #NOAPP */
 121 0060 9091 1101 		lds r25,273
 122 0064 97FF      		sbrs r25,7
 123 0066 00C0      		rjmp .L11
 222:daisycomm.c   ****                 UPSTREAM_DMA.CTRLA &= ~DMA_CH_ENABLE_bm;
 124               		.loc 1 222 0
 125 0068 9091 1001 		lds r25,272
 126 006c 9F77      		andi r25,lo8(127)
 127 006e E0E0      		ldi r30,lo8(256)
 128 0070 F1E0      		ldi r31,hi8(256)
 129 0072 908B      		std Z+16,r25
 130               	.L11:
 225:daisycomm.c   ****             upstreamRxDone = 0;
 131               		.loc 1 225 0
 132 0074 1092 0000 		sts upstreamRxDone,__zero_reg__
 133 0078 1092 0000 		sts upstreamRxDone+1,__zero_reg__
 227:daisycomm.c   ****             upstreamBusy = 0;
 134               		.loc 1 227 0
 135 007c 1092 0000 		sts upstreamBusy,__zero_reg__
 230:daisycomm.c   ****             if(selectedDirection == INBOUND)
 136               		.loc 1 230 0
 137 0080 8823      		tst r24
 138 0082 01F4      		brne .L12
 232:daisycomm.c   ****                 prepareDMAChannel(&UPSTREAM_DMA, UPSTREAM_DIST_USART_INBOUND_TRIGGER, &UPSTREAM_DIS
 139               		.loc 1 232 0
 140 0084 8BE6      		ldi r24,lo8(107)
 141               	.LVL5:
 142 0086 60E0      		ldi r22,lo8(inbound_upstream_data)
 143 0088 70E0      		ldi r23,hi8(inbound_upstream_data)
 144 008a 40E0      		ldi r20,lo8(0)
 145 008c 0E94 0000 		call prepareDMAChannel.constprop.0
 146               	.LVL6:
 147               	.LBB18:
 148               	.LBB19:
 314:daisycomm.c   ****     }
 315:daisycomm.c   **** }
 316:daisycomm.c   **** 
 317:daisycomm.c   **** /************************************************************************
 318:daisycomm.c   ****  * activateDMAChannel(selectedChannel,numBytes)
 319:daisycomm.c   ****  *
 320:daisycomm.c   ****  * Activates the DMA channel identified by selectedChannel (a DMA.CHX structure)
 321:daisycomm.c   ****  * to receive numBytes bytes.  The DMA channel must have been previously prepared
 322:daisycomm.c   ****  * with prepareDMAChannel().
 323:daisycomm.c   ****  ************************************************************************/
 324:daisycomm.c   **** static void activateDMAChannel(DMA_CH_t *selectedChannel,int numBytes)
 325:daisycomm.c   **** {
 326:daisycomm.c   ****     //Set block size to packet size
 327:daisycomm.c   ****     selectedChannel->TRFCNT = numBytes;
 149               		.loc 1 327 0
 150 0090 87E0      		ldi r24,lo8(7)
 151 0092 90E0      		ldi r25,hi8(7)
 152 0094 E0E1      		ldi r30,lo8(272)
 153 0096 F1E0      		ldi r31,hi8(272)
 154 0098 8483      		std Z+4,r24
 155 009a 9583      		std Z+5,r25
 328:daisycomm.c   ****     //Enable the channel on single shot mode with a burst length of one.  Whenever the trigger arri
 329:daisycomm.c   ****     //only one burst will be performed.
 330:daisycomm.c   ****     selectedChannel->CTRLA = DMA_CH_BURSTLEN_1BYTE_gc | DMA_CH_SINGLE_bm | DMA_CH_ENABLE_bm;
 156               		.loc 1 330 0
 157 009c 84E8      		ldi r24,lo8(-124)
 158 009e 8093 1001 		sts 272,r24
 159               	.LBE19:
 160               	.LBE18:
 235:daisycomm.c   ****                 UPSTREAM_CONFIG = INBOUND;
 161               		.loc 1 235 0
 162 00a2 1092 0000 		sts UPSTREAM_CONFIG,__zero_reg__
 163 00a6 00C0      		rjmp .L13
 164               	.LVL7:
 165               	.L12:
 238:daisycomm.c   ****                 UPSTREAM_DIST_USART.STATUS = USART_TXCIF_bm;
 166               		.loc 1 238 0
 167 00a8 E0EA      		ldi r30,lo8(2464)
 168 00aa F9E0      		ldi r31,hi8(2464)
 169 00ac 80E4      		ldi r24,lo8(64)
 170               	.LVL8:
 171 00ae 8183      		std Z+1,r24
 239:daisycomm.c   ****                 UPSTREAM_DIST_USART.CTRLA = USART_TXCINTLVL_LO_gc | USART_RXCINTLVL_OFF_gc;
 172               		.loc 1 239 0
 173 00b0 84E0      		ldi r24,lo8(4)
 174 00b2 8383      		std Z+3,r24
 240:daisycomm.c   ****                 prepareDMAChannel(&UPSTREAM_DMA, UPSTREAM_DIST_USART_OUTBOUND_TRIGGER, &UPSTREAM_DI
 175               		.loc 1 240 0
 176 00b4 8CE6      		ldi r24,lo8(108)
 177 00b6 60E0      		ldi r22,lo8(outbound_upstream_data+1)
 178 00b8 70E0      		ldi r23,hi8(outbound_upstream_data+1)
 179 00ba 41E0      		ldi r20,lo8(1)
 180 00bc 0E94 0000 		call prepareDMAChannel.constprop.0
 242:daisycomm.c   ****                 UPSTREAM_CONFIG = OUTBOUND;
 181               		.loc 1 242 0
 182 00c0 81E0      		ldi r24,lo8(1)
 183 00c2 8093 0000 		sts UPSTREAM_CONFIG,r24
 184               	.L13:
 249:daisycomm.c   ****     sei();
 185               		.loc 1 249 0
 186               	/* #APP */
 187               	 ;  249 "daisycomm.c" 1
 188 00c6 7894      		sei
 189               	 ;  0 "" 2
 190               	/* epilogue start */
 251:daisycomm.c   **** }
 191               		.loc 1 251 0
 192               	/* #NOAPP */
 193 00c8 0895      		ret
 194               		.cfi_endproc
 195               	.LFE16:
 197               	.global	__vector_14
 199               	__vector_14:
 200               	.LFB6:
  89:daisycomm.c   **** {
 201               		.loc 1 89 0
 202               		.cfi_startproc
 203 00ca 1F92      		push r1
 204               	.LCFI0:
 205               		.cfi_def_cfa_offset 3
 206               		.cfi_offset 1, -2
 207 00cc 0F92      		push r0
 208               	.LCFI1:
 209               		.cfi_def_cfa_offset 4
 210               		.cfi_offset 0, -3
 211 00ce 0FB6      		in r0,__SREG__
 212 00d0 0F92      		push r0
 213 00d2 1124      		clr __zero_reg__
 214 00d4 2F93      		push r18
 215               	.LCFI2:
 216               		.cfi_def_cfa_offset 5
 217               		.cfi_offset 18, -4
 218 00d6 3F93      		push r19
 219               	.LCFI3:
 220               		.cfi_def_cfa_offset 6
 221               		.cfi_offset 19, -5
 222 00d8 4F93      		push r20
 223               	.LCFI4:
 224               		.cfi_def_cfa_offset 7
 225               		.cfi_offset 20, -6
 226 00da 5F93      		push r21
 227               	.LCFI5:
 228               		.cfi_def_cfa_offset 8
 229               		.cfi_offset 21, -7
 230 00dc 6F93      		push r22
 231               	.LCFI6:
 232               		.cfi_def_cfa_offset 9
 233               		.cfi_offset 22, -8
 234 00de 7F93      		push r23
 235               	.LCFI7:
 236               		.cfi_def_cfa_offset 10
 237               		.cfi_offset 23, -9
 238 00e0 8F93      		push r24
 239               	.LCFI8:
 240               		.cfi_def_cfa_offset 11
 241               		.cfi_offset 24, -10
 242 00e2 9F93      		push r25
 243               	.LCFI9:
 244               		.cfi_def_cfa_offset 12
 245               		.cfi_offset 25, -11
 246 00e4 AF93      		push r26
 247               	.LCFI10:
 248               		.cfi_def_cfa_offset 13
 249               		.cfi_offset 26, -12
 250 00e6 BF93      		push r27
 251               	.LCFI11:
 252               		.cfi_def_cfa_offset 14
 253               		.cfi_offset 27, -13
 254 00e8 EF93      		push r30
 255               	.LCFI12:
 256               		.cfi_def_cfa_offset 15
 257               		.cfi_offset 30, -14
 258 00ea FF93      		push r31
 259               	.LCFI13:
 260               		.cfi_def_cfa_offset 16
 261               		.cfi_offset 31, -15
 262               	/* prologue: Signal */
 263               	/* frame size = 0 */
 264               	/* stack size = 15 */
 265               	.L__stack_usage = 15
  91:daisycomm.c   ****     if(UPSTREAM_CONFIG == OUTBOUND)
 266               		.loc 1 91 0
 267 00ec 8091 0000 		lds r24,UPSTREAM_CONFIG
 268 00f0 8130      		cpi r24,lo8(1)
 269 00f2 01F4      		brne .L15
  94:daisycomm.c   ****         upstreamBusy = 0;
 270               		.loc 1 94 0
 271 00f4 1092 0000 		sts upstreamBusy,__zero_reg__
 272 00f8 00C0      		rjmp .L14
 273               	.L15:
  98:daisycomm.c   ****         if((UPSTREAM_DMA.CTRLB & DMA_CH_CHBUSY_bm) || !(UPSTREAM_DMA.CTRLA & DMA_CH_ENABLE_bm))
 274               		.loc 1 98 0
 275 00fa 8091 1101 		lds r24,273
 276 00fe 87FD      		sbrc r24,7
 277 0100 00C0      		rjmp .L17
  98:daisycomm.c   ****         if((UPSTREAM_DMA.CTRLB & DMA_CH_CHBUSY_bm) || !(UPSTREAM_DMA.CTRLA & DMA_CH_ENABLE_bm))
 278               		.loc 1 98 0 is_stmt 0 discriminator 1
 279 0102 8091 1001 		lds r24,272
 280 0106 87FD      		sbrc r24,7
 281 0108 00C0      		rjmp .L18
 282               	.L17:
 100:daisycomm.c   ****             upstreamBusy++;
 283               		.loc 1 100 0 is_stmt 1
 284 010a 8091 0000 		lds r24,upstreamBusy
 285 010e 8F5F      		subi r24,lo8(-(1))
 286 0110 8093 0000 		sts upstreamBusy,r24
 287               	.L18:
 103:daisycomm.c   ****         if(upstreamBusy > 2)
 288               		.loc 1 103 0
 289 0114 8091 0000 		lds r24,upstreamBusy
 290 0118 8330      		cpi r24,lo8(3)
 291 011a 00F0      		brlo .L14
 106:daisycomm.c   ****             UPSTREAM_DMA.CTRLA = 0x00;
 292               		.loc 1 106 0
 293 011c E0E0      		ldi r30,lo8(256)
 294 011e F1E0      		ldi r31,hi8(256)
 295 0120 108A      		std Z+16,__zero_reg__
 296               	.L19:
 108:daisycomm.c   ****             while(UPSTREAM_DMA.CTRLA & DMA_CH_ENABLE_bm);
 297               		.loc 1 108 0 discriminator 1
 298 0122 8091 1001 		lds r24,272
 299 0126 87FD      		sbrc r24,7
 300 0128 00C0      		rjmp .L19
 111:daisycomm.c   ****             UPSTREAM_DMA.CTRLA = DMA_CH_RESET_bm;
 301               		.loc 1 111 0
 302 012a 80E4      		ldi r24,lo8(64)
 303 012c E0E0      		ldi r30,lo8(256)
 304 012e F1E0      		ldi r31,hi8(256)
 305 0130 808B      		std Z+16,r24
 114:daisycomm.c   ****             prepareDMAChannel(&UPSTREAM_DMA, UPSTREAM_DIST_USART_INBOUND_TRIGGER, &UPSTREAM_DIST_US
 306               		.loc 1 114 0
 307 0132 8BE6      		ldi r24,lo8(107)
 308 0134 60E0      		ldi r22,lo8(inbound_upstream_data)
 309 0136 70E0      		ldi r23,hi8(inbound_upstream_data)
 310 0138 40E0      		ldi r20,lo8(0)
 311 013a 0E94 0000 		call prepareDMAChannel.constprop.0
 312               	.LVL9:
 313               	.LBB20:
 314               	.LBB21:
 327:daisycomm.c   ****     selectedChannel->TRFCNT = numBytes;
 315               		.loc 1 327 0
 316 013e 87E0      		ldi r24,lo8(7)
 317 0140 90E0      		ldi r25,hi8(7)
 318 0142 E0E1      		ldi r30,lo8(272)
 319 0144 F1E0      		ldi r31,hi8(272)
 320 0146 8483      		std Z+4,r24
 321 0148 9583      		std Z+5,r25
 322               		.loc 1 330 0
 323 014a 84E8      		ldi r24,lo8(-124)
 324 014c 8093 1001 		sts 272,r24
 325               	.LVL10:
 326               	.L14:
 327               	/* epilogue start */
 328               	.LBE21:
 329               	.LBE20:
 118:daisycomm.c   **** }
 330               		.loc 1 118 0
 331 0150 FF91      		pop r31
 332 0152 EF91      		pop r30
 333 0154 BF91      		pop r27
 334 0156 AF91      		pop r26
 335 0158 9F91      		pop r25
 336 015a 8F91      		pop r24
 337 015c 7F91      		pop r23
 338 015e 6F91      		pop r22
 339 0160 5F91      		pop r21
 340 0162 4F91      		pop r20
 341 0164 3F91      		pop r19
 342 0166 2F91      		pop r18
 343 0168 0F90      		pop r0
 344 016a 0FBE      		out __SREG__,r0
 345 016c 0F90      		pop r0
 346 016e 1F90      		pop r1
 347 0170 1895      		reti
 348               		.cfi_endproc
 349               	.LFE6:
 351               	.global	__vector_6
 353               	__vector_6:
 354               	.LFB7:
 125:daisycomm.c   **** {
 355               		.loc 1 125 0
 356               		.cfi_startproc
 357 0172 1F92      		push r1
 358               	.LCFI14:
 359               		.cfi_def_cfa_offset 3
 360               		.cfi_offset 1, -2
 361 0174 0F92      		push r0
 362               	.LCFI15:
 363               		.cfi_def_cfa_offset 4
 364               		.cfi_offset 0, -3
 365 0176 0FB6      		in r0,__SREG__
 366 0178 0F92      		push r0
 367 017a 1124      		clr __zero_reg__
 368 017c 8F93      		push r24
 369               	.LCFI16:
 370               		.cfi_def_cfa_offset 5
 371               		.cfi_offset 24, -4
 372 017e 9F93      		push r25
 373               	.LCFI17:
 374               		.cfi_def_cfa_offset 6
 375               		.cfi_offset 25, -5
 376 0180 EF93      		push r30
 377               	.LCFI18:
 378               		.cfi_def_cfa_offset 7
 379               		.cfi_offset 30, -6
 380 0182 FF93      		push r31
 381               	.LCFI19:
 382               		.cfi_def_cfa_offset 8
 383               		.cfi_offset 31, -7
 384               	/* prologue: Signal */
 385               	/* frame size = 0 */
 386               	/* stack size = 7 */
 387               	.L__stack_usage = 7
 128:daisycomm.c   ****     if(UPSTREAM_DMA.CTRLB & DMA_CH_ERRIF_bm)
 388               		.loc 1 128 0
 389 0184 8091 1101 		lds r24,273
 390 0188 85FD      		sbrc r24,5
 391 018a 00C0      		rjmp .L21
 137:daisycomm.c   ****     if(UPSTREAM_DMA.CTRLB & DMA_CH_TRNIF_bm)
 392               		.loc 1 137 0
 393 018c 8091 1101 		lds r24,273
 394 0190 84FF      		sbrs r24,4
 395 0192 00C0      		rjmp .L21
 140:daisycomm.c   ****         UPSTREAM_DMA.CTRLB = UPSTREAM_DMA.CTRLB | DMA_CH_TRNIF_bm;
 396               		.loc 1 140 0
 397 0194 8091 1101 		lds r24,273
 398 0198 8061      		ori r24,lo8(16)
 399 019a E0E0      		ldi r30,lo8(256)
 400 019c F1E0      		ldi r31,hi8(256)
 401 019e 818B      		std Z+17,r24
 141:daisycomm.c   ****         upstreamBusy = 0;
 402               		.loc 1 141 0
 403 01a0 1092 0000 		sts upstreamBusy,__zero_reg__
 142:daisycomm.c   ****         notifyDaisy = 1;
 404               		.loc 1 142 0
 405 01a4 81E0      		ldi r24,lo8(1)
 406 01a6 8093 0000 		sts notifyDaisy,r24
 143:daisycomm.c   ****         upstreamRxDone = 1;
 407               		.loc 1 143 0
 408 01aa 81E0      		ldi r24,lo8(1)
 409 01ac 90E0      		ldi r25,hi8(1)
 410 01ae 8093 0000 		sts upstreamRxDone,r24
 411 01b2 9093 0000 		sts upstreamRxDone+1,r25
 412               	.L21:
 413               	/* epilogue start */
 145:daisycomm.c   **** }
 414               		.loc 1 145 0
 415 01b6 FF91      		pop r31
 416 01b8 EF91      		pop r30
 417 01ba 9F91      		pop r25
 418 01bc 8F91      		pop r24
 419 01be 0F90      		pop r0
 420 01c0 0FBE      		out __SREG__,r0
 421 01c2 0F90      		pop r0
 422 01c4 1F90      		pop r1
 423 01c6 1895      		reti
 424               		.cfi_endproc
 425               	.LFE7:
 427               	.global	__vector_90
 429               	__vector_90:
 430               	.LFB8:
 159:daisycomm.c   **** {
 431               		.loc 1 159 0
 432               		.cfi_startproc
 433 01c8 1F92      		push r1
 434               	.LCFI20:
 435               		.cfi_def_cfa_offset 3
 436               		.cfi_offset 1, -2
 437 01ca 0F92      		push r0
 438               	.LCFI21:
 439               		.cfi_def_cfa_offset 4
 440               		.cfi_offset 0, -3
 441 01cc 0FB6      		in r0,__SREG__
 442 01ce 0F92      		push r0
 443 01d0 1124      		clr __zero_reg__
 444 01d2 8F93      		push r24
 445               	.LCFI22:
 446               		.cfi_def_cfa_offset 5
 447               		.cfi_offset 24, -4
 448 01d4 9F93      		push r25
 449               	.LCFI23:
 450               		.cfi_def_cfa_offset 6
 451               		.cfi_offset 25, -5
 452 01d6 EF93      		push r30
 453               	.LCFI24:
 454               		.cfi_def_cfa_offset 7
 455               		.cfi_offset 30, -6
 456 01d8 FF93      		push r31
 457               	.LCFI25:
 458               		.cfi_def_cfa_offset 8
 459               		.cfi_offset 31, -7
 460               	/* prologue: Signal */
 461               	/* frame size = 0 */
 462               	/* stack size = 7 */
 463               	.L__stack_usage = 7
 160:daisycomm.c   ****     upstreamBusy = 0;
 464               		.loc 1 160 0
 465 01da 1092 0000 		sts upstreamBusy,__zero_reg__
 161:daisycomm.c   ****     notifyDaisy = 1;
 466               		.loc 1 161 0
 467 01de 81E0      		ldi r24,lo8(1)
 468 01e0 8093 0000 		sts notifyDaisy,r24
 162:daisycomm.c   ****     upstreamTxDone = 1;
 469               		.loc 1 162 0
 470 01e4 81E0      		ldi r24,lo8(1)
 471 01e6 90E0      		ldi r25,hi8(1)
 472 01e8 8093 0000 		sts upstreamTxDone,r24
 473 01ec 9093 0000 		sts upstreamTxDone+1,r25
 163:daisycomm.c   ****     UPSTREAM_DIST_USART.CTRLA = USART_TXCINTLVL_OFF_gc | USART_RXCINTLVL_OFF_gc;
 474               		.loc 1 163 0
 475 01f0 E0EA      		ldi r30,lo8(2464)
 476 01f2 F9E0      		ldi r31,hi8(2464)
 477 01f4 1382      		std Z+3,__zero_reg__
 164:daisycomm.c   ****     UPSTREAM_DIST_USART.STATUS = USART_TXCIF_bm;
 478               		.loc 1 164 0
 479 01f6 80E4      		ldi r24,lo8(64)
 480 01f8 8183      		std Z+1,r24
 481               	/* epilogue start */
 165:daisycomm.c   **** }
 482               		.loc 1 165 0
 483 01fa FF91      		pop r31
 484 01fc EF91      		pop r30
 485 01fe 9F91      		pop r25
 486 0200 8F91      		pop r24
 487 0202 0F90      		pop r0
 488 0204 0FBE      		out __SREG__,r0
 489 0206 0F90      		pop r0
 490 0208 1F90      		pop r1
 491 020a 1895      		reti
 492               		.cfi_endproc
 493               	.LFE8:
 495               	.global	computeChecksum
 497               	computeChecksum:
 498               	.LFB13:
 331:daisycomm.c   **** }
 332:daisycomm.c   **** 
 333:daisycomm.c   **** /************************************************************************
 334:daisycomm.c   ****  * Returns the appropriate checksum for the first packetSize bytes of packetBuffer
 335:daisycomm.c   ****  * As a shortcut, feeding an entire packet to this routine should result in a return
 336:daisycomm.c   ****  * value of zero for a proper packet.
 337:daisycomm.c   ****  ************************************************************************/
 338:daisycomm.c   **** int computeChecksum(uint8_t *packetBuffer, int packetSize)
 339:daisycomm.c   **** {
 499               		.loc 1 339 0
 500               		.cfi_startproc
 501               	.LVL11:
 502               	/* prologue: function */
 503               	/* frame size = 0 */
 504               	/* stack size = 0 */
 505               	.L__stack_usage = 0
 506               	.LBB22:
 340:daisycomm.c   ****     uint8_t accumulator = 0;
 507               		.loc 1 340 0
 508 020c FC01      		movw r30,r24
 341:daisycomm.c   ****     for(int i=0;i<packetSize;i++)
 509               		.loc 1 341 0
 510 020e 20E0      		ldi r18,lo8(0)
 511 0210 30E0      		ldi r19,hi8(0)
 340:daisycomm.c   ****     uint8_t accumulator = 0;
 512               		.loc 1 340 0
 513 0212 80E0      		ldi r24,lo8(0)
 514               	.LVL12:
 515               		.loc 1 341 0
 516 0214 00C0      		rjmp .L25
 517               	.LVL13:
 518               	.L26:
 342:daisycomm.c   ****     {
 343:daisycomm.c   ****         accumulator += packetBuffer[i];
 519               		.loc 1 343 0 discriminator 2
 520 0216 9191      		ld r25,Z+
 521 0218 890F      		add r24,r25
 522               	.LVL14:
 341:daisycomm.c   ****     for(int i=0;i<packetSize;i++)
 523               		.loc 1 341 0 discriminator 2
 524 021a 2F5F      		subi r18,lo8(-(1))
 525 021c 3F4F      		sbci r19,hi8(-(1))
 526               	.LVL15:
 527               	.L25:
 341:daisycomm.c   ****     for(int i=0;i<packetSize;i++)
 528               		.loc 1 341 0 is_stmt 0 discriminator 1
 529 021e 2617      		cp r18,r22
 530 0220 3707      		cpc r19,r23
 531 0222 04F0      		brlt .L26
 532               	.LBE22:
 344:daisycomm.c   ****     }
 345:daisycomm.c   **** 
 346:daisycomm.c   ****     return (0x00 - accumulator);
 533               		.loc 1 346 0 is_stmt 1
 534 0224 90E0      		ldi r25,lo8(0)
 535 0226 9095      		com r25
 536 0228 8195      		neg r24
 537 022a 9F4F      		sbci r25,lo8(-1)
 538               	.LVL16:
 539               	/* epilogue start */
 347:daisycomm.c   **** }
 540               		.loc 1 347 0
 541 022c 0895      		ret
 542               		.cfi_endproc
 543               	.LFE13:
 545               	.global	configureDaisyUSART
 547               	configureDaisyUSART:
 548               	.LFB14:
 348:daisycomm.c   **** 
 349:daisycomm.c   **** 
 350:daisycomm.c   **** /************************************************************************
 351:daisycomm.c   ****  * configureDaisyUSART()
 352:daisycomm.c   ****  *
 353:daisycomm.c   ****  * Configures the daisy chain system based on parameters in the daisyconfig.h file
 354:daisycomm.c   ****  ************************************************************************/
 355:daisycomm.c   **** void configureDaisyUSART(void)
 356:daisycomm.c   **** {
 549               		.loc 1 356 0
 550               		.cfi_startproc
 551               	/* prologue: function */
 552               	/* frame size = 0 */
 553               	/* stack size = 0 */
 554               	.L__stack_usage = 0
 555               	.LVL17:
 556               	.LBB23:
 557               	.LBB24:
 197:daisycomm.c   ****         targetUSART->BAUDCTRLA = 0;                                //Configure for 2 MBaud by setti
 558               		.loc 1 197 0
 559 022e E0EA      		ldi r30,lo8(2464)
 560 0230 F9E0      		ldi r31,hi8(2464)
 561 0232 1682      		std Z+6,__zero_reg__
 198:daisycomm.c   ****         targetUSART->BAUDCTRLB = 0x00;                            //and BSEL to zero
 562               		.loc 1 198 0
 563 0234 1782      		std Z+7,__zero_reg__
 200:daisycomm.c   ****     targetUSART->CTRLC = USART_CMODE_ASYNCHRONOUS_gc | \
 564               		.loc 1 200 0
 565 0236 83E0      		ldi r24,lo8(3)
 566 0238 8583      		std Z+5,r24
 203:daisycomm.c   ****     targetUSART->CTRLB |= USART_RXEN_bm | USART_TXEN_bm;    //enable RX and TX
 567               		.loc 1 203 0
 568 023a 8481      		ldd r24,Z+4
 569 023c 8861      		ori r24,lo8(24)
 570 023e 8483      		std Z+4,r24
 571               	.LBE24:
 572               	.LBE23:
 357:daisycomm.c   ****     //First initialize the upstream
 358:daisycomm.c   ****     configureUSARTHardware(&UPSTREAM_DIST_USART,0,0);
 359:daisycomm.c   **** 
 360:daisycomm.c   ****     //Prepare DMA transfers
 361:daisycomm.c   ****     DMA.CTRL = DMA_ENABLE_bm;
 573               		.loc 1 361 0
 574 0240 80E8      		ldi r24,lo8(-128)
 575 0242 8093 0001 		sts 256,r24
 362:daisycomm.c   **** 
 363:daisycomm.c   ****     //Assume default configuration with downstream OUT and upstream IN
 364:daisycomm.c   ****     configureHalfDuplexLink(UPSTREAM,INBOUND);
 576               		.loc 1 364 0
 577 0246 80E0      		ldi r24,lo8(0)
 578 0248 0E94 0000 		call configureHalfDuplexLink.constprop.1
 365:daisycomm.c   **** 
 366:daisycomm.c   ****     //Activate the heartbeat timer for resetting inbound DMA as necessary
 367:daisycomm.c   ****     //Interrupt every half millisecond
 368:daisycomm.c   ****     //At 32 MHz internal oscillator with 1024 prescaler,
 369:daisycomm.c   ****     DAISY_TC.CTRLB = TC_WGMODE_NORMAL_gc;
 579               		.loc 1 369 0
 580 024c E0E0      		ldi r30,lo8(2048)
 581 024e F8E0      		ldi r31,hi8(2048)
 582 0250 1182      		std Z+1,__zero_reg__
 370:daisycomm.c   ****     DAISY_TC.CTRLC = 0x00;
 583               		.loc 1 370 0
 584 0252 1282      		std Z+2,__zero_reg__
 371:daisycomm.c   ****     DAISY_TC.CTRLD = TC_EVACT_OFF_gc | TC_EVSEL_OFF_gc;
 585               		.loc 1 371 0
 586 0254 1382      		std Z+3,__zero_reg__
 372:daisycomm.c   ****     DAISY_TC.CTRLE = 0x00;
 587               		.loc 1 372 0
 588 0256 1482      		std Z+4,__zero_reg__
 373:daisycomm.c   ****     DAISY_TC.PERBUF = 16;
 589               		.loc 1 373 0
 590 0258 80E1      		ldi r24,lo8(16)
 591 025a 90E0      		ldi r25,hi8(16)
 592 025c 86AB      		std Z+54,r24
 593 025e 97AB      		std Z+55,r25
 374:daisycomm.c   ****     DAISY_TC.INTCTRLA = TC_OVFINTLVL_LO_gc;
 594               		.loc 1 374 0
 595 0260 81E0      		ldi r24,lo8(1)
 596 0262 8683      		std Z+6,r24
 375:daisycomm.c   ****     DAISY_TC.CTRLA = TC_CLKSEL_DIV1024_gc;
 597               		.loc 1 375 0
 598 0264 87E0      		ldi r24,lo8(7)
 599 0266 8083      		st Z,r24
 600               	/* epilogue start */
 376:daisycomm.c   **** 
 377:daisycomm.c   ****     //Activate the Upstream DMA for a command packet of data
 378:daisycomm.c   ****     //activateDMAChannel(&UPSTREAM_DMA,COMMAND_PACKET_SIZE);
 379:daisycomm.c   **** }
 601               		.loc 1 379 0
 602 0268 0895      		ret
 603               		.cfi_endproc
 604               	.LFE14:
 606               	.global	doDaisyTask
 608               	doDaisyTask:
 609               	.LFB15:
 380:daisycomm.c   **** 
 381:daisycomm.c   **** /************************************************************************
 382:daisycomm.c   ****  * doDaisyTask()
 383:daisycomm.c   ****  *
 384:daisycomm.c   ****  * Main routine of the daisy chain process
 385:daisycomm.c   ****  * Maintains system state and manages the transmission/reception of chained data
 386:daisycomm.c   ****  * Should be called whenever notifyDaisy is set to 1.
 387:daisycomm.c   ****  ************************************************************************/
 388:daisycomm.c   **** 
 389:daisycomm.c   **** void doDaisyTask(void)
 390:daisycomm.c   **** {
 610               		.loc 1 390 0
 611               		.cfi_startproc
 612 026a CF93      		push r28
 613               	.LCFI26:
 614               		.cfi_def_cfa_offset 3
 615               		.cfi_offset 28, -2
 616               	/* prologue: function */
 617               	/* frame size = 0 */
 618               	/* stack size = 1 */
 619               	.L__stack_usage = 1
 391:daisycomm.c   ****   //This is set to IDLE when the upstream port is idle and TRANSMITTING when it is in use
 392:daisycomm.c   ****   static DAISY_STATE_t daisyState = DAISY_IDLE;
 393:daisycomm.c   ****   uint8_t packetSize;
 394:daisycomm.c   **** 
 395:daisycomm.c   ****   //First clear the daisy notification flag
 396:daisycomm.c   ****   cli();
 620               		.loc 1 396 0
 621               	/* #APP */
 622               	 ;  396 "daisycomm.c" 1
 623 026c F894      		cli
 624               	 ;  0 "" 2
 397:daisycomm.c   ****   notifyDaisy = 0;
 625               		.loc 1 397 0
 626               	/* #NOAPP */
 627 026e 1092 0000 		sts notifyDaisy,__zero_reg__
 398:daisycomm.c   ****   sei();
 628               		.loc 1 398 0
 629               	/* #APP */
 630               	 ;  398 "daisycomm.c" 1
 631 0272 7894      		sei
 632               	 ;  0 "" 2
 399:daisycomm.c   **** 
 400:daisycomm.c   ****   switch(daisyState)
 633               		.loc 1 400 0
 634               	/* #NOAPP */
 635 0274 8091 0000 		lds r24,daisyState.3772
 636 0278 8823      		tst r24
 637 027a 01F0      		breq .L30
 638 027c 8130      		cpi r24,lo8(1)
 639 027e 01F0      		breq .+2
 640 0280 00C0      		rjmp .L28
 641 0282 00C0      		rjmp .L34
 642               	.L30:
 401:daisycomm.c   ****     {
 402:daisycomm.c   ****     case DAISY_IDLE:
 403:daisycomm.c   **** 
 404:daisycomm.c   ****       if(upstreamRxDone)
 643               		.loc 1 404 0
 644 0284 8091 0000 		lds r24,upstreamRxDone
 645 0288 9091 0000 		lds r25,upstreamRxDone+1
 646 028c 0097      		sbiw r24,0
 647 028e 01F4      		brne .+2
 648 0290 00C0      		rjmp .L28
 405:daisycomm.c   ****     {
 406:daisycomm.c   ****       //A packet arrived from upstream.  Parse it and compute some sort of reply.
 407:daisycomm.c   ****       cli();
 649               		.loc 1 407 0
 650               	/* #APP */
 651               	 ;  407 "daisycomm.c" 1
 652 0292 F894      		cli
 653               	 ;  0 "" 2
 408:daisycomm.c   ****       upstreamRxDone = 0;
 654               		.loc 1 408 0
 655               	/* #NOAPP */
 656 0294 1092 0000 		sts upstreamRxDone,__zero_reg__
 657 0298 1092 0000 		sts upstreamRxDone+1,__zero_reg__
 409:daisycomm.c   ****       sei();
 658               		.loc 1 409 0
 659               	/* #APP */
 660               	 ;  409 "daisycomm.c" 1
 661 029c 7894      		sei
 662               	 ;  0 "" 2
 410:daisycomm.c   **** 
 411:daisycomm.c   ****       //A data packet has arrived from upstream.  Validate it
 412:daisycomm.c   ****       if(computeChecksum((uint8_t *)inbound_upstream_data,COMMAND_PACKET_SIZE) != 0x00)
 663               		.loc 1 412 0
 664               	/* #NOAPP */
 665 029e 80E0      		ldi r24,lo8(inbound_upstream_data)
 666 02a0 90E0      		ldi r25,hi8(inbound_upstream_data)
 667 02a2 67E0      		ldi r22,lo8(7)
 668 02a4 70E0      		ldi r23,hi8(7)
 669 02a6 0E94 0000 		call computeChecksum
 670 02aa 0097      		sbiw r24,0
 671 02ac 01F0      		breq .L32
 413:daisycomm.c   ****         {
 414:daisycomm.c   ****           //Invalid checksum
 415:daisycomm.c   ****           RxCheckSumErrCnt[0]++;
 672               		.loc 1 415 0
 673 02ae 8091 0000 		lds r24,RxCheckSumErrCnt
 674 02b2 9091 0000 		lds r25,RxCheckSumErrCnt+1
 675 02b6 0196      		adiw r24,1
 676 02b8 8093 0000 		sts RxCheckSumErrCnt,r24
 677 02bc 9093 0000 		sts RxCheckSumErrCnt+1,r25
 416:daisycomm.c   ****           outbound_upstream_data[0] = 3; //Packet size
 678               		.loc 1 416 0
 679 02c0 83E0      		ldi r24,lo8(3)
 680 02c2 8093 0000 		sts outbound_upstream_data,r24
 417:daisycomm.c   ****           outbound_upstream_data[1] = inbound_upstream_data[1]; //Reflected command byte
 681               		.loc 1 417 0
 682 02c6 8091 0000 		lds r24,inbound_upstream_data+1
 683 02ca 8093 0000 		sts outbound_upstream_data+1,r24
 418:daisycomm.c   ****           outbound_upstream_data[2] = CHECKSUM_ERROR; //Checksum error
 684               		.loc 1 418 0
 685 02ce C1E0      		ldi r28,lo8(1)
 686 02d0 C093 0000 		sts outbound_upstream_data+2,r28
 419:daisycomm.c   ****           outbound_upstream_data[3] = computeChecksum((uint8_t *)outbound_upstream_data,3); //check
 687               		.loc 1 419 0
 688 02d4 80E0      		ldi r24,lo8(outbound_upstream_data)
 689 02d6 90E0      		ldi r25,hi8(outbound_upstream_data)
 690 02d8 63E0      		ldi r22,lo8(3)
 691 02da 70E0      		ldi r23,hi8(3)
 692 02dc 0E94 0000 		call computeChecksum
 693 02e0 8093 0000 		sts outbound_upstream_data+3,r24
 420:daisycomm.c   ****           configureHalfDuplexLink(UPSTREAM,OUTBOUND);
 694               		.loc 1 420 0
 695 02e4 81E0      		ldi r24,lo8(1)
 696 02e6 0E94 0000 		call configureHalfDuplexLink.constprop.1
 421:daisycomm.c   ****         UPSTREAM_DIST_USART.CTRLA = USART_TXCINTLVL_OFF_gc;
 697               		.loc 1 421 0
 698 02ea E0EA      		ldi r30,lo8(2464)
 699 02ec F9E0      		ldi r31,hi8(2464)
 700 02ee 1382      		std Z+3,__zero_reg__
 422:daisycomm.c   ****         UPSTREAM_DIST_USART.DATA = outbound_upstream_data[0];
 701               		.loc 1 422 0
 702 02f0 8091 0000 		lds r24,outbound_upstream_data
 703 02f4 8093 A009 		sts 2464,r24
 704               	.LVL18:
 705               	.LBB25:
 706               	.LBB26:
 707               		.file 2 "/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../av
   1:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   6:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   9:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  12:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      distribution.
  16:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  17:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  21:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  33:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  35:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  38:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  41:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  42:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <math.h>
  45:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  46:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \file */
  47:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \code
  49:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \endcode
  53:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  54:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     used.
  58:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  59:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  68:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  77:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  81:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** */
  82:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  83:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  87:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  88:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  93:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  94:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  97:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  98:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #  include <math.h>
 102:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
 103:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 104:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /**
 105:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 107:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 109:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 112:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 114:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 120:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 125:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 129:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 132:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 140:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  */
 141:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** void
 142:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** {
 144:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 153:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 156:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 159:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#else
 160:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//round up by default
 161:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#endif
 163:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 164:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 165:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 166:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #else
 167:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks = 1;
 170:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	{
 172:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		while(__ticks)
 175:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		{
 176:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 			__ticks --;
 179:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		}
 180:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		return;
 181:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	}
 182:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	else
 183:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
 186:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** }
 187:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 188:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /**
 189:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 190:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 191:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 193:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 196:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 198:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    will not be informed about this case.
 201:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 202:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   
 207:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 211:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  
 214:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 218:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 222:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  */
 223:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** void
 224:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** _delay_us(double __us)
 225:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** {
 226:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 228:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 235:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 238:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 241:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#else
 242:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//round up by default
 243:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#endif
 245:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 246:/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 708               		.loc 2 246 0
 709 02f8 80E4      		 ldi r24,lo8(64)
 710 02fa 8A95      	    1:dec r24
 711 02fc 01F4      	    brne 1b
 712               	.LBE26:
 713               	.LBE25:
 423:daisycomm.c   ****           //_delay_us(10);
 424:daisycomm.c   ****           DELAY_ROUTINE();
 425:daisycomm.c   ****         UPSTREAM_DIST_USART.STATUS = USART_TXCIF_bm;
 714               		.loc 1 425 0
 715 02fe 80E4      		ldi r24,lo8(64)
 716 0300 8183      		std Z+1,r24
 426:daisycomm.c   ****         UPSTREAM_DIST_USART.CTRLA = USART_TXCINTLVL_LO_gc;
 717               		.loc 1 426 0
 718 0302 84E0      		ldi r24,lo8(4)
 719 0304 8383      		std Z+3,r24
 720               	.LVL19:
 721               	.LBB27:
 722               	.LBB28:
 327:daisycomm.c   ****     selectedChannel->TRFCNT = numBytes;
 723               		.loc 1 327 0
 724 0306 83E0      		ldi r24,lo8(3)
 725 0308 90E0      		ldi r25,hi8(3)
 726 030a E0E1      		ldi r30,lo8(272)
 727 030c F1E0      		ldi r31,hi8(272)
 728 030e 8483      		std Z+4,r24
 729 0310 9583      		std Z+5,r25
 330:daisycomm.c   ****     selectedChannel->CTRLA = DMA_CH_BURSTLEN_1BYTE_gc | DMA_CH_SINGLE_bm | DMA_CH_ENABLE_bm;
 730               		.loc 1 330 0
 731 0312 84E8      		ldi r24,lo8(-124)
 732 0314 8093 1001 		sts 272,r24
 733               	.LBE28:
 734               	.LBE27:
 427:daisycomm.c   ****           activateDMAChannel(&UPSTREAM_DMA,3);
 428:daisycomm.c   ****           daisyState = DAISY_TRANSMITTING;
 735               		.loc 1 428 0
 736 0318 C093 0000 		sts daisyState.3772,r28
 429:daisycomm.c   ****           break;
 737               		.loc 1 429 0
 738 031c 00C0      		rjmp .L28
 739               	.LVL20:
 740               	.L32:
 430:daisycomm.c   ****         }
 431:daisycomm.c   **** 
 432:daisycomm.c   ****       if(((inbound_upstream_data[0] & 0xF0) == 0xF0) || ((inbound_upstream_data[0] & 0x0F) == 0x00)
 741               		.loc 1 432 0
 742 031e 8091 0000 		lds r24,inbound_upstream_data
 743 0322 807F      		andi r24,lo8(-16)
 744 0324 803F      		cpi r24,lo8(-16)
 745 0326 01F0      		breq .L33
 746               		.loc 1 432 0 is_stmt 0 discriminator 1
 747 0328 8091 0000 		lds r24,inbound_upstream_data
 748 032c 90E0      		ldi r25,lo8(0)
 749 032e 8F70      		andi r24,lo8(15)
 750 0330 9070      		andi r25,hi8(15)
 751 0332 0097      		sbiw r24,0
 752 0334 01F4      		brne .L28
 753               	.L33:
 433:daisycomm.c   ****         {
 434:daisycomm.c   ****           //This packet should be responded to
 435:daisycomm.c   ****           packetSize = processCommand((uint8_t *)inbound_upstream_data,(uint8_t *)outbound_upstream
 754               		.loc 1 435 0 is_stmt 1
 755 0336 80E0      		ldi r24,lo8(inbound_upstream_data)
 756 0338 90E0      		ldi r25,hi8(inbound_upstream_data)
 757 033a 60E0      		ldi r22,lo8(outbound_upstream_data)
 758 033c 70E0      		ldi r23,hi8(outbound_upstream_data)
 759 033e 0E94 0000 		call processCommand
 760 0342 C82F      		mov r28,r24
 761               	.LVL21:
 436:daisycomm.c   **** 
 437:daisycomm.c   ****           //Assume the command processor handled the packetization
 438:daisycomm.c   ****           configureHalfDuplexLink(UPSTREAM,OUTBOUND);
 762               		.loc 1 438 0
 763 0344 81E0      		ldi r24,lo8(1)
 764               	.LVL22:
 765 0346 0E94 0000 		call configureHalfDuplexLink.constprop.1
 439:daisycomm.c   ****         UPSTREAM_DIST_USART.CTRLA = USART_TXCINTLVL_OFF_gc;
 766               		.loc 1 439 0
 767 034a E0EA      		ldi r30,lo8(2464)
 768 034c F9E0      		ldi r31,hi8(2464)
 769 034e 1382      		std Z+3,__zero_reg__
 440:daisycomm.c   ****         UPSTREAM_DIST_USART.DATA = outbound_upstream_data[0];
 770               		.loc 1 440 0
 771 0350 8091 0000 		lds r24,outbound_upstream_data
 772 0354 8093 A009 		sts 2464,r24
 773               	.LVL23:
 774               	.LBB29:
 775               	.LBB30:
 776               		.loc 2 246 0
 777 0358 80E4      		 ldi r24,lo8(64)
 778 035a 8A95      	    1:dec r24
 779 035c 01F4      	    brne 1b
 780               	.LBE30:
 781               	.LBE29:
 441:daisycomm.c   **** 
 442:daisycomm.c   ****           //_delay_us(10);
 443:daisycomm.c   ****           DELAY_ROUTINE();
 444:daisycomm.c   ****         UPSTREAM_DIST_USART.STATUS = USART_TXCIF_bm;
 782               		.loc 1 444 0
 783 035e 80E4      		ldi r24,lo8(64)
 784 0360 8183      		std Z+1,r24
 445:daisycomm.c   ****         UPSTREAM_DIST_USART.CTRLA = USART_TXCINTLVL_LO_gc;
 785               		.loc 1 445 0
 786 0362 84E0      		ldi r24,lo8(4)
 787 0364 8383      		std Z+3,r24
 788               	.LVL24:
 446:daisycomm.c   ****           activateDMAChannel(&UPSTREAM_DMA,packetSize-1);
 789               		.loc 1 446 0
 790 0366 8C2F      		mov r24,r28
 791 0368 90E0      		ldi r25,lo8(0)
 792 036a 0197      		sbiw r24,1
 793               	.LBB31:
 794               	.LBB32:
 327:daisycomm.c   ****     selectedChannel->TRFCNT = numBytes;
 795               		.loc 1 327 0
 796 036c E0E1      		ldi r30,lo8(272)
 797 036e F1E0      		ldi r31,hi8(272)
 798 0370 8483      		std Z+4,r24
 799 0372 9583      		std Z+5,r25
 330:daisycomm.c   ****     selectedChannel->CTRLA = DMA_CH_BURSTLEN_1BYTE_gc | DMA_CH_SINGLE_bm | DMA_CH_ENABLE_bm;
 800               		.loc 1 330 0
 801 0374 84E8      		ldi r24,lo8(-124)
 802 0376 8093 1001 		sts 272,r24
 803               	.LBE32:
 804               	.LBE31:
 447:daisycomm.c   ****           daisyState = DAISY_TRANSMITTING;
 805               		.loc 1 447 0
 806 037a 81E0      		ldi r24,lo8(1)
 807 037c 8093 0000 		sts daisyState.3772,r24
 808 0380 00C0      		rjmp .L28
 809               	.LVL25:
 810               	.L34:
 448:daisycomm.c   ****         }
 449:daisycomm.c   ****     }
 450:daisycomm.c   ****       break;
 451:daisycomm.c   **** 
 452:daisycomm.c   ****     case DAISY_TRANSMITTING:
 453:daisycomm.c   ****       //System is pushing data upstream, but it might be done
 454:daisycomm.c   ****       if(upstreamTxDone)
 811               		.loc 1 454 0
 812 0382 8091 0000 		lds r24,upstreamTxDone
 813 0386 9091 0000 		lds r25,upstreamTxDone+1
 814 038a 0097      		sbiw r24,0
 815 038c 01F0      		breq .L28
 455:daisycomm.c   ****     {
 456:daisycomm.c   ****       //The upstream transmitter is loaded with data (but possibly not done)
 457:daisycomm.c   **** 
 458:daisycomm.c   ****       cli();
 816               		.loc 1 458 0
 817               	/* #APP */
 818               	 ;  458 "daisycomm.c" 1
 819 038e F894      		cli
 820               	 ;  0 "" 2
 459:daisycomm.c   ****       upstreamTxDone = 0;
 821               		.loc 1 459 0
 822               	/* #NOAPP */
 823 0390 1092 0000 		sts upstreamTxDone,__zero_reg__
 824 0394 1092 0000 		sts upstreamTxDone+1,__zero_reg__
 460:daisycomm.c   ****       sei();
 825               		.loc 1 460 0
 826               	/* #APP */
 827               	 ;  460 "daisycomm.c" 1
 828 0398 7894      		sei
 829               	 ;  0 "" 2
 461:daisycomm.c   ****       daisyState = DAISY_IDLE;
 830               		.loc 1 461 0
 831               	/* #NOAPP */
 832 039a 1092 0000 		sts daisyState.3772,__zero_reg__
 462:daisycomm.c   **** 
 463:daisycomm.c   ****       configureHalfDuplexLink(UPSTREAM,INBOUND);
 833               		.loc 1 463 0
 834 039e 80E0      		ldi r24,lo8(0)
 835 03a0 0E94 0000 		call configureHalfDuplexLink.constprop.1
 836               	.L28:
 837               	/* epilogue start */
 464:daisycomm.c   ****     }
 465:daisycomm.c   ****       break;
 466:daisycomm.c   **** 
 467:daisycomm.c   ****     default:
 468:daisycomm.c   ****       break;
 469:daisycomm.c   ****     }
 470:daisycomm.c   **** }
 838               		.loc 1 470 0
 839 03a4 CF91      		pop r28
 840 03a6 0895      		ret
 841               		.cfi_endproc
 842               	.LFE15:
 844               	.global	RxCheckSumErrCnt
 845               	.global	RxCheckSumErrCnt
 846               		.section .bss
 849               	RxCheckSumErrCnt:
 850 0000 0000 0000 		.skip 4,0
 851               		.lcomm upstreamBusy,1
 852               		.lcomm upstreamTxDone,2
 853               		.lcomm upstreamRxDone,2
 854               		.lcomm UPSTREAM_CONFIG,1
 855               		.lcomm outbound_upstream_data,200
 856               		.lcomm inbound_upstream_data,7
 857               	.global	notifyDaisy
 858               	.global	notifyDaisy
 861               	notifyDaisy:
 862 0004 00        		.skip 1,0
 863               		.lcomm daisyState.3772,1
 864               		.text
 865               	.Letext0:
 866               		.file 3 "/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../av
 867               		.file 4 "/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../av
 868               		.file 5 "../common/daisycomm.h"
DEFINED SYMBOLS
                            *ABS*:00000000 daisycomm.c
     /tmp/ccJFVxxi.s:2      *ABS*:0000003f __SREG__
     /tmp/ccJFVxxi.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccJFVxxi.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccJFVxxi.s:5      *ABS*:00000034 __CCP__
     /tmp/ccJFVxxi.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccJFVxxi.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccJFVxxi.s:14     .text:00000000 prepareDMAChannel.constprop.0
     /tmp/ccJFVxxi.s:105    .text:0000005e configureHalfDuplexLink.constprop.1
     /tmp/ccJFVxxi.s:852    .bss:00000008 upstreamRxDone
                             .bss:00000005 upstreamBusy
     /tmp/ccJFVxxi.s:855    .bss:000000d3 inbound_upstream_data
     /tmp/ccJFVxxi.s:853    .bss:0000000a UPSTREAM_CONFIG
     /tmp/ccJFVxxi.s:854    .bss:0000000b outbound_upstream_data
     /tmp/ccJFVxxi.s:199    .text:000000ca __vector_14
     /tmp/ccJFVxxi.s:353    .text:00000172 __vector_6
     /tmp/ccJFVxxi.s:861    .bss:00000004 notifyDaisy
     /tmp/ccJFVxxi.s:429    .text:000001c8 __vector_90
     /tmp/ccJFVxxi.s:851    .bss:00000006 upstreamTxDone
     /tmp/ccJFVxxi.s:497    .text:0000020c computeChecksum
     /tmp/ccJFVxxi.s:547    .text:0000022e configureDaisyUSART
     /tmp/ccJFVxxi.s:608    .text:0000026a doDaisyTask
     /tmp/ccJFVxxi.s:856    .bss:000000da daisyState.3772
     /tmp/ccJFVxxi.s:849    .bss:00000000 RxCheckSumErrCnt

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
processCommand
