   1               		.file	"accel.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  14               	writeRegisterSPI:
  15               	.LFB7:
  16               		.file 1 "accel.c"
   1:accel.c       **** /****************************************************
   2:accel.c       **** 
   3:accel.c       ****  // Author:            Zachary Clifford
   4:accel.c       ****  // File Name:        C1482-SRC-PXDMCU-0_tactsense.c
   5:accel.c       ****  // Creation Date:    5 March, 2012
   6:accel.c       ****  // Revision:        00
   7:accel.c       ****  // Hardware:        ATxmega32A4U
   8:accel.c       ****  // Description:    Accelerometer sensor driver
   9:accel.c       **** 
  10:accel.c       **** ****************************************************/
  11:accel.c       **** 
  12:accel.c       **** /******************************************************************************
  13:accel.c       ****     File Revision History:
  14:accel.c       **** -------------------------------------------------------------------------------
  15:accel.c       **** Revision    Date        Engineer    Description
  16:accel.c       **** --------    --------    --------    -------------------------------------------
  17:accel.c       **** 00            MM/DD/YY    ZAC            Initial Release
  18:accel.c       **** -------------------------------------------------------------------------------
  19:accel.c       **** 
  20:accel.c       **** ******************************************************************************/
  21:accel.c       **** 
  22:accel.c       **** #include <avr/io.h>
  23:accel.c       **** #include "accel.h"
  24:accel.c       **** #include "distal.h"
  25:accel.c       **** 
  26:accel.c       **** //The system can take 5 MHz.  Peripheral clock is set to 32 MHz internally, so a divide by 8 presca
  27:accel.c       **** //In this chip, the division is accomplished by a divide by 16 with a doubler
  28:accel.c       **** 
  29:accel.c       **** #define ACCELSPI SPID
  30:accel.c       **** #define ACCELSPI_PORT PORTD
  31:accel.c       **** #define ACCEL_CS_PORT PORTE     // chip select
  32:accel.c       **** #define ACCEL_CS_PIN_MASK 0x08  // chip select pin
  33:accel.c       **** 
  34:accel.c       **** static void writeRegisterSPI(uint8_t addr, uint8_t data);
  35:accel.c       **** 
  36:accel.c       **** void configureSPIModulesAccel(void)
  37:accel.c       **** {
  38:accel.c       ****   ACCEL_CS_PORT.OUTSET = ACCEL_CS_PIN_MASK; // default chip select to high
  39:accel.c       ****   ACCEL_CS_PORT.DIRSET = ACCEL_CS_PIN_MASK; // make sure it is an output
  40:accel.c       ****   ACCELSPI_PORT.DIRCLR = 0x40;
  41:accel.c       ****   ACCELSPI_PORT.DIRSET = 0xB0;
  42:accel.c       ****   ACCELSPI_PORT.OUTSET = 0x10;
  43:accel.c       ****   ACCELSPI.INTCTRL = SPI_INTLVL_OFF_gc;
  44:accel.c       ****   ACCELSPI.CTRL = SPI_ENABLE_bm | SPI_MASTER_bm | SPI_MODE_3_gc | SPI_PRESCALER_DIV16_gc | SPI_CLK2
  45:accel.c       **** }
  46:accel.c       **** 
  47:accel.c       **** /*
  48:accel.c       ****  * Abstraction Function for ReadWriting Registers On The Accelerometer
  49:accel.c       ****  */
  50:accel.c       **** static void writeRegisterSPI(uint8_t addr, uint8_t data)
  51:accel.c       **** {
  17               		.loc 1 51 0
  18               		.cfi_startproc
  19               	.LVL0:
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 0 */
  23               	.L__stack_usage = 0
  52:accel.c       ****   uint8_t dummy;
  53:accel.c       ****   ACCEL_CS_PORT.OUTCLR = ACCEL_CS_PIN_MASK; // chip select
  24               		.loc 1 53 0
  25 0000 98E0      		ldi r25,lo8(8)
  26 0002 E0E8      		ldi r30,lo8(1664)
  27 0004 F6E0      		ldi r31,hi8(1664)
  28 0006 9683      		std Z+6,r25
  54:accel.c       **** 
  55:accel.c       ****   //ADDR should be 5 bits in length.  Bit 6 should be low for single write
  56:accel.c       ****   //bit 7 should be low to indicate WRITE
  57:accel.c       ****   ACCELSPI.DATA = addr;
  29               		.loc 1 57 0
  30 0008 E0EC      		ldi r30,lo8(2496)
  31 000a F9E0      		ldi r31,hi8(2496)
  32 000c 8383      		std Z+3,r24
  58:accel.c       ****   while(!(ACCELSPI.STATUS & SPI_IF_bm)) {
  33               		.loc 1 58 0
  34 000e 00C0      		rjmp .L2
  35               	.LVL1:
  36               	.L3:
  59:accel.c       ****     dummy = ACCELSPI.DATA; } //wait for it to finish
  37               		.loc 1 59 0
  38 0010 8091 C309 		lds r24,2499
  39               	.L2:
  58:accel.c       ****   while(!(ACCELSPI.STATUS & SPI_IF_bm)) {
  40               		.loc 1 58 0 discriminator 1
  41 0014 8091 C209 		lds r24,2498
  42 0018 87FF      		sbrs r24,7
  43 001a 00C0      		rjmp .L3
  60:accel.c       **** 
  61:accel.c       ****   // the dummy read is needed for the SPI_IF flag to clear
  62:accel.c       **** 
  63:accel.c       ****   ACCELSPI.DATA = data;
  44               		.loc 1 63 0
  45 001c E0EC      		ldi r30,lo8(2496)
  46 001e F9E0      		ldi r31,hi8(2496)
  47 0020 6383      		std Z+3,r22
  64:accel.c       ****   while(!(ACCELSPI.STATUS & SPI_IF_bm)) {
  48               		.loc 1 64 0
  49 0022 00C0      		rjmp .L4
  50               	.L5:
  65:accel.c       ****     dummy = ACCELSPI.DATA; } //wait for it to finish
  51               		.loc 1 65 0
  52 0024 8091 C309 		lds r24,2499
  53               	.L4:
  64:accel.c       ****   while(!(ACCELSPI.STATUS & SPI_IF_bm)) {
  54               		.loc 1 64 0 discriminator 1
  55 0028 8091 C209 		lds r24,2498
  56 002c 87FF      		sbrs r24,7
  57 002e 00C0      		rjmp .L5
  66:accel.c       **** 
  67:accel.c       ****   ACCEL_CS_PORT.OUTSET = ACCEL_CS_PIN_MASK; // chip select
  58               		.loc 1 67 0
  59 0030 88E0      		ldi r24,lo8(8)
  60 0032 E0E8      		ldi r30,lo8(1664)
  61 0034 F6E0      		ldi r31,hi8(1664)
  62               	.LVL2:
  63 0036 8583      		std Z+5,r24
  64               	/* epilogue start */
  68:accel.c       ****   return;
  69:accel.c       **** }
  65               		.loc 1 69 0
  66 0038 0895      		ret
  67               		.cfi_endproc
  68               	.LFE7:
  70               	.global	configureSPIModulesAccel
  72               	configureSPIModulesAccel:
  73               	.LFB6:
  37:accel.c       **** {
  74               		.loc 1 37 0
  75               		.cfi_startproc
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 0 */
  79               	.L__stack_usage = 0
  38:accel.c       ****   ACCEL_CS_PORT.OUTSET = ACCEL_CS_PIN_MASK; // default chip select to high
  80               		.loc 1 38 0
  81 003a E0E8      		ldi r30,lo8(1664)
  82 003c F6E0      		ldi r31,hi8(1664)
  83 003e 88E0      		ldi r24,lo8(8)
  84 0040 8583      		std Z+5,r24
  39:accel.c       ****   ACCEL_CS_PORT.DIRSET = ACCEL_CS_PIN_MASK; // make sure it is an output
  85               		.loc 1 39 0
  86 0042 8183      		std Z+1,r24
  40:accel.c       ****   ACCELSPI_PORT.DIRCLR = 0x40;
  87               		.loc 1 40 0
  88 0044 E0E6      		ldi r30,lo8(1632)
  89 0046 F6E0      		ldi r31,hi8(1632)
  90 0048 80E4      		ldi r24,lo8(64)
  91 004a 8283      		std Z+2,r24
  41:accel.c       ****   ACCELSPI_PORT.DIRSET = 0xB0;
  92               		.loc 1 41 0
  93 004c 80EB      		ldi r24,lo8(-80)
  94 004e 8183      		std Z+1,r24
  42:accel.c       ****   ACCELSPI_PORT.OUTSET = 0x10;
  95               		.loc 1 42 0
  96 0050 80E1      		ldi r24,lo8(16)
  97 0052 8583      		std Z+5,r24
  43:accel.c       ****   ACCELSPI.INTCTRL = SPI_INTLVL_OFF_gc;
  98               		.loc 1 43 0
  99 0054 E0EC      		ldi r30,lo8(2496)
 100 0056 F9E0      		ldi r31,hi8(2496)
 101 0058 1182      		std Z+1,__zero_reg__
  44:accel.c       ****   ACCELSPI.CTRL = SPI_ENABLE_bm | SPI_MASTER_bm | SPI_MODE_3_gc | SPI_PRESCALER_DIV16_gc | SPI_CLK2
 102               		.loc 1 44 0
 103 005a 8DED      		ldi r24,lo8(-35)
 104 005c 8083      		st Z,r24
 105               	/* epilogue start */
  45:accel.c       **** }
 106               		.loc 1 45 0
 107 005e 0895      		ret
 108               		.cfi_endproc
 109               	.LFE6:
 111               	.global	configAccel
 113               	configAccel:
 114               	.LFB8:
  70:accel.c       **** 
  71:accel.c       **** /*
  72:accel.c       ****  * Configure ADXL345 Accelerometer for 16G Measurement Mode
  73:accel.c       **** 
  74:accel.c       ****  called once in main
  75:accel.c       ****  */
  76:accel.c       **** void configAccel(void)
  77:accel.c       **** {
 115               		.loc 1 77 0
 116               		.cfi_startproc
 117               	/* prologue: function */
 118               	/* frame size = 0 */
 119               	/* stack size = 0 */
 120               	.L__stack_usage = 0
  78:accel.c       ****     writeRegisterSPI(0x2D, 0x08); //switch from standby to measuring
 121               		.loc 1 78 0
 122 0060 8DE2      		ldi r24,lo8(45)
 123 0062 68E0      		ldi r22,lo8(8)
 124 0064 0E94 0000 		call writeRegisterSPI
  79:accel.c       ****     writeRegisterSPI(0x31, 0x0F); //set to fullscale, full resolution
 125               		.loc 1 79 0
 126 0068 81E3      		ldi r24,lo8(49)
 127 006a 6FE0      		ldi r22,lo8(15)
 128 006c 0E94 0000 		call writeRegisterSPI
 129               	/* epilogue start */
  80:accel.c       **** }
 130               		.loc 1 80 0
 131 0070 0895      		ret
 132               		.cfi_endproc
 133               	.LFE8:
 135               	.global	readAxes
 137               	readAxes:
 138               	.LFB9:
  81:accel.c       **** 
  82:accel.c       **** /*
  83:accel.c       ****  * Clockout Six Databytes From ADXL345, Two Bytes Per Axis
  84:accel.c       ****  */
  85:accel.c       **** void readAxes(uint8_t *dataOut)
  86:accel.c       **** {
 139               		.loc 1 86 0
 140               		.cfi_startproc
 141               	.LVL3:
 142 0072 CF93      		push r28
 143               	.LCFI0:
 144               		.cfi_def_cfa_offset 3
 145               		.cfi_offset 28, -2
 146 0074 DF93      		push r29
 147               	.LCFI1:
 148               		.cfi_def_cfa_offset 4
 149               		.cfi_offset 29, -3
 150 0076 00D0      		rcall .
 151               	.LCFI2:
 152               		.cfi_def_cfa_offset 6
 153 0078 CDB7      		in r28,__SP_L__
 154 007a DEB7      		in r29,__SP_H__
 155               	.LCFI3:
 156               		.cfi_def_cfa_register 28
 157               	/* prologue: function */
 158               	/* frame size = 2 */
 159               	/* stack size = 4 */
 160               	.L__stack_usage = 4
  87:accel.c       ****     configureSPIModulesAccel();
 161               		.loc 1 87 0
 162 007c 8983      		std Y+1,r24
 163 007e 9A83      		std Y+2,r25
 164 0080 0E94 0000 		call configureSPIModulesAccel
 165               	.LVL4:
  88:accel.c       ****     ACCEL_CS_PORT.OUTCLR = ACCEL_CS_PIN_MASK;
 166               		.loc 1 88 0
 167 0084 28E0      		ldi r18,lo8(8)
 168 0086 E0E8      		ldi r30,lo8(1664)
 169 0088 F6E0      		ldi r31,hi8(1664)
 170 008a 2683      		std Z+6,r18
  89:accel.c       **** 
  90:accel.c       ****     ACCELSPI.DATA = (0x32 | 0xC0); //start at the x axis register, addr 0x32, set multibyte read wi
 171               		.loc 1 90 0
 172 008c 22EF      		ldi r18,lo8(-14)
 173 008e E0EC      		ldi r30,lo8(2496)
 174 0090 F9E0      		ldi r31,hi8(2496)
 175 0092 2383      		std Z+3,r18
 176 0094 9A81      		ldd r25,Y+2
 177 0096 8981      		ldd r24,Y+1
 178               	.L9:
  91:accel.c       ****     while(!(ACCELSPI.STATUS & SPI_IF_bm)); //wait for it to finish
 179               		.loc 1 91 0 discriminator 1
 180 0098 2091 C209 		lds r18,2498
 181 009c 27FF      		sbrs r18,7
 182 009e 00C0      		rjmp .L9
 183               		.loc 1 91 0 is_stmt 0
 184 00a0 FC01      		movw r30,r24
 185 00a2 86E0      		ldi r24,lo8(6)
 186               	.LBB2:
  92:accel.c       **** 
  93:accel.c       ****     for (uint8_t i = 0; i < 6; i++)
  94:accel.c       ****     {
  95:accel.c       ****         ACCELSPI.DATA = 0x00; //clockout
 187               		.loc 1 95 0 is_stmt 1
 188 00a4 A0EC      		ldi r26,lo8(2496)
 189 00a6 B9E0      		ldi r27,hi8(2496)
 190               	.L11:
 191 00a8 1396      		adiw r26,3
 192 00aa 1C92      		st X,__zero_reg__
 193 00ac 1397      		sbiw r26,3
 194               	.L10:
  96:accel.c       ****         while(!(ACCELSPI.STATUS & SPI_IF_bm)); //wait for clockout to finish
 195               		.loc 1 96 0 discriminator 1
 196 00ae 9091 C209 		lds r25,2498
 197 00b2 97FF      		sbrs r25,7
 198 00b4 00C0      		rjmp .L10
  97:accel.c       ****         dataOut[i] = ACCELSPI.DATA; //store
 199               		.loc 1 97 0
 200 00b6 9091 C309 		lds r25,2499
 201 00ba 9193      		st Z+,r25
 202 00bc 8150      		subi r24,lo8(-(-1))
  93:accel.c       ****     for (uint8_t i = 0; i < 6; i++)
 203               		.loc 1 93 0
 204 00be 01F4      		brne .L11
 205               	.LBE2:
  98:accel.c       ****     }
  99:accel.c       **** 
 100:accel.c       ****     ACCEL_CS_PORT.OUTSET = ACCEL_CS_PIN_MASK;
 206               		.loc 1 100 0
 207 00c0 88E0      		ldi r24,lo8(8)
 208 00c2 E0E8      		ldi r30,lo8(1664)
 209 00c4 F6E0      		ldi r31,hi8(1664)
 210 00c6 8583      		std Z+5,r24
 211               	/* epilogue start */
 101:accel.c       ****     return;
 102:accel.c       **** }
 212               		.loc 1 102 0
 213 00c8 0F90      		pop __tmp_reg__
 214 00ca 0F90      		pop __tmp_reg__
 215 00cc DF91      		pop r29
 216 00ce CF91      		pop r28
 217 00d0 0895      		ret
 218               		.cfi_endproc
 219               	.LFE9:
 221               	.Letext0:
 222               		.file 2 "/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../av
 223               		.file 3 "/home/baxelrod/ARM-H/avr8-gnu-toolchain-linux_x86/bin/../lib/gcc/avr/4.6.2/../../../../av
DEFINED SYMBOLS
                            *ABS*:00000000 accel.c
     /tmp/ccBmzmme.s:2      *ABS*:0000003f __SREG__
     /tmp/ccBmzmme.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccBmzmme.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccBmzmme.s:5      *ABS*:00000034 __CCP__
     /tmp/ccBmzmme.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccBmzmme.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccBmzmme.s:14     .text:00000000 writeRegisterSPI
     /tmp/ccBmzmme.s:72     .text:0000003a configureSPIModulesAccel
     /tmp/ccBmzmme.s:113    .text:00000060 configAccel
     /tmp/ccBmzmme.s:137    .text:00000072 readAxes

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
