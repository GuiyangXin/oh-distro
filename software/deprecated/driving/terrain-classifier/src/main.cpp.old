#include <stdio.h>
#include <unistd.h>
#include <opencv/cv.h>
#include <opencv/highgui.h>
#include <getopt.h>
#include <bot_core/bot_core.h>
#include <bot_frames/bot_frames.h>
#include <vector>
#include <opencv2/nonfree/features2d.hpp>
#include <perception_opencv_utils/opencv_utils.hpp>
#include <ConciseArgs>

using namespace std;

struct RoadDetectorOptions { 
  bool vDEBUG;
  std::string vCHANNEL;
  RoadDetectorOptions () : 
    vCHANNEL(std::string("CAMERALEFT")), vDEBUG(false) {}
};


/*typedef struct _state_t state_t;

  struct _state_t {
  lcm_t *lcm;
  GMainLoop *mainloop;
  BotFrames *frames; 
  BotParam *param;
  GMutex *mutex;
  pthread_t  process_thread;
  int verbose;
  //do we add these to a queue??
  };*/

class Terrain{
public:
  lcm_t *lcm;
  GMainLoop *mainloop;
  BotFrames *frames; 
  BotParam *param;
  GMutex *mutex;
  RoadDetectorOptions options;
  pthread_t  process_thread;
  int verbose;
  //do we add these to a queue??
  vector<bot_core_image_t *> image_list;
  bot_core_image_t *last_image;
  opencv_utils::DisplayWrapper dp;
};

/*
 * Creates an opencv image header for a carmen3d_image_t structure
 * FYI: THIS FUNCTION DOES NOT COPY THE DATA!
 */
/*static inline CvMat get_opencv_header_for_bot_core_image_t(const bot_core_image_t * c3d_im)
{
  if (c3d_im->pixelformat == BOT_CORE_IMAGE_T_PIXEL_FORMAT_BGR || c3d_im->pixelformat
      == BOT_CORE_IMAGE_T_PIXEL_FORMAT_RGB) {
    return cvMat(c3d_im->height, c3d_im->width, CV_8UC3, c3d_im->data);
  }
  else if (c3d_im->pixelformat == BOT_CORE_IMAGE_T_PIXEL_FORMAT_GRAY) {
    return cvMat(c3d_im->height, c3d_im->width, CV_8UC1, c3d_im->data);
  }
  else if (c3d_im->pixelformat == BOT_CORE_IMAGE_T_PIXEL_FORMAT_FLOAT_GRAY32) {
    return cvMat(c3d_im->height, c3d_im->width, CV_32FC1, c3d_im->data);
  }
  else {
    fprintf(stderr, "ERROR: invalid bot_core_image_t pixel format!\n");
    assert(false);
    return cvMat(0, 0, 0, NULL); //make compiler happy
  }
}*/


void on_image(const lcm_recv_buf_t *rbuf, const char * channel, const bot_core_image_t * msg, void * user) {  
  Terrain *self = (Terrain *) user;
  fprintf(stderr, "Image received\n");
  g_mutex_lock(self->mutex);
  //self->image_list.push_back(bot_core_image_t_copy(msg));
  self->last_image = bot_core_image_t_copy(msg);
  g_mutex_unlock(self->mutex);
}

void sift_extractor(bot_core_image_t *bc_img){
    fprintf(stderr, "Extracting Sift\n");
    
    IplImage* img;

    static bot_core_image_t * localFrame=(bot_core_image_t *) calloc(1,sizeof(bot_core_image_t));
    const bot_core_image_t * newFrame=NULL;
    if (bc_img->pixelformat==BOT_CORE_IMAGE_T_PIXEL_FORMAT_MJPEG){
        //create space for decompressed image
      //envoy_decompress_bot_core_image_t(s->received_image,localFrame);
      return;
        //copy pointer for working locally
        newFrame = localFrame;
    }
    else{
        //uncompressed, just copy pointer
        newFrame = bc_img;
    }  
    

    //better copy this - otherwise will crash stuff
    CvMat cvImg = opencv_utils::get_opencv_header_for_bot_core_image_t(newFrame);

    CvMat *frame = &cvImg;//NULL;
    //Copy(&cvImg,frame);

    static IplImage tmpHeader;
    IplImage * currentFrame;

    currentFrame = cvGetImage(frame,&tmpHeader);

    const cv::Mat input = cv::Mat(currentFrame, false);

    //cv::SiftFeatureDetector detector;
    //cv::StarFeatureDetector detector;
    //cv::FastFeatureDetector detector;
    cv::SurfFeatureDetector surf_detector;
    std::vector<cv::KeyPoint> surf_keypoints;
    surf_detector.detect(input, surf_keypoints);

    // Add results to image and save.
    cv::Mat surf_output;
    cv::drawKeypoints(input, surf_keypoints, surf_output);
    cv::imwrite("surf_result.jpg", surf_output);

    cv::StarFeatureDetector star_detector;
    std::vector<cv::KeyPoint> star_keypoints;
    star_detector.detect(input, star_keypoints);

    // Add results to image and save.
    cv::Mat star_output;
    cv::drawKeypoints(input, star_keypoints, star_output);
    cv::imwrite("star_result.jpg", star_output);

    cv::SiftFeatureDetector sift_detector;
    std::vector<cv::KeyPoint> sift_keypoints;
    sift_detector.detect(input, sift_keypoints);

    // Add results to image and save.
    cv::Mat sift_output;
    cv::drawKeypoints(input, sift_keypoints, sift_output);
    cv::imwrite("sift_result.jpg", sift_output);
}

/*
bool
HistogramTracker::initialize(const cv::Mat& img, const cv::Mat& mask) {
  
  hue_info = HistogramInfo();
  val_info = HistogramInfo();
  sat_info = HistogramInfo();
  object_roi = cv::Mat();
  internal_init();

    // Compute mask roi for debug
    if (!computeMaskROI(img, mask, pred_win)) 
        return false;

    // Convert to HSV space
    cv::Mat hsv; 
    cvtColor(img, hsv, CV_BGR2HSV);

    std::vector<cv::Mat> channels;
    cv::split(hsv, channels);
    assert(channels.size() == 3);
    cv::Mat hue = channels[0]; 
    cv::Mat val = channels[1];
    cv::Mat sat = channels[2];
    // std::cerr << "hue: " << hue << std::endl;

    // Calculate Histogram
    calcHist(&hue, 1, 0, mask, hue_info.histogram, 1, &hue_info.size, &hue_info.pranges); 
    calcHist(&val, 1, 0, mask, val_info.histogram, 1, &val_info.size, &val_info.pranges); 
    calcHist(&sat, 1, 0, mask, sat_info.histogram, 1, &sat_info.size, &sat_info.pranges); 

    // std::cerr << "hue hist: " << hue_info.histogram << " " << std::endl;
    // std::cerr << "val hist: " << val_info.histogram << " " << std::endl;

    normalize(hue_info.histogram, hue_info.histogram, 0, 1, CV_MINMAX);
    normalize(val_info.histogram, val_info.histogram, 0, 1, CV_MINMAX);
    normalize(sat_info.histogram, sat_info.histogram, 0, 1, CV_MINMAX);

    // Compute unimodal histogram
    hue_info.computeUnimodalHistogram();
    val_info.computeUnimodalHistogram();
    sat_info.computeUnimodalHistogram();

    // Create debug histograms
    hue_info.createHistogramImage();
    val_info.createHistogramImage();
    sat_info.createHistogramImage();

    // cv::Mat display = img.clone();
    // showHistogramInfo(display);

    // cv::imshow("Initialize Histogram Tracker", display);
    mask_initialized_ = true;

    // Once mask is inialized, find the 
    std::cerr << "Initialized: Prediction window " << pred_win.tl() << "->" << pred_win.br() << std::endl;

    return true;
}


 */


int detect_road(Terrain *self, bot_core_image_t *img){
  //doing nothing for now 
  if(img->pixelformat == BOT_CORE_IMAGE_T_PIXEL_FORMAT_MJPEG){
    fprintf(stderr,"JPEG - Skipping for now\n");
    return -1;
  }

  //better copy this - otherwise will crash stuff
  int64_t stime = bot_timestamp_now();
  CvMat cvImg = opencv_utils::get_opencv_header_for_bot_core_image_t(img);
  
  static IplImage tmpHeader;
  IplImage * currentFrame;
  CvMat *frame = &cvImg;
  currentFrame = cvGetImage(frame,&tmpHeader);
  
  const cv::Mat input = cv::Mat(currentFrame, false);

  //  Mat mtx(img);
  //void cvtColor(const Mat& src, Mat& dst, int code, int dstCn=0)
  cv::Mat bgr_mat(img->height,img->width,CV_8UC3);
  cvtColor(input, bgr_mat, CV_RGB2BGR);

  cv::Mat hsv_mat(img->height,img->width,CV_8UC3);
  cvtColor(input, hsv_mat, CV_RGB2HSV);
  int64_t etime = bot_timestamp_now();
  fprintf(stderr, "Time taken : %f\n", (etime-stime)/1.0e6);
  opencv_utils::DisplayFrame disp("Test", &cvImg, img->width);
  disp.display();
  self->dp.display("RGB", &cvImg, img->width);

  return 0;
}

static void *p_thread(void *user)
{
  Terrain * self = (Terrain *) user;

  int status = 0;
  while(1){
    g_mutex_lock(self->mutex);
    if(!self->last_image){
       usleep(100);
       g_mutex_unlock(self->mutex);
    }
    else{
      bot_core_image_t *img = self->last_image;
      self->last_image = NULL;
      g_mutex_unlock(self->mutex);
      int status = detect_road(self, img);
      //process the last one??
      //fprintf(stderr, "Buffer size : %d\n", self->image_list.size());
    }

    /*if(self->image_list.size() == 0){
       usleep(5000);
    }
    else{
      //process the last one??
      //fprintf(stderr, "Buffer size : %d\n", self->image_list.size());
      }*/
    /*if(s->processed){
     
      }
      else{
      int status = detect_objects(s);
      g_mutex_lock(s->mutex);
      s->processed = 1;
      g_mutex_unlock(s->mutex);
      }*/
  }
}

int main(int argc, char **argv)
{
  g_thread_init(NULL);
  setlinebuf (stdout);

  Terrain *state = new Terrain();

  state->lcm =  bot_lcm_get_global(NULL);
  state->last_image = NULL;
  state->param = bot_param_new_from_server(state->lcm, 1);
  state->frames = bot_frames_get_global (state->lcm, state->param);

  state->mutex = g_mutex_new();

  state->mainloop = g_main_loop_new( NULL, FALSE );  
    
  fprintf(stderr, "Setting the segment first method - this one works best\n");

  ConciseArgs opt(argc, (char**)argv);
  opt.add(options.vCHANNEL, "c", "camera-channel","Camera Channel [CAMERALEFT]");
  opt.add(state->options.vDEBUG, "d", "debug","Debug mode");
  opt.parse();

  /*const char *optstring = "vhcfsdb";
  struct option long_opts[] = { { "help", no_argument, 0, 'h' },
				{ "verbose", no_argument, 0, 'v' }, 
				{ 0, 0, 0, 0 } };

  int c;
  while ((c = getopt_long(argc, argv, optstring, long_opts, 0)) >= 0) {
    switch (c) {
    case 'h':
      //usage(argv[0]);
      fprintf(stderr, "No help found - please add help\n");
      break;
    case 'v':
      {
	fprintf(stderr,"Verbose\n");
	state->verbose = 1;
	break;
      }
    }
    }*/
  
  if (!state->mainloop){
    printf("Couldn't create main loop\n");
    return -1;
  }

  //add lcm to mainloop 
  bot_glib_mainloop_attach_lcm (state->lcm);

  bot_core_image_t_subscribe(state->lcm, "CAMERALEFT", on_image, state);
  
  pthread_create(&state->process_thread , NULL, p_thread, state);

  state->dp.start();
    
  /* heart beat*/
  //g_timeout_add (100, heartbeat_cb, state);
    
  //adding proper exiting 
  bot_signal_pipe_glib_quit_on_kill (state->mainloop);
    
  fprintf(stderr, "Starting Main Loop\n");

  ///////////////////////////////////////////////
  g_main_loop_run(state->mainloop);
    
  bot_glib_mainloop_detach_lcm(state->lcm);
}

