#Calibration for the sensors on the HANDLE hand
#
# NOTE: In general, the order of the arrays is: [F0, F1, F2, F2 Ant., Spread].
# Where: F0 is analogous to your right index finger, F1 is analogous to your 
# middle finger, F2 is analogous to your thumb, F2 Ant. is the antagonistic 
# motor for F2, and Spread is the motor which controls the rotation of F0 and
# F1.

# Note there are 12 proximal and 10 distal sensors.
#Finger[3] fingerTactile
# calibration consists of a zero offset for each sensor
# these return unitless values
Tactile:
    proximal : [700,700,700,700,700,700,700,700,700,700,700,700]
    distal   : [700,700,700,700,700,700,700,700,700,700]

# The proximal joint angle.  Approx 2.84 ticks per degree.
# int32[3] proximalJointAngle
# zero is in degrees - to make it easier to adjust
# zero visually angle from horisontal plane
# tics_per_radian : 162.815507

proximalJointAngle:
    tics_per_degree : 2.84
    zero            : 0

# The finger distal joint flexture angle
# Note there are 4 readings on either side of the joint, for a total of 8
# each pair of readings is converted to a ratio of difference to sum to reduce sensitivity to intensity
# Finger[3] distalJointAngle
#
# the raw readings are converted to flex and twist as follows:
# 
# ratio[0]:a0 * (sensor[0] - sensor[1]) / (sensor[0] + sensor[1]) + b0
# ...
# flex[0]: kflex * (ratio[0] + ratio[1])    # hopefully we can remove this since it should theoretically be consistent across fingers
# twist[0]:ktwist * (ratio[0] - ratio[1])	# currently not implemented

distalJointAngle:
    k_motor_enc    : 0.000424
    motor_enc_zero : -1106.966158
    k_pin_enc      : 2128.714798
    0 : {a: 0.566776, ktwist: 0.5, b: 0.298663, kflex: 0.5}
    1 : {a: 0.819015, ktwist: 0.5, b: -0.073142, kflex: 0.5}
    2 : {a: 0.833997, ktwist: 0.5, b: 0.264967, kflex: 0.5}
    3 : {a: 0.408867, ktwist: 0.5, b: 0.344963, kflex: 0.5}
