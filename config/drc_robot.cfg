kmcl {
  nparticles=400;
  resample_threshold=0.5;
  rng_seed=0;
  decimate_factor=32;
  # frequency at which entire frame is skipped. process X of every frames. [only using in lcm so far
  frame_skip=3;
  # frequency at which likelihood evaluaton is skipped. process X of every frames
  lhood_skip=1;
  # note thate this is compounded on the frames_skip


  # known height pitch and roll of sensor - for 2D motion. meters, degrees, degrees
  # ignored is you set [-1, -1, -1]
  #height_pitch_roll=[1.3,0,0];  # trolley
  #height_pitch_roll=[0.34,0,0]; # irobot
  height_pitch_roll=[1.14,0,0]; # wheelchair

  # likelihood function params:
  # higher sigma: slower, less critical resampling
  # higher proportion means slower resampling
  # certain - was:
  #sigma=0.025;
  #floor_proportion=0.999;

  # more certain - works will with medium noise dynamics:
  #sigma=0.03;
  #floor_proportion=0.9996;

  # works will with low noise dynamics:
  sigma=0.025;
  floor_proportion=0.999;

  # final global alignment of 3D model - x,y,t [m,m,deg]
  # this is used to align with 2D occupancy grid from envoy and also into ROS:
  # Set this to 0,0,0 to do no transformation:
  align_2d = [0,0,0] ;
  #align_2d = [11,-48,49.2] ;   # works with stata_3_4_2_with_obs_and_places.lcmlog 
  #align_2d = [92,17,120] ;   # works with 2nd floor png for ROS

  mode{
    table{
      floors=["table"];
    }
    editor_out{
      floors=["editor_out"];
    }
    floor01{
      floors=["stata_01"];
    }
    floor02{
      floors=["stata_02_meta_tri"];
    }
    floor03{
      floors=["stata_03"];
    }
    floor04{
      floors=["stata_04"];
    }
    floor05{
      floors=["stata_05"];
    }
    floor06{
      floors=["stata_06"];
    }
    floor07{
      floors=["stata_07"];
    }
    floor08{
      floors=["stata_08"];
    }
    floor09{
      floors=["stata_09"];
    }
    floors0203{
      floors=["stata_02_meta_tri","stata_03"];
    }
    floor02_kinect{
      floors=["stata_02_from_kinect"];
    }
    floor03_kinect{
      floors=["stata_03_from_kinect"];
    }
    floors0203_kinect{
      floors=["stata_02_from_kinect","stata_03_from_kinect"];
    }
    floor02_kinect_tri{
      floors=["stata_02_from_kinect_tri"];
    }
    floor03_kinect_tri{
      floors=["stata_03_from_kinect_tri"];
    }
    floors0203_kinect_tri{
      floors=["stata_02_from_kinect_tri","stata_03_from_kinect_tri"];
    }
    bottom{
      floors=["stata_01","stata_02_meta_tri","stata_03","stata_04"];
    }
    medialab{
      floors=["medialab"];
    }
  }

  motion{
    original{ # very noisy by works for most datasets
      # each group is the variance for: position, rpy, velocity, rpy angular rate:
      initial=[0.01, 0.001, 0.00001, 0.0000001];
      # when vo succeeds:
      success=[0.002 , 0.0004 , 0.0008 , 0.0003];
      # when vo fails, propogate with high noise
      failure=[0.003 , 0.004 , 0.0008 , 0.0003];
      wheelod=[0.001 , 0.001 , 0.0002 , 0.0001];
    }
    medium{ # in between, more than necessary but less then very noisy
      # each group is the variance for: position, rpy, velocity, rpy angular rate:
      initial=[0.01, 0.001, 0.00001, 0.0000001];
      # when vo succeeds:
      # worked just fine: success=[0.0006 , 0.0002 , 0.00012 , 0.00006];
      success=[0.00025 , 0.0002 , 0.00012 , 0.00006];
      # when vo fails, propogate with high noise
      failure=[0.003 , 0.004 , 0.0008 , 0.0003];
      wheelod=[0.001 , 0.001 , 0.0002 , 0.0001];
    }
    typical{ # lower noise, seems to be more realistic
      # each group is the variance for: position, rpy, velocity, rpy angular rate:
      initial=[0.01, 0.001, 0.00001, 0.0000001];
      # when vo succeeds:
      success=[0.00002 , 0.000004 , 0.000008 , 0.000003];
      # when vo fails, propogate with high noise
      failure=[0.003 , 0.004 , 0.0008 , 0.0003];
      wheelod=[0.001 , 0.001 , 0.0002 , 0.0001];
    }
  }

  model {
    table {
      path="/home/mfallon/projects/kmcl/kmcl/models/table_models/meta_model.ply";
      height = 0.0;
    }
    editor_out {
      path="/home/mfallon/data/models/stata_2nd_vslam/model.ply";
      height = 0.0;
    }
    stata_01 {
      path="/home/mfallon/projects/kmcl/kmcl/models/stata_models/stata_01.ply";
      height = 0.0;
    }
    stata_02 {
      path="/home/mfallon/projects/kmcl/kmcl/models/stata_models/stata_02.ply";
      height = 2.0;
    }
    stata_02_meta_tri {
      path="/home/mfallon/projects/kmcl/kmcl/models/stata_models/stata_02_meta_tri.ply";
      height = 2.0;
    }
    stata_02_from_kinect {
      path="/home/mfallon/projects/kmcl/kmcl/models/stata_models/stata_02_from_kinect.ply";
      height = 0.0;
    }
    stata_02_from_kinect_tri {
      path="/home/mfallon/projects/kmcl/kmcl/models/stata_models/stata_02_from_kinect_tri.ply";
      height = 0.0;
    }
    stata_03 {
      path="/home/mfallon/projects/kmcl/kmcl/models/stata_models/stata_03.ply";
      height = 7.128;
    }
    stata_03_from_kinect {
      path="/home/mfallon/projects/kmcl/kmcl/models/stata_models/stata_03_from_kinect.ply";
      height = 0.0;
    }
    stata_03_from_kinect_tri {
      path="/home/mfallon/projects/kmcl/kmcl/models/stata_models/stata_03_from_kinect_tri.ply";
      height = 0.0;
    }
    stata_04 {
      path="/home/mfallon/projects/kmcl/kmcl/models/stata_models/stata_04.ply";
      height = 0.0;
      #height = 11.99;
    }
    stata_05 {
      path="/home/mfallon/projects/kmcl/kmcl/models/stata_models/stata_05.ply";
      height = 15.65;
    }
    stata_06 {
      path="/home/mfallon/projects/kmcl/kmcl/models/stata_models/stata_06.ply";
      height = 19.3;
    }
    stata_07 {
      path="/home/mfallon/projects/kmcl/kmcl/models/stata_models/stata_07.ply";
      height = 22.96;
    }
    stata_08 {
      path="/home/mfallon/projects/kmcl/kmcl/models/stata_models/stata_08.ply";
      height = 26.62;
    }
    stata_09 {
      path="/home/mfallon/projects/kmcl/kmcl/models/stata_models/stata_09.ply";
      height = 29.21;
    }
    medialab {
      path="/home/mfallon/projects/kmcl/kmcl/models/stata_models/medialab.ply";
      height = 0.0;
    }
  }
}

# Vision SLAM settings
vision_slam {
  visualization {
    feature_tracks {
      enabled = false;
      lcm_channel="FEATURE_TRACK";
      every_match = false;
      track_length = 3;
      color_type = "depth";  #fixed      
      # Color used if color type is fixed
      #color = [1.0, 0.0, 0.0]
    }    
  }
  loop_proposal {
    # used for kmcl:
    # trained by hordur:
    vocabulary = "dbow_surf_9_5.voc";
    vocabulary_descriptor = "surf";

    #TODO might make sense to split up depending on loop proposal implementation
    # Filename of vocabulary to use for place recognition.
    #vocabulary = "stereo_surf_vocabulary.voc";
    #vocabulary = "calonder_vocabulary.txt";
    #vocabulary = "dbow_surf_9_5.voc";
    #vocabulary = "holidays.tree";
    #vocabulary = "hkmedians_K16_L4.bvoc";
    #vocabulary = "hkmedians_K10_L5.bvoc";
    #vocabulary = "hkmedians_K20_L3.bvoc";
    #####vocabulary = "hkmedians_K10_L6.bvoc";

    vocabulary_weights = "holidays.weights";

    #loop_proposal = "vt";
    loop_proposal = "dbow";
    #loop_proposal = "bbow";

    # Name of descriptor to use for place recognition.
    #vocabulary_descriptor = "calonder";
    #vocabulary_descriptor = "surf";
    ######vocabulary_descriptor = "brief";

    # Minimum time elapsed in seconds between frames before trying to register.
    min_time = 10;
    # Minimum score from loop proposal before trying alignment.
    min_score = 0.1;
    # Maximum number of frames to propose
    max_num_proposals = 10;
    # A time limit, in seconds, on how frequently a check for loop proposals is made.
    proposal_time_limit = 1.0;
  }
  loop_closure {
    # Name of descriptor to use for alignment (brief, surf, calonder)
    alignment_descriptor = "brief";  
    #alignment_descriptor = "calonder";  

    # Minimum number of inliers before accepting a loop closure.
    min_inliers = 20;
  }
  vocabulary_builder {
    # Filename of vocabulary file.
    vocabulary = "new_vocab.voc";
    vocabulary_type = "dbow";
    descriptor = "surf";
    dbow {
      k = 9;
      L = 3;
      stop_words = 0.01;
      descriptor_size = 176;
    }    
  }
  smoothed_map {
    isam {
      # Cost function to use "L2", "pseudo-huber"
      cost_function = "L2"; #"pseudo_huber"; 

      # Use incremental update - false or true
      incremental = false;

      verbose = false;
      quiet = false;

      force_numerical_jacobian = false;

      method = "gauss_newton";

      epsilon = 1e-4;
      epsilon_abs = 0.001;
      epsilon_rel = 0.00001;
      max_iterations = 3; #20;

      lm_lambda0 = 1e-6;
      lm_lambda_factor = 10.;

      dogleg = true;
      continuable = false;
      last_lambda = -1;

      mod_update = 1;
      mod_batch = 100;
      mod_solve = 10;
    }
  }
}

lidar {
  lcm_channel = "HOKUYO_LIDAR";
  spatial_decimation_thresh = 0.2;
  beam_skip = 3;
  max_range = 29.7;  
}

# Options for fovis
fovis {
  feature-window-size = 9;
  max-pyramid-level = 3;
  min-pyramid-level = 0;
  target-pixels-per-feature = 200;
  fast-threshold = 10;
  fast-threshold-adaptive-gain = 0.002;
  use-adaptive-threshold = "true";
  use-homography-initialization = "true";
  ref-frame-change-threshold = 150;

  # OdometryFrame
  use-bucketing = "true";
  bucket-width = 50;
  bucket-height = 50;
  max-keypoints-per-bucket = 10;
  use-image-normalization = "false";

  # MotionEstimator
  inlier-max-reprojection-error = 2.5;
  clique-inlier-threshold = 0.1;
  min-features-for-estimate = 20;
  max-mean-reprojection-error = 4.0;
  use-subpixel-refinement = "true";
  feature-search-window = 25;
  update-target-features-with-refined = "false";

  # StereoDepth
  stereo-require-mutual-match = "true";
  stereo-max-dist-epipolar-line = 2.0;
  stereo-max-refinement-displacement = 2.0;
  stereo-max-disparity = 128;
}

cameras {
    # ueye_wide_march_17_2011
    ueye_wide {
        lcm_channel = "CAMLCM_IMAGE";
        coord_frame = "stereo";
        type = "stereo";

        left {
            width = 752;
            height = 480;
            fx = 570.087;
            fy = 567.2;
            cx = 378.976;
            cy = 243.263;
            distortion_model = "plumb";
            k1 = -0.422035;
            k2 = 0.178349;
            k3 = 0;
            p1 = 0;
            p2 = 0;
        }

        right {
            width = 752;
            height = 480;
            fx = 570.087;
            fy = 567.2;
            cx = 373.295;
            cy = 235.284;
            distortion_model = "plumb";
            k1 = -0.398833;
            k2 = 0.144892;
            k3 = 0;
            p1 = 0;
            p2 = 0;
        }

        rotation = [0.999881, 0.0152938, -0.00190647, -0.0152595, 0.999742, 0.0168465, 0.00216362, -0.0168154, 0.999856];
        translation = [-0.271216, -0.000310378, -0.00690859];
    }

    # PR2, rectified
    pr2_stereo {
      lcm_channel = "CAMLCM_IMAGE";
      coord_frame = "stereo";
      type = "stereo";

      left {
          width = 640;
          height = 480;
          distortion_model = "plumb";
          fx = 384.68031999999999;
          fy = 384.68031999999999;
          cx = 351.323;
          cy = 254.138;
          k1 = 0.0;
          k2 = 0.0;
          k3 = 0.0;
          p1 = 0.0;
          p2 = 0.0;
      }

      right {
          width = 640;
          height = 480;
          distortion_model = "plumb";
          fx = 384.68031999999999;
          fy = 384.68031999999999;
          cx = 351.323;
          cy = 254.138;
          k1 = 0.0;
          k2 = 0.0;
          k3 = 0.0;
          p1 = 0.0;
          p2 = 0.0;
      }

      rotation = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];
      translation = [-0.0896544, 0.0, 0.0];
    }

    ueye_narrow {
      lcm_channel = "CAMLCM_IMAGE";
      coord_frame = "stereo";
      type = "stereo";

      left {
          width = 752;
          height = 480;
          distortion_model = "plumb";
          fx = 533.526786789;
          fy = 533.526786789;
          cx = 337.895721436;
          cy = 238.880491257;
          k1 = 0.0;
          k2 = 0.0;
          k3 = 0.0;
          p1 = 0.0;
          p2 = 0.0;
      }

      right {
          width = 752;
          height = 480;
          distortion_model = "plumb";
          fx = 533.526786789;
          fy = 533.526786789;
          cx = 337.895721436;
          cy = 238.880491257;
          k1 = 0.0;
          k2 = 0.0;
          k3 = 0.0;
          p1 = 0.0;
          p2 = 0.0;
      }

      rotation = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];
      translation = [-0.155024448135, 0.0, 0.0];
    }

    newcollege_stereo {
      lcm_channel = "IMAGE_STEREO";
      coord_frame = "stereo";
      type = "stereo";

      left {
          width = 512;
          height = 384;
          distortion_model = "plumb";
          fx = 389.956085;
          fy = 389.956085;
          cx = 254.903519;
          cy = 201.899490;
          k1 = 0.0;
          k2 = 0.0;
          k3 = 0.0;
          p1 = 0.0;
          p2 = 0.0;
      }

      right {
          width = 512;
          height = 384;
          distortion_model = "plumb";
          fx = 389.956085;
          fy = 389.956085;
          cx = 254.903519;
          cy = 201.899490;
          k1 = 0.0;
          k2 = 0.0;
          k3 = 0.0;
          p1 = 0.0;
          p2 = 0.0;
      }

      rotation = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];
      translation = [-0.120005, 0.0, 0.0];
    }

    ueye_wide_2011_04_21 {
      lcm_channel = "IMAGE_STEREO";
      coord_frame = "stereo";
      type = "stereo";

      left {
          width = 752;
          height = 480;
          distortion_model = "plumb";
          fx = 547.65232846;
          fy = 547.65232846;
          cx = 386.234132692;
          cy = 239.559544037;
          k1 = -0.38861277427;
          k2 = 0.136588795467;
          k3 = 0.0;
          p1 = 0.0;
          p2 = 0.0;
      }

      right {
          width = 752;
          height = 480;
          distortion_model = "plumb";
          fx = 547.65232846;
          fy = 547.65232846;
          cx = 380.866979892;
          cy = 237.491182572;
          k1 = -0.361154557529;
          k2 = 0.0921748687453;
          k3 = 0.0;
          p1 = 0.0;
          p2 = 0.0;
      }

      rotation = [0.999843407551, 0.0160001376615, -0.00756015685126, -0.0159359195638, 0.999837058873, 0.0084795147982, 0.00769459839486, -0.00835770891874, 0.999935468846];
      translation = [-0.267534312181, 0.000109077400069, -0.0119906289315];
    }

    # s/n 0332100188 - original and only psdk. was "psdk"
    marine_psdk_2 {
        lcm_channel = "OPENNI_FRAME";
        coord_frame = "camera";
        type = "openni";

        rgb {
            width = 640;
            height = 480;

            fx = 538.67;
            fy = 540.414;
            cx = 323.711;
            cy = 245.432;
        }

        depth {
            width = 640;
            height = 480;

            fx = 568.284;
            fy = 564.552;
            cx = 329.061;
            cy = 254.306;
        }

        shift_offset = 1090;
        projector_depth_baseline = 7.50000030e-02;

        # TODO: Need to redo the extrinsics for the PSDK (08-31-2011)
        rotation = [9.9993764381493289e-01, 1.1996001518643428e-03,
    		-1.1102677213905385e-02, -1.2212530944426727e-03,
    		9.9999736533871642e-01, -1.9436708839395763e-03,
    		1.1100316334224038e-02, 1.9571088629423005e-03,
    		9.9993647433333421e-01];
        translation = [2.5783973008807439e-02, -1.9418604569335543e-04, 9.3017318598686736e-04];
       
    }

    # 320 pixel s/n 0332100188 - original and only psdk. was "psdk_320"
    marine_psdk_2_320 {
        lcm_channel = "OPENNI_FRAME";
        coord_frame = "camera";
        type = "openni";

        rgb {
            width = 320;
            height = 240;

            fx = 269.335;
            fy = 270.207;
            cx = 161.8555;
            cy = 122.716;
        }

        depth {
            width = 320;
            height = 240;

            fx = 284.142;
            fy = 282.276;
            cx = 164.5305;
            cy = 127.153;
        }

        shift_offset = 1090;
        projector_depth_baseline = 7.50000030e-02;

        # TODO: Need to redo the extrinsics for the PSDK (08-31-2011)
        rotation = [9.9993764381493289e-01, 1.1996001518643428e-03,
    		-1.1102677213905385e-02, -1.2212530944426727e-03,
    		9.9999736533871642e-01, -1.9436708839395763e-03,
    		1.1100316334224038e-02, 1.9571088629423005e-03,
    		9.9993647433333421e-01];
        translation = [2.5783973008807439e-02, -1.9418604569335543e-04, 9.3017318598686736e-04];
       
    }


    # s/n b9iwpa000879
    marine_asus_2 {
        lcm_channel = "OPENNI_FRAME";
        coord_frame = "camera";
        type = "openni";

        rgb {
            width = 640;
            height = 480;

            fx = 537.874;
            fy = 537.953;
            cx = 317.019;
            cy = 242.859;
        }

        # HJ: I have to double check and see what intrinsic
        #     fovis uses when using openni data.
        depth {
            width = 640;
            height = 480;

            fx = 572.156;
            fy = 572.362;
            cx = 320.705;
            cy = 245.120;
        }

        shift_offset = 1090;
        projector_depth_baseline = 7.50000030e-02;

        # Using OpenNI both should be in the same reference frome
        rotation = [1.0, 0.0, 0.0, 
                    0.0, 1.0, 0.0,
                    0.0, 0.0, 1.0];
        translation = [0.0, 0.0, 0.0];
       
    }

    # only used to push the rgb to the collabmap_viewer
    kinect_rgb {
      lcm_channel = "KINECT_RGB";
      coord_frame = "stereo";
      type = "stereo";

      left {
          width = 752;
          height = 480;
          distortion_model = "plumb";
          fx = 547.65232846;
          fy = 547.65232846;
          cx = 386.234132692;
          cy = 239.559544037;
          k1 = -0.38861277427;
          k2 = 0.136588795467;
          k3 = 0.0;
          p1 = 0.0;
          p2 = 0.0;
      }

      right {
          width = 752;
          height = 480;
          distortion_model = "plumb";
          fx = 547.65232846;
          fy = 547.65232846;
          cx = 380.866979892;
          cy = 237.491182572;
          k1 = -0.361154557529;
          k2 = 0.0921748687453;
          k3 = 0.0;
          p1 = 0.0;
          p2 = 0.0;
      }

      rotation = [0.999843407551, 0.0160001376615, -0.00756015685126, -0.0159359195638, 0.999837058873, 0.0084795147982, 0.00769459839486, -0.00835770891874, 0.999935468846];
      translation = [-0.267534312181, 0.000109077400069, -0.0119906289315];
    }

    kinect_depth {
      lcm_channel = "KINECT_DEPTH";
      coord_frame = "stereo";
      type = "stereo";

      left {
          width = 752;
          height = 480;
          distortion_model = "plumb";
          fx = 547.65232846;
          fy = 547.65232846;
          cx = 386.234132692;
          cy = 239.559544037;
          k1 = -0.38861277427;
          k2 = 0.136588795467;
          k3 = 0.0;
          p1 = 0.0;
          p2 = 0.0;
      }

      right {
          width = 752;
          height = 480;
          distortion_model = "plumb";
          fx = 547.65232846;
          fy = 547.65232846;
          cx = 380.866979892;
          cy = 237.491182572;
          k1 = -0.361154557529;
          k2 = 0.0921748687453;
          k3 = 0.0;
          p1 = 0.0;
          p2 = 0.0;
      }

      rotation = [0.999843407551, 0.0160001376615, -0.00756015685126, -0.0159359195638, 0.999837058873, 0.0084795147982, 0.00769459839486, -0.00835770891874, 0.999935468846];
      translation = [-0.267534312181, 0.000109077400069, -0.0119906289315];
    }

    # this calibration is from the Kinect used by the rrg group
    kinect {
        lcm_channel = "KINECT_FRAME";
        coord_frame = "kinect";
        type = "primesense";

        rgb {
            width = 640;
            height = 480;

            fx = 576.09757860;
            fy = 576.09757860;
            cx = 321.06398107;
            cy = 242.97676897;

            #distortion_model = "plumb";
            #k1 = -3.8861277426970980e-01;
            #k2 = 1.3658879546745739e-01;
            #k3 = 0.;
            #p1 = 0.;
            #p2 = 0.;
        }

        depth {
            width = 640;
            height = 480;

            fx = 576.09757860;
            fy = 576.09757860;
            cx = 321.06398107;
            cy = 242.97676897;

            #distortion_model = "plumb";
            #k1 = -3.6115455752927456e-01;
            #k2 = 9.2174868745340310e-02;
            #k3 = 0.;
            #p1 = 0.;
            #p2 = 0.;
        }

        shift_offset = 1079.4753;
        projector_depth_baseline = 0.07214;

        rotation = [0.999999, -0.000796, 0.001256, 0.000739, 0.998970, 0.045368, -0.001291, -0.045367, 0.998970];
        translation = [-0.015756, -0.000923, 0.002316];
    }
    
    # this calibration is from the Kinect used by the marine group
    kinect_marine {
        lcm_channel = "KINECT_FRAME";
        coord_frame = "kinect";
        type = "primesense";

        rgb {
            width = 640;
            height = 480;

            fx = 5.7059425732172076e+02;
            fy = 5.7060941894705400e+02;
            cx = 3.2287709398073190e+02;
            cy = 2.4433609830914622e+02;
        }

        depth {
            width = 640;
            height = 480;

            fx = 5.1558457256956194e+02;
            fy = 5.1575506420208967e+02;
            cx = 3.1836287911397608e+02;
            cy = 2.5620308746398820e+02;
        }

        shift_offset = 1090;
        projector_depth_baseline = 7.50000030e-02;

        rotation = [9.9993764381493289e-01, 1.1996001518643428e-03,
    		-1.1102677213905385e-02, -1.2212530944426727e-03,
    		9.9999736533871642e-01, -1.9436708839395763e-03,
    		1.1100316334224038e-02, 1.9571088629423005e-03,
    		9.9993647433333421e-01];
        translation = [2.5783973008807439e-02, -1.9418604569335543e-04, 9.3017318598686736e-04];
    }
    

    # this calibration is from the PSDK used by the marine group [by hordur]
    asus {
        lcm_channel = "OPENNI_FRAME";
        coord_frame = "camera";
        type = "openni";

        rgb {
            width = 640;
            height = 480;

            fx = 537.874;
            fy = 537.953;
            cx = 317.019;
            cy = 242.859;
        }

        # HJ: I have to double check and see what intrinsic
        #     fovis uses when using openni data.
        depth {
            width = 640;
            height = 480;

            fx = 572.156;
            fy = 572.362;
            cx = 320.705;
            cy = 245.120;
        }

        shift_offset = 1090;
        projector_depth_baseline = 7.50000030e-02;

        # Using OpenNI both should be in the same reference frome
        rotation = [1.0, 0.0, 0.0, 
                    0.0, 1.0, 0.0,
                    0.0, 0.0, 1.0];
        translation = [0.0, 0.0, 0.0];
       
    }

    ueye_23_06 {
        lcm_channel = "IMAGE_STEREO";
        coord_frame = "stereo";
        type = "stereo";
        left {
            width = 752;
            height = 480;
            fx = 592.787;
            fy = 593.326;
            cx = 372.906;
            cy = 239.581;
            distortion_model = "plumb";
            k1 = -0.452559;
            k2 = 0.234448;
            k3 = 0;
            p1 = 0;
            p2 = 0;
        }

        right {
            width = 752;
            height = 480;
            fx = 592.787;
            fy = 593.326;
            cx = 372.457;
            cy = 238.025;
            distortion_model = "plumb";
            k1 = -0.429348;
            k2 = 0.179752;
            k3 = 0;
            p1 = 0;
            p2 = 0;
        }

        rotation = [0.999826, 0.0148971, -0.0112075, -0.0147928, 0.999847, 0.00933387, 0.0113448, -0.00916646, 0.999894];
        translation = [-0.271861, -6.7689e-05, -0.00620688];
    }

    jmcd_stereo {
      lcm_channel = "BUMBLEBEE2_RAW";
      coord_frame = "stereo";
      type = "stereo";

      left {
          width = 1024;
          height = 768;
          distortion_model = "plumb";
          fx = 8.3997123954738106e+02;
          fy = 8.3997123954738106e+02;
          cx = 5.1672071884973627e+02;
          cy = 3.9257838221390421e+02;
          k1 = -3.6102289446719543e-01;
          k2 = 1.6169482800561447e-01;
          k3 = 0.0;
          p1 = 0.0;
          p2 = 0.0;
      }

      right {
          width = 1024;
          height = 768;
          distortion_model = "plumb";
          fx = 8.3997123954738106e+02;
          fy = 8.3997123954738106e+02;
          cx = 5.1634837655502668e+02;
          cy = 3.9265195401881817e+02;
          k1 = -3.6651532004754611e-01;
          k2 = 1.7352385137716123e-01;
          k3 = 0.0;
          p1 = 0.0;
          p2 = 0.0;
      }

      rotation = [ 9.9998876778520474e-01, -2.7229793732209320e-03, -3.8793925762955197e-03,
                   2.7262826373192113e-03,  9.9999592543893245e-01,  8.4645644576545058e-04, 
                   3.8770718860314229e-03, -8.5702325880889288e-04,  9.9999211688129042e-01];

      translation = [-3.2234683134412384e-01, -1.9253185439805723e-05, 6.5087455961914224e-03];
    }

    jmcd_stereo_small {
      lcm_channel = "BUMBLEBEE2_IMAGE";
      coord_frame = "stereo";
      type = "stereo";

      left {
          width = 512;
          height = 384;
          distortion_model = "plumb";
          fx = 4.1301164795076573e+02;
          fy = 4.1301164795076573e+02;
          cx = 2.6029000170036994e+02;
          cy = 1.9543983489840392e+02;
          k1 = -3.4906709865856539e-01;
          k2 = 1.4506985467765568e-01;
          k3 = 0.0;
          p1 = 0.0;
          p2 = 0.0;
      }

      right {
          width = 512;
          height = 384;
          distortion_model = "plumb";
          fx = 4.1301164795076573e+02;
          fy = 4.1301164795076573e+02;
          cx = 2.6012713398721905e+02;
          cy = 1.9601163263195997e+02;
          k1 = -3.6011899481185050e-01;
          k2 = 1.6187522902360726e-01;
          k3 = 0.0;
          p1 = 0.0;
          p2 = 0.0;
      }

      rotation = [ 9.9998391929040986e-01, -2.1289205041938220e-03, -5.2563160177015542e-03,
                   2.1311158192580085e-03,  9.9999764426199012e-01,  4.1208716927503274e-04,
                   5.2554263343739371e-03, -4.2328236083726006e-04,  9.9998610056644643e-01];

      translation = [-1.1912332491259187e-01, -1.0324932848627731e-03, 2.2304214149842282e-03];
    }

    rawseeds_bicocca {
        lcm_channel = "IMAGE_STEREO";
        coord_frame = "stereo";
        type = "stereo";
        left {
            width = 640;
            height = 480;
            fx = 6.604720072425989e2;
            fy = 6.604720072425989e2;
            cx = 3.160922999727285e2;
            cy = 2.142798093473395e2;
            distortion_model = "plumb";
            k1 = -0.270077304858834;
            k2 = 0;
            k3 = 0.198230912855217;
            p1 = -0.000131430244570;
            p2 = 0;
        }

        right {
            width = 640;
            height = 480;
            fx = 6.647630154214031e2;
            fy = 6.647630154214031e2;
            cx = 3.273481117704479e2;
            cy = 2.453608840023571e2;
            distortion_model = "plumb";
            k1 = -0.293857248831788;
            k2 = 0.141264589242246;
            k3 = 0;
            p1 = 0;
            p2 = 0.001794955905251;
        }

        rotation = [0.999952418583, -0.00556693821264, -0.00801060349632, 0.00555247896072, 0.99998291748, -0.00182612326339, 0.0080206325704, 0.00178155766648, 0.999966247183];
        translation = [-180.842489641e-03, -0.607324224744e-03, -4.41412548475e-03];

    }

    feature_track {
      lcm_channel = "FEATURE_TRACK";
      coord_frame = "camera";
    }
}


models {
    #wheelchair {
    #    wavefront_model = "copley/A204-R1.obj";
    #    translate = [-0.4774696935, -0.288993438, 0];
    #    rotate_xyz = [90, 0, 0];
    #    scale = 0.001;
    #}
    wheelchair {
        wavefront_model = "wheelchair/wavefront/ElectricWheelchairl.obj";
        translate = [-0.4774696935, -0.288993438, 0];
        rotate_xyz = [90, 0, 0];
        scale = 0.001;
    }
    person {
        wavefront_model = "person/walking_person.obj";
        translate = [-2, -0.7, 0];
        rotate_xyz = [90, 0, 0];
        scale = 0.02;
    }
    #person {
    #    wavefront_model = "person/dalek_modified_works_wo_mtl.obj";
    #    translate = [0.1, 0, 0];
    #    rotate_xyz = [90, 0, -90];
    #    scale = 0.29;
    #}
}



articulated_body_name {
#  body1 {
#    frame = "laser";
#    visualization = "cylinder";
#    scale  = [1, 2, 3];
#    translation = [.5, 1, 1.5];
#    rpy = [0,0,0];
#    color = [0, 1, 0, 1];
#  }

  body2 {
    frame = "camera";
    visualization = "cube";
    scale  = [.001, .001, .001];
    translation = [1.5, 1, .5];
    rpy = [0,0,0];
    color = [1, 0, 0, 1];
  }
}


    planar_lidars {
        # One Hokuyo UTM-30LX LIDAR
        SKIRT_FRONT {
            #position = [.44, .0, .1]; # Original (manual)
            #rpy      = [0, 0, 0]; # Original (manual)
            position = [0.4581, -0.0042, 0.1];     # Based on 07-29-11 calibration
            rpy      = [-0.84, 1.6, 0.3715];       # Based on 08/10/11 IMU measurement
            relative_to = "body";
            coord_frame = "laser";
        }
        SKIRT_REAR {
        
            position =[-0.42, -.02, .1]; #[.44, .0, .1]; # Original (manual)                                                                                                                                                               \
            rpy      = [ 0, 0, -180.8];#[0, 0, 0];        # Original (manual)     
            relative_to = "body";
            coord_frame = "laser";
        }
        laser {
            lcm_channel ="TOP_LASER";
            position = [.094, -.276, .1];    
            rpy      = [0, 0, 0];
            relative_to = "body";
            coord_frame = "laser";
        }
    }


calibration{
    planar_lidars {
        # One Hokuyo UTM-30LX LIDAR
        SKIRT_FRONT {
            #position = [.44, .0, .1]; # Original (manual)
            #rpy      = [0, 0, 0]; # Original (manual)
            position = [0.4581, -0.0042, 0.1];     # Based on 07-29-11 calibration
            rpy      = [-0.84, 1.6, 0.3715];       # Based on 08/10/11 IMU measurement
            relative_to = "body";
            coord_frame = "laser";
        }
        SKIRT_REAR {
        
            position =[-0.42, -.02, .1]; #[.44, .0, .1]; # Original (manual)                                                                                                                                                               \
            rpy      = [ 0, 0, -180.8];#[0, 0, 0];        # Original (manual)     
            relative_to = "body";
            coord_frame = "laser";
        }
        TOP_LASER {
            lcm_channel ="TOP_LASER";
            position = [.094, -.276, .1];    
            rpy      = [0, 0, 0];
            relative_to = "body";
            coord_frame = "laser";
        }
    }

    velodyne {
	model = "HDL_32E";
	channel = "SEG_VELODYNE";
        #	x_vs = [-0.11,0,-1.35,180,-30,0];
        x_vs = [-0.11,0,-1.35,180,0,0];
        x_lr = [0,0,0,0,0,0];
	intrinsic_calib_file = "velodyne/HDL32E_segway_db.xml";
    }
    
    # Ad-hoc methods used; assumed laser is level, and at body center... we should probably fix the center part
    # Used some manually-measured quantities

    # All in meters
    vehicle_bounds { # Changed width from +/- 0.3 to +/- 0.4
        front_left  = [.5,.4];
        front_right = [.5,-.4];
        rear_left   = [-.5,.4];
        rear_right  = [-.5,-.4];
    }
    
    calibration_to_body {
        position    = [0,0,0];
        orientation = [1,0,0,0];
    }
}

# Coordinate frames
#coordinate_frames {
#   root_frame = "local";                 #a root_frame must be defined
#
#   camera {
#     relative_to = "local";
#     history = 0;
#
#     initial_transform{
#       translation = [ 0, 0, 0 ];
#       rpy = [ 0, 0, 0 ];
#     }
#   }
#}



coordinate_frames {
  root_frame = "local";

  body {
    relative_to = "local";
    history = 1000;
    #pose_update_channel = "PARTICLE_MEAN";      #bot_core_pose_t messages will be listened for this channel
    pose_update_channel = "POSE";      #bot_core_pose_t messages will be listened for this channel
    initial_transform{
      translation = [ 0, 0, 0 ];
      quat = [ 1, 0, 0, 0 ];
    }
  }

  global {
      relative_to = "local";
      history = 1000;
      update_channel = "GLOBAL_TO_LOCAL";
      initial_transform {
          translation = [0, 0, 0 ];
          quat = [1, 0, 0, 0];
      }
  }

  laser {
    relative_to = "body";
    history = 0;
    update_channel = "";
    initial_transform{
      translation = [ 0, 0, 0 ];
      rpy = [ 0, 0, 0 ];
    }
  }
  camera {
    relative_to = "body";
    history = 0;
    initial_transform{
      translation = [ 1, 0, 0 ];
      rodrigues = [ 0, 0, 0 ];
    }
  }
#etc...
}

robot{
    length     = 1.09;
    width      = 0.65;        # 0.58 was used ***consider changin this 
    wheel_base = 1.486;         # front to back distance, value taken from agile, needs to be changed
    odometry_inverted  = 0; 
    laser1_offset      = 0.44; #these things are repeated - probably can use the laser as the source
    frontlaser_offset  = 0.44; 
    frontlaser_flipped = 0;    

    frontlaser_use            = 1;
    frontlaser_side_offset    = 0.0;
    frontlaser_angular_offset = 0.0;  #-0.785398163#45#0.0  #sachi added to new carmen
    frontlaser_id             = 1;    #sachi added

    rearlaser_offset      = -0.42;
    laser2_offset         = -0.42;      
    rearlaser_side_offset = 0.0;
    rearlaser_flipped     = 0;
    rearlaser_angular_offset = -3.1415926535897931;
    rearlaser_use            = 1;
    rearlaser_id             = 2;    #sachi added

    frontlaser_ignore_first_n_beams = 0;  # avoid self-occlusion
    frontlaser_ignore_last_n_beams  = 0; #not sure if these are used

    rearlaser_ignore_first_n_beams = 10;   # avoid self-occlusion
    rearlaser_ignore_last_n_beams  = 10;    # avoid self-occlusion
    
    min_approach_dist = 0.4; #was 0.1 sachi changed to 0.2
    min_side_dist     = 0.1;  #sachi changed
    acceleration      = 0.3; #was 0.2 - increased for person following         # m/s^2    sachi 0.3
    deceleration      = 0.3; #was 0.2 - increased for person following         # m/s^2    sac 0.3
    reaction_time     = 0.1;
    ##The following gain values were tested and found to work adquetly for 40% power on the wheelchair 
    sensor_timeout     = 3.0;

    max_t_vel          = 1.5; #  - this is the value for best person following#1.0#1.5 #m/s #increased for person following - not sure if this will screw with the dynamics
    max_r_vel          = 5.0;# - the value used for best person following#rad/s 
    theta_gain         = 4.0;#2.0#not used for velocity commands
    theta_d_gain       = 2.0;#not used for velocity commands
    displacement_gain  = 4.0;#2.0#5.0
    allow_rear_motion  = 0; #off#on
    rectangular        = 0;
    use_sonar          = 0;
    use_laser          = 1;        
    use_laser1         = 1;
    use_laser2         = 0;
    use_laser3         = 0;
    use_laser4         = 0;
    use_laser5         = 0;
    use_front_laser    = 0;
    use_back_laser     = 0;
    collision_avoidance = 0;
}

navigator{
    goal_size            = 0.8;
    goal_theta_tolerance = 1.5;
    ignore_new_goals_until_completed = 0;
    waypoint_tolerance   = 0.3;
    
    min_approach_dist = 0.3;
    min_side_dist     = 0.1;

    robot_length      = .75;
    robot_width       = 0.5;#.75;
    

    replan_frequency  = 5;
    smooth_path       = true;#false;#true;
    plan_to_nearest_free_point = true;
}

simulator{
    simulate_frontlaser = 0;
    simulate_rearlaser  = 0;
    dt                  = 0.025;
    time                = 0.025;
    sync_mode           = 0; #0/1 
    use_robot           = 0; #was called off - make sure compatible
    acceleration        = 1.0;#0.5;
    rot_acceleration    = 5.0;#2.0;

    person_leg_width    = 0.1;
    person_dist_from_robot = 0.4;
    person_speed        = 0.3;

    laser_probability_of_random_max     = .0001;
    laser_probability_of_random_reading = .0001;
    laser_sensor_variance               = .0001;
}

localizer{
    mean_c_d    = -0.0182;
    mean_c_t    = -0.105;
    std_dev_c_d = 0.0;
    std_dev_c_t = 0.0612;

    mean_d_d    = 1.0065;
    mean_d_t    = -0.0072;
    std_dev_d_d = 0.0932;
    std_dev_d_t = 0.0000;

    mean_t_d    = 0.0144;
    mean_t_t    = 0.8996;
    std_dev_t_d = 0.00;
    std_dev_t_t = 0.3699;

    num_particles   = 1000;#5000
    laser_max_range = 30.0;
    use_rear_laser  = false; #off
    tracking_beam_minlikelihood = 0.45;
    global_beam_minlikelihood   = 0.9;

    odom_a1 = 0.2;    # a1 = error in rotation
                      # as a function of rotation
    odom_a2 = 0.01;    # a2 = error in rotation
                    # as a function of translation
    odom_a3 = 0.2;    # a3 = error in translation
                                        # as a function of translation
    odom_a4 = 0.01;

    robot_particles  = 1000;#5000            # number of samples
    use_front_laser  = false; #off
    use_laser1       = true;#on
    use_laser2       = false;#  off
    use_laser3       = false;
    use_laser4       = false;
    use_laser5       = false;
    min_wall_prob    = 0.5; #0.5;   #was 0.25 Sachi changed ZMay 20
    outlier_fraction = 0.85;
    #might need to decrease these values
    update_distance  = 0.20; #was 0.2
    update_heading   = 0.20;
    ## integrate a beam each n rads (new version of laser_skip)
    integrate_angle  = 0.15; ## 0.052359   ## 3 degrees
    integrate_angle_deg  = 3.0;
    do_scanmatching  = false; #off    #was off
    constrain_to_map = false; #off    #was off
    occupied_prob    = 0.5;
    lmap_std         = 0.3;
    global_lmap_std  = 0.6;
    global_evidence_weight = 0.01;
    global_distance_threshold = 2.0;
    global_test_samples = 1000000; #was 100000
    use_sensor          = true; 
    tracking_beam_minlikelihood = 0.45;
    global_beam_minlikelihood = 0.9;    
}

